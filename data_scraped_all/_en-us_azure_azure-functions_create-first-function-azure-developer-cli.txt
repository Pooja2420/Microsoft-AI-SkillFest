Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Quickstart: Create and deploy functions to Azure Functions using the Azure Developer CLI
Article
2024-10-19
1 contributor
In this article
In this Quickstart, you use Azure Developer command-line tools to create functions that respond to HTTP requests. After testing the code locally, you deploy it to a new serverless function app you create running in a Flex Consumption plan in Azure Functions.
The project source uses the Azure Developer CLI (azd) to simplify deploying your code to Azure. This deployment follows current best practices for secure and scalable Azure Functions deployments.
By default, the Flex Consumption plan follows apay-for-what-you-usebilling model, which means to complete this quickstart incurs a small cost of a few USD cents or less in your Azure account.
Prerequisites
An Azure account with an active subscription.Create an account for free.
An Azure account with an active subscription.Create an account for free.
Azure Developer CLI.
Azure Developer CLI.
Azure Functions Core Tools.
Azure Functions Core Tools.
.NET 8.0 SDK
.NET 8.0 SDK
Azurite storage emulator
Azurite storage emulator
Java 17 Developer KitIf you use anothersupported version of Java, you must update the project's pom.xml file.TheJAVA_HOMEenvironment variable must be set to the install location of the correct version of the JDK.
If you use anothersupported version of Java, you must update the project's pom.xml file.
TheJAVA_HOMEenvironment variable must be set to the install location of the correct version of the JDK.
JAVA_HOME
Apache Maven 3.8.x
Node.js 20
PowerShell 7.2
PowerShell 7.2
.NET 6.0 SDK
.NET 6.0 SDK
Python 3.11.
Asecure HTTP test toolfor sending requests with JSON payloads to your function endpoints. This article usescurl.
curl
Initialize the project
You can use theazd initcommand to create a local Azure Functions code project from a template.
azd init
In your local terminal or command prompt, run thisazd initcommand in an empty folder:azd init --template functions-quickstart-dotnet-azd -e flexquickstart-dotnetThis command pulls the project files from thetemplate repositoryand initializes the project in the current folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
In your local terminal or command prompt, run thisazd initcommand in an empty folder:
azd init
azd init --template functions-quickstart-dotnet-azd -e flexquickstart-dotnet
azd init --template functions-quickstart-dotnet-azd -e flexquickstart-dotnet
This command pulls the project files from thetemplate repositoryand initializes the project in the current folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
-e
azd
Run this command to navigate to thehttpapp folder:cd http
Run this command to navigate to thehttpapp folder:
http
cd http
cd http
Create a file namedlocal.settings.jsonin thehttpfolder that contains this JSON data:{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet-isolated"
    }
}This file is required when running locally.
Create a file namedlocal.settings.jsonin thehttpfolder that contains this JSON data:
http
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet-isolated"
    }
}
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet-isolated"
    }
}
This file is required when running locally.
In your local terminal or command prompt, run thisazd initcommand in an empty folder:azd init --template azure-functions-java-flex-consumption-azd -e flexquickstart-javaThis command pulls the project files from thetemplate repositoryand initializes the project in the current folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
In your local terminal or command prompt, run thisazd initcommand in an empty folder:
azd init
azd init --template azure-functions-java-flex-consumption-azd -e flexquickstart-java
azd init --template azure-functions-java-flex-consumption-azd -e flexquickstart-java
This command pulls the project files from thetemplate repositoryand initializes the project in the current folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
-e
azd
Run this command to navigate to thehttpapp folder:cd http
Run this command to navigate to thehttpapp folder:
http
cd http
cd http
Create a file namedlocal.settings.jsonin thehttpfolder that contains this JSON data:{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "java"
    }
}This file is required when running locally.
Create a file namedlocal.settings.jsonin thehttpfolder that contains this JSON data:
http
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "java"
    }
}
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "java"
    }
}
This file is required when running locally.
In your local terminal or command prompt, run thisazd initcommand in an empty folder:azd init --template functions-quickstart-javascript-azd -e flexquickstart-jsThis command pulls the project files from thetemplate repositoryand initializes the project in the root folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
In your local terminal or command prompt, run thisazd initcommand in an empty folder:
azd init
azd init --template functions-quickstart-javascript-azd -e flexquickstart-js
azd init --template functions-quickstart-javascript-azd -e flexquickstart-js
This command pulls the project files from thetemplate repositoryand initializes the project in the root folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
-e
azd
Create a file namedlocal.settings.jsonin the root folder that contains this JSON data:{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "node"
    }
}This file is required when running locally.
Create a file namedlocal.settings.jsonin the root folder that contains this JSON data:
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "node"
    }
}
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "node"
    }
}
This file is required when running locally.
In your local terminal or command prompt, run thisazd initcommand in an empty folder:azd init --template functions-quickstart-powershell-azd -e flexquickstart-psThis command pulls the project files from thetemplate repositoryand initializes the project in the root folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
In your local terminal or command prompt, run thisazd initcommand in an empty folder:
azd init
azd init --template functions-quickstart-powershell-azd -e flexquickstart-ps
azd init --template functions-quickstart-powershell-azd -e flexquickstart-ps
This command pulls the project files from thetemplate repositoryand initializes the project in the root folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
-e
azd
Run this command to navigate to thesrcapp folder:cd src
Run this command to navigate to thesrcapp folder:
src
cd src
cd src
Create a file namedlocal.settings.jsonin thesrcfolder that contains this JSON data:{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "powershell",
        "FUNCTIONS_WORKER_RUNTIME_VERSION": "7.2"
    }
}This file is required when running locally.
Create a file namedlocal.settings.jsonin thesrcfolder that contains this JSON data:
src
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "powershell",
        "FUNCTIONS_WORKER_RUNTIME_VERSION": "7.2"
    }
}
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "powershell",
        "FUNCTIONS_WORKER_RUNTIME_VERSION": "7.2"
    }
}
This file is required when running locally.
In your local terminal or command prompt, run thisazd initcommand in an empty folder:azd init --template functions-quickstart-typescript-azd -e flexquickstart-tsThis command pulls the project files from thetemplate repositoryand initializes the project in the root folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
In your local terminal or command prompt, run thisazd initcommand in an empty folder:
azd init
azd init --template functions-quickstart-typescript-azd -e flexquickstart-ts
azd init --template functions-quickstart-typescript-azd -e flexquickstart-ts
This command pulls the project files from thetemplate repositoryand initializes the project in the root folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
-e
azd
Create a file namedlocal.settings.jsonin the root folder that contains this JSON data:{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "node"
    }
}This file is required when running locally.
Create a file namedlocal.settings.jsonin the root folder that contains this JSON data:
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "node"
    }
}
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "node"
    }
}
This file is required when running locally.
In your local terminal or command prompt, run thisazd initcommand in an empty folder:azd init --template functions-quickstart-python-http-azd -e flexquickstart-pyThis command pulls the project files from thetemplate repositoryand initializes the project in the root folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
In your local terminal or command prompt, run thisazd initcommand in an empty folder:
azd init
azd init --template functions-quickstart-python-http-azd -e flexquickstart-py
azd init --template functions-quickstart-python-http-azd -e flexquickstart-py
This command pulls the project files from thetemplate repositoryand initializes the project in the root folder. The-eflag sets a name for the current environment. Inazd, the environment is used to maintain a unique deployment context for your app, and you can define more than one. It's also used in the name of the resource group you create in Azure.
-e
azd
Create a file namedlocal.settings.jsonin the root folder that contains this JSON data:{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "python"
    }
}This file is required when running locally.
Create a file namedlocal.settings.jsonin the root folder that contains this JSON data:
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "python"
    }
}
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "python"
    }
}
This file is required when running locally.
Create and activate a virtual environment
In the root folder, run these commands to create and activate a virtual environment named.venv:
.venv
Linux/macOS
Windows (bash)
Windows (Cmd)
python3 -m venv .venv
source .venv/bin/activate
python3 -m venv .venv
source .venv/bin/activate
If Python didn't install the venv package on your Linux distribution, run the following command:
sudo apt-get install python3-venv
sudo apt-get install python3-venv
py -m venv .venv
source .venv/scripts/activate
py -m venv .venv
source .venv/scripts/activate
py -m venv .venv
.venv\scripts\activate
py -m venv .venv
.venv\scripts\activate
Run in your local environment
Run this command from your app folder in a terminal or command prompt:func startmvn clean package
mvn azure-functions:runnpm install
func startnpm install
npm startWhen the Functions host starts in your local project folder, it writes the URL endpoints of your HTTP triggered functions to the terminal output.
Run this command from your app folder in a terminal or command prompt:
func start
func start
mvn clean package
mvn azure-functions:run
mvn clean package
mvn azure-functions:run
npm install
func start
npm install
func start
npm install
npm start
npm install
npm start
When the Functions host starts in your local project folder, it writes the URL endpoints of your HTTP triggered functions to the terminal output.
In your browser, navigate to thehttpgetendpoint, which should look like this URL:http://localhost:7071/api/httpget
In your browser, navigate to thehttpgetendpoint, which should look like this URL:
httpget
http://localhost:7071/api/httpget
From a new terminal or command prompt window, run thiscurlcommand to send a POST request with a JSON payload to thehttppostendpoint:curl -i http://localhost:7071/api/httppost -H "Content-Type: text/json" -d @testdata.jsoncurl -i http://localhost:7071/api/httppost -H "Content-Type: text/json" -d "@src/functions/testdata.json"This command reads JSON payload data from thetestdata.jsonproject file. You can find examples of both HTTP requests in thetest.httpproject file.
From a new terminal or command prompt window, run thiscurlcommand to send a POST request with a JSON payload to thehttppostendpoint:
curl
httppost
curl -i http://localhost:7071/api/httppost -H "Content-Type: text/json" -d @testdata.json
curl -i http://localhost:7071/api/httppost -H "Content-Type: text/json" -d @testdata.json
curl -i http://localhost:7071/api/httppost -H "Content-Type: text/json" -d "@src/functions/testdata.json"
curl -i http://localhost:7071/api/httppost -H "Content-Type: text/json" -d "@src/functions/testdata.json"
This command reads JSON payload data from thetestdata.jsonproject file. You can find examples of both HTTP requests in thetest.httpproject file.
testdata.json
test.http
When you're done, press Ctrl+C in the terminal window to stop thefunc.exehost process.
When you're done, press Ctrl+C in the terminal window to stop thefunc.exehost process.
func.exe
Rundeactivateto shut down the virtual environment.
deactivate
Review the code (optional)
You can review the code that defines the two HTTP trigger function endpoints:
httpget
httpget
httppost
httppost
[Function("httpget")]
       public IActionResult Run([HttpTrigger(AuthorizationLevel.Function, "get")]
         HttpRequest req,
         string name)
       {
           var returnValue = string.IsNullOrEmpty(name)
               ? "Hello, World."
               : $"Hello, {name}.";

           _logger.LogInformation($"C# HTTP trigger function processed a request for {returnValue}.");

           return new OkObjectResult(returnValue);
       }
[Function("httpget")]
       public IActionResult Run([HttpTrigger(AuthorizationLevel.Function, "get")]
         HttpRequest req,
         string name)
       {
           var returnValue = string.IsNullOrEmpty(name)
               ? "Hello, World."
               : $"Hello, {name}.";

           _logger.LogInformation($"C# HTTP trigger function processed a request for {returnValue}.");

           return new OkObjectResult(returnValue);
       }
@FunctionName("httpget")
public HttpResponseMessage run(
        @HttpTrigger(
            name = "req",
            methods = {HttpMethod.GET},
            authLevel = AuthorizationLevel.FUNCTION)
            HttpRequestMessage<Optional<String>> request,
        final ExecutionContext context) {
    context.getLogger().info("Java HTTP trigger processed a request.");

    // Parse query parameter
    String name = Optional.ofNullable(request.getQueryParameters().get("name")).orElse("World");

    return request.createResponseBuilder(HttpStatus.OK).body("Hello, " + name).build();
}
@FunctionName("httpget")
public HttpResponseMessage run(
        @HttpTrigger(
            name = "req",
            methods = {HttpMethod.GET},
            authLevel = AuthorizationLevel.FUNCTION)
            HttpRequestMessage<Optional<String>> request,
        final ExecutionContext context) {
    context.getLogger().info("Java HTTP trigger processed a request.");

    // Parse query parameter
    String name = Optional.ofNullable(request.getQueryParameters().get("name")).orElse("World");

    return request.createResponseBuilder(HttpStatus.OK).body("Hello, " + name).build();
}
const { app } = require('@azure/functions');

app.http('httpget', {
    methods: ['GET'],
    authLevel: 'function',
    handler: async (request, context) => {
        context.log(`Http function processed request for url "${request.url}"`);

        const name = request.query.get('name') || await request.text() || 'world';

        return { body: `Hello, ${name}!` };
    }
});
const { app } = require('@azure/functions');

app.http('httpget', {
    methods: ['GET'],
    authLevel: 'function',
    handler: async (request, context) => {
        context.log(`Http function processed request for url "${request.url}"`);

        const name = request.query.get('name') || await request.text() || 'world';

        return { body: `Hello, ${name}!` };
    }
});
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";

export async function httpGetFunction(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> {
    context.log(`Http function processed request for url "${request.url}"`);

    const name = request.query.get('name') || await request.text() || 'world';

    return { body: `Hello, ${name}!` };
};

app.http('httpget', {
    methods: ['GET'],
    authLevel: 'function',
    handler: httpGetFunction
});
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";

export async function httpGetFunction(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> {
    context.log(`Http function processed request for url "${request.url}"`);

    const name = request.query.get('name') || await request.text() || 'world';

    return { body: `Hello, ${name}!` };
};

app.http('httpget', {
    methods: ['GET'],
    authLevel: 'function',
    handler: httpGetFunction
});
Thisfunction.jsonfile defines thehttpgetfunction:
function.json
httpget
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "Request",
      "methods": [
        "get"
      ],
      "route": "httpget"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "Response"
    }
  ]
}
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "Request",
      "methods": [
        "get"
      ],
      "route": "httpget"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "Response"
    }
  ]
}
Thisrun.ps1file implements the function code:
run.ps1
using namespace System.Net

# Input bindings are passed in via param block.
param($Request, $TriggerMetadata)

# Write to the Azure Functions log stream.
Write-Host "PowerShell HTTP trigger function processed a request."

# Interact with query parameters
$name = $Request.Query.name

$body = "This HTTP triggered function executed successfully. Pass a name in the query string for a personalized response."

if ($name) {
    $body = "Hello, $name. This HTTP triggered function executed successfully."
}

# Associate values to output bindings by calling 'Push-OutputBinding'.
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
    StatusCode = [HttpStatusCode]::OK
    Body = $body
})
using namespace System.Net

# Input bindings are passed in via param block.
param($Request, $TriggerMetadata)

# Write to the Azure Functions log stream.
Write-Host "PowerShell HTTP trigger function processed a request."

# Interact with query parameters
$name = $Request.Query.name

$body = "This HTTP triggered function executed successfully. Pass a name in the query string for a personalized response."

if ($name) {
    $body = "Hello, $name. This HTTP triggered function executed successfully."
}

# Associate values to output bindings by calling 'Push-OutputBinding'.
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
    StatusCode = [HttpStatusCode]::OK
    Body = $body
})
@app.route(route="httpget", methods=["GET"])
def http_get(req: func.HttpRequest) -> func.HttpResponse:
    name = req.params.get("name", "World")

    logging.info(f"Processing GET request. Name: {name}")

    return func.HttpResponse(f"Hello, {name}!")
@app.route(route="httpget", methods=["GET"])
def http_get(req: func.HttpRequest) -> func.HttpResponse:
    name = req.params.get("name", "World")

    logging.info(f"Processing GET request. Name: {name}")

    return func.HttpResponse(f"Hello, {name}!")
[Function("httppost")]
public IActionResult Run([HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequest req,
    [FromBody] Person person)
{
    _logger.LogInformation($"C# HTTP POST trigger function processed a request for url {req.Body}");

    if (string.IsNullOrEmpty(person.Name) | string.IsNullOrEmpty(person.Age.ToString()) | person.Age == 0)
    {
        _logger.LogInformation("C# HTTP POST trigger function processed a request with no name/age provided.");
        return new BadRequestObjectResult("Please provide both name and age in the request body.");
    }

    var returnValue = $"Hello, {person.Name}! You are {person.Age} years old.";
    
    _logger.LogInformation($"C# HTTP POST trigger function processed a request for {person.Name} who is {person.Age} years old.");
    return new OkObjectResult(returnValue);
}
[Function("httppost")]
public IActionResult Run([HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequest req,
    [FromBody] Person person)
{
    _logger.LogInformation($"C# HTTP POST trigger function processed a request for url {req.Body}");

    if (string.IsNullOrEmpty(person.Name) | string.IsNullOrEmpty(person.Age.ToString()) | person.Age == 0)
    {
        _logger.LogInformation("C# HTTP POST trigger function processed a request with no name/age provided.");
        return new BadRequestObjectResult("Please provide both name and age in the request body.");
    }

    var returnValue = $"Hello, {person.Name}! You are {person.Age} years old.";
    
    _logger.LogInformation($"C# HTTP POST trigger function processed a request for {person.Name} who is {person.Age} years old.");
    return new OkObjectResult(returnValue);
}
@FunctionName("httppost")
public HttpResponseMessage runPost(
        @HttpTrigger(
            name = "req",
            methods = {HttpMethod.POST},
            authLevel = AuthorizationLevel.FUNCTION)
            HttpRequestMessage<Optional<String>> request,
        final ExecutionContext context) {
    context.getLogger().info("Java HTTP trigger processed a POST request.");

    // Parse request body
    String name;
    Integer age;
    try {
        ObjectMapper mapper = new ObjectMapper();
        JsonNode jsonNode = mapper.readTree(request.getBody().orElse("{}"));
        name = Optional.ofNullable(jsonNode.get("name")).map(JsonNode::asText).orElse(null);
        age = Optional.ofNullable(jsonNode.get("age")).map(JsonNode::asInt).orElse(null);
        if (name == null || age == null) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                    .body("Please provide both name and age in the request body.").build();
        }
    } catch (Exception e) {
        context.getLogger().severe("Error parsing request body: " + e.getMessage());
        return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                .body("Error parsing request body").build();
    }
@FunctionName("httppost")
public HttpResponseMessage runPost(
        @HttpTrigger(
            name = "req",
            methods = {HttpMethod.POST},
            authLevel = AuthorizationLevel.FUNCTION)
            HttpRequestMessage<Optional<String>> request,
        final ExecutionContext context) {
    context.getLogger().info("Java HTTP trigger processed a POST request.");

    // Parse request body
    String name;
    Integer age;
    try {
        ObjectMapper mapper = new ObjectMapper();
        JsonNode jsonNode = mapper.readTree(request.getBody().orElse("{}"));
        name = Optional.ofNullable(jsonNode.get("name")).map(JsonNode::asText).orElse(null);
        age = Optional.ofNullable(jsonNode.get("age")).map(JsonNode::asInt).orElse(null);
        if (name == null || age == null) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                    .body("Please provide both name and age in the request body.").build();
        }
    } catch (Exception e) {
        context.getLogger().severe("Error parsing request body: " + e.getMessage());
        return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
                .body("Error parsing request body").build();
    }
const { app } = require('@azure/functions');

app.http('httppost', {
    methods: ['POST'],
    authLevel: 'function',
    handler: async (request, context) => {
        context.log(`Http function processed request for url "${request.url}"`);

        try {
            const person = await request.json();
            const { name, age } = person;

            if (!name || !age) {
                return {
                    status: 400,
                    body: 'Please provide both name and age in the request body.'
                };
            }

            return {
                status: 200,
                body: `Hello, ${name}! You are ${age} years old.`
            };
        } catch (error) {
            return {
                status: 400,
                body: 'Invalid request body. Please provide a valid JSON object with name and age.'
            };
        }
    }
});
const { app } = require('@azure/functions');

app.http('httppost', {
    methods: ['POST'],
    authLevel: 'function',
    handler: async (request, context) => {
        context.log(`Http function processed request for url "${request.url}"`);

        try {
            const person = await request.json();
            const { name, age } = person;

            if (!name || !age) {
                return {
                    status: 400,
                    body: 'Please provide both name and age in the request body.'
                };
            }

            return {
                status: 200,
                body: `Hello, ${name}! You are ${age} years old.`
            };
        } catch (error) {
            return {
                status: 400,
                body: 'Invalid request body. Please provide a valid JSON object with name and age.'
            };
        }
    }
});
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";

interface Person {
    name: string;
    age: number;
}

function isPerson(obj: any): obj is Person {
    return typeof obj === 'object' && obj !== null && 
           typeof obj.name === 'string' && 
           typeof obj.age === 'number';
}

export async function httpPostBodyFunction(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> {
    context.log(`Http function processed request for url "${request.url}"`);

        try {
            const data: any  = await request.json();
    
            if (!isPerson(data)) {
                return {
                    status: 400,
                    body: 'Please provide both name and age in the request body.'
                };
            }

            return {
                status: 200,
                body: `Hello, ${data.name}! You are ${data.age} years old.`
            };
        } catch (error) {
            return {
                status: 400,
                body: 'Invalid request body. Please provide a valid JSON object with name and age.'
            };
        }
};

app.http('httppost', {
    methods: ['POST'],
    authLevel: 'function',
    handler: httpPostBodyFunction
});
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";

interface Person {
    name: string;
    age: number;
}

function isPerson(obj: any): obj is Person {
    return typeof obj === 'object' && obj !== null && 
           typeof obj.name === 'string' && 
           typeof obj.age === 'number';
}

export async function httpPostBodyFunction(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> {
    context.log(`Http function processed request for url "${request.url}"`);

        try {
            const data: any  = await request.json();
    
            if (!isPerson(data)) {
                return {
                    status: 400,
                    body: 'Please provide both name and age in the request body.'
                };
            }

            return {
                status: 200,
                body: `Hello, ${data.name}! You are ${data.age} years old.`
            };
        } catch (error) {
            return {
                status: 400,
                body: 'Invalid request body. Please provide a valid JSON object with name and age.'
            };
        }
};

app.http('httppost', {
    methods: ['POST'],
    authLevel: 'function',
    handler: httpPostBodyFunction
});
Thisfunction.jsonfile defines thehttppostfunction:
function.json
httppost
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "Request",
      "methods": [
        "post"
      ],
      "route": "httppost"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "Response"
    }
  ]
}
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "Request",
      "methods": [
        "post"
      ],
      "route": "httppost"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "Response"
    }
  ]
}
Thisrun.ps1file implements the function code:
run.ps1
using namespace System.Net

# Input bindings are passed in via param block.
param($Request, $TriggerMetadata)

# Write to the Azure Functions log stream.
Write-Host "PowerShell HTTP trigger function processed a request."

# Interact with the body of the request.
$name = $Request.Body.name
$age = $Request.Body.age
$status = [HttpStatusCode]::OK

$body = "This HTTP triggered function executed successfully. Pass a name in the request body for a personalized response."

if ( -not ($name -and $age)){
    $body = "Please provide both 'name' and 'age' in the request body."
    $status = [HttpStatusCode]::BadRequest
}
else {
    <# Action when all if and elseif conditions are false #>
    $body = "Hello, ${name}! You are ${age} years old."
}

# Associate values to output bindings by calling 'Push-OutputBinding'.
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
    StatusCode = $status
    Body = $body
})
using namespace System.Net

# Input bindings are passed in via param block.
param($Request, $TriggerMetadata)

# Write to the Azure Functions log stream.
Write-Host "PowerShell HTTP trigger function processed a request."

# Interact with the body of the request.
$name = $Request.Body.name
$age = $Request.Body.age
$status = [HttpStatusCode]::OK

$body = "This HTTP triggered function executed successfully. Pass a name in the request body for a personalized response."

if ( -not ($name -and $age)){
    $body = "Please provide both 'name' and 'age' in the request body."
    $status = [HttpStatusCode]::BadRequest
}
else {
    <# Action when all if and elseif conditions are false #>
    $body = "Hello, ${name}! You are ${age} years old."
}

# Associate values to output bindings by calling 'Push-OutputBinding'.
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
    StatusCode = $status
    Body = $body
})
@app.route(route="httppost", methods=["POST"])
def http_post(req: func.HttpRequest) -> func.HttpResponse:
    try:
        req_body = req.get_json()
        name = req_body.get('name')
        age = req_body.get('age')
        
        logging.info(f"Processing POST request. Name: {name}")

        if name and isinstance(name, str) and age and isinstance(age, int):
            return func.HttpResponse(f"Hello, {name}! You are {age} years old!")
        else:
            return func.HttpResponse(
                "Please provide both 'name' and 'age' in the request body.",
                status_code=400
            )
    except ValueError:
        return func.HttpResponse(
            "Invalid JSON in request body",
            status_code=400
        )
@app.route(route="httppost", methods=["POST"])
def http_post(req: func.HttpRequest) -> func.HttpResponse:
    try:
        req_body = req.get_json()
        name = req_body.get('name')
        age = req_body.get('age')
        
        logging.info(f"Processing POST request. Name: {name}")

        if name and isinstance(name, str) and age and isinstance(age, int):
            return func.HttpResponse(f"Hello, {name}! You are {age} years old!")
        else:
            return func.HttpResponse(
                "Please provide both 'name' and 'age' in the request body.",
                status_code=400
            )
    except ValueError:
        return func.HttpResponse(
            "Invalid JSON in request body",
            status_code=400
        )
You can review the complete template projecthere.
You can review the complete template projecthere.
You can review the complete template projecthere.
You can review the complete template projecthere.
You can review the complete template projecthere.
You can review the complete template projecthere.
After you verify your functions locally, it's time to publish them to Azure.
Create Azure resources
This project is configured to use theazd provisioncommand to create a function app in a Flex Consumption plan, along with other required Azure resources.
azd provision
Note
This project includes a set of Bicep files thatazduses to create a secure deployment to a Flex consumption plan that follows best practices.
azd
Theazd upandazd deploycommands aren't currently supported for Java apps.
azd up
azd deploy
In the root folder of the project, run this command to create the required Azure resources:azd provisionThe root folder contains theazure.yamldefinition file required byazd.If you aren't already signed-in, you're asked to authenticate with your Azure account.
In the root folder of the project, run this command to create the required Azure resources:
azd provision
azd provision
The root folder contains theazure.yamldefinition file required byazd.
azure.yaml
azd
If you aren't already signed-in, you're asked to authenticate with your Azure account.
When prompted, provide these required deployment parameters:ParameterDescriptionAzure subscriptionSubscription in which your resources are created.Azure locationAzure region in which to create the resource group that contains the new Azure resources. Only regions that currently support the Flex Consumption plan are shown.Theazd provisioncommand uses your response to these prompts with the Bicep configuration files to create and configure these required Azure resources:Flex Consumption plan and function appAzure Storage (required) and Application Insights (recommended)Access policies and roles for your accountService-to-service connections using managed identities (instead of stored connection strings)Virtual network to securely run both the function app and the other Azure resourcesAfter the command completes successfully, you can deploy your project code to this new function app in Azure.
When prompted, provide these required deployment parameters:
Theazd provisioncommand uses your response to these prompts with the Bicep configuration files to create and configure these required Azure resources:
azd provision
Flex Consumption plan and function app
Azure Storage (required) and Application Insights (recommended)
Access policies and roles for your account
Service-to-service connections using managed identities (instead of stored connection strings)
Virtual network to securely run both the function app and the other Azure resources
After the command completes successfully, you can deploy your project code to this new function app in Azure.
Deploy to Azure
You can use Core Tools to package your code and deploy it to Azure from thetargetoutput folder.
target
Navigate to the app folder equivalent in thetargetoutput folder:cd http/target/azure-functions/contoso-functionsThis folder should have a host.json file, which indicates that it's the root of your compiled Java function app.
Navigate to the app folder equivalent in thetargetoutput folder:
target
cd http/target/azure-functions/contoso-functions
cd http/target/azure-functions/contoso-functions
This folder should have a host.json file, which indicates that it's the root of your compiled Java function app.
Run these commands to deploy your compiled Java code project to the new function app resource in Azure using Core Tools:bashCmdAPP_NAME=$(azd env get-value AZURE_FUNCTION_NAME)
func azure functionapp publish $APP_NAMEfor /f "tokens=*" %i in ('azd env get-value AZURE_FUNCTION_NAME') do set APP_NAME=%i
func azure functionapp publish %APP_NAME%Theazd env get-valuecommand gets your function app name from the local environment, which is required for deployment usingfunc azure functionapp publish. After publishing completes successfully, you see links to the HTTP trigger endpoints in Azure.
Run these commands to deploy your compiled Java code project to the new function app resource in Azure using Core Tools:
bash
Cmd
APP_NAME=$(azd env get-value AZURE_FUNCTION_NAME)
func azure functionapp publish $APP_NAME
APP_NAME=$(azd env get-value AZURE_FUNCTION_NAME)
func azure functionapp publish $APP_NAME
for /f "tokens=*" %i in ('azd env get-value AZURE_FUNCTION_NAME') do set APP_NAME=%i
func azure functionapp publish %APP_NAME%
for /f "tokens=*" %i in ('azd env get-value AZURE_FUNCTION_NAME') do set APP_NAME=%i
func azure functionapp publish %APP_NAME%
Theazd env get-valuecommand gets your function app name from the local environment, which is required for deployment usingfunc azure functionapp publish. After publishing completes successfully, you see links to the HTTP trigger endpoints in Azure.
azd env get-value
func azure functionapp publish
Deploy to Azure
This project is configured to use theazd upcommand to deploy this project to a new function app in a Flex Consumption plan in Azure.
azd up
Tip
This project includes a set of Bicep files thatazduses to create a secure deployment to a Flex consumption plan that follows best practices.
azd
Run this command to haveazdcreate the required Azure resources in Azure and deploy your code project to the new function app:azd upThe root folder contains theazure.yamldefinition file required byazd.If you aren't already signed-in, you're asked to authenticate with your Azure account.
Run this command to haveazdcreate the required Azure resources in Azure and deploy your code project to the new function app:
azd
azd up
azd up
The root folder contains theazure.yamldefinition file required byazd.
azure.yaml
azd
If you aren't already signed-in, you're asked to authenticate with your Azure account.
When prompted, provide these required deployment parameters:ParameterDescriptionAzure subscriptionSubscription in which your resources are created.Azure locationAzure region in which to create the resource group that contains the new Azure resources. Only regions that currently support the Flex Consumption plan are shown.Theazd upcommand uses your response to these prompts with the Bicep configuration files to complete these deployment tasks:Create and configure these required Azure resources (equivalent toazd provision):Flex Consumption plan and function appAzure Storage (required) and Application Insights (recommended)Access policies and roles for your accountService-to-service connections using managed identities (instead of stored connection strings)Virtual network to securely run both the function app and the other Azure resourcesPackage and deploy your code to the deployment container (equivalent toazd deploy). The app is then started and runs in the deployed package.After the command completes successfully, you see links to the resources you created.
When prompted, provide these required deployment parameters:
Theazd upcommand uses your response to these prompts with the Bicep configuration files to complete these deployment tasks:
azd up
Create and configure these required Azure resources (equivalent toazd provision):Flex Consumption plan and function appAzure Storage (required) and Application Insights (recommended)Access policies and roles for your accountService-to-service connections using managed identities (instead of stored connection strings)Virtual network to securely run both the function app and the other Azure resources
Create and configure these required Azure resources (equivalent toazd provision):
azd provision
Flex Consumption plan and function app
Azure Storage (required) and Application Insights (recommended)
Access policies and roles for your account
Service-to-service connections using managed identities (instead of stored connection strings)
Virtual network to securely run both the function app and the other Azure resources
Package and deploy your code to the deployment container (equivalent toazd deploy). The app is then started and runs in the deployed package.
Package and deploy your code to the deployment container (equivalent toazd deploy). The app is then started and runs in the deployed package.
azd deploy
After the command completes successfully, you see links to the resources you created.
Invoke the function on Azure
You can now invoke your function endpoints in Azure by making HTTP requests to their URLs using your HTTP test tool or from the browser (for GET requests). When your functions run in Azure, access key authorization is enforced, and you must provide a function access key with your request.
You can use the Core Tools to obtain the URL endpoints of your functions running in Azure.
In your local terminal or command prompt, run these commands to get the URL endpoint values:bashCmdSET APP_NAME=(azd env get-value AZURE_FUNCTION_NAME)
func azure functionapp list-functions $APP_NAME --show-keysfor /f "tokens=*" %i in ('azd env get-value AZURE_FUNCTION_NAME') do set APP_NAME=%i
func azure functionapp list-functions %APP_NAME% --show-keysPowerShellCmd$APP_NAME = azd env get-value AZURE_FUNCTION_NAME
func azure functionapp list-functions $APP_NAME --show-keysfor /f "tokens=*" %i in ('azd env get-value AZURE_FUNCTION_NAME') do set APP_NAME=%i
func azure functionapp list-functions %APP_NAME% --show-keysTheazd env get-valuecommand gets your function app name from the local environment. Using the--show-keysoption withfunc azure functionapp list-functionsmeans that the returnedInvoke URL:value for each endpoint includes a function-level access key.
In your local terminal or command prompt, run these commands to get the URL endpoint values:
bash
Cmd
SET APP_NAME=(azd env get-value AZURE_FUNCTION_NAME)
func azure functionapp list-functions $APP_NAME --show-keys
SET APP_NAME=(azd env get-value AZURE_FUNCTION_NAME)
func azure functionapp list-functions $APP_NAME --show-keys
for /f "tokens=*" %i in ('azd env get-value AZURE_FUNCTION_NAME') do set APP_NAME=%i
func azure functionapp list-functions %APP_NAME% --show-keys
for /f "tokens=*" %i in ('azd env get-value AZURE_FUNCTION_NAME') do set APP_NAME=%i
func azure functionapp list-functions %APP_NAME% --show-keys
PowerShell
Cmd
$APP_NAME = azd env get-value AZURE_FUNCTION_NAME
func azure functionapp list-functions $APP_NAME --show-keys
$APP_NAME = azd env get-value AZURE_FUNCTION_NAME
func azure functionapp list-functions $APP_NAME --show-keys
for /f "tokens=*" %i in ('azd env get-value AZURE_FUNCTION_NAME') do set APP_NAME=%i
func azure functionapp list-functions %APP_NAME% --show-keys
for /f "tokens=*" %i in ('azd env get-value AZURE_FUNCTION_NAME') do set APP_NAME=%i
func azure functionapp list-functions %APP_NAME% --show-keys
Theazd env get-valuecommand gets your function app name from the local environment. Using the--show-keysoption withfunc azure functionapp list-functionsmeans that the returnedInvoke URL:value for each endpoint includes a function-level access key.
azd env get-value
--show-keys
func azure functionapp list-functions
As before, use your HTTP test tool to validate these URLs in your function app running in Azure.
As before, use your HTTP test tool to validate these URLs in your function app running in Azure.
Redeploy your code
You can run theazd upcommand as many times as you need to both provision your Azure resources and deploy code updates to your function app.
azd up
Note
Deployed code files are always overwritten by the latest deployment package.
Your initial responses toazdprompts and any environment variables generated byazdare stored locally in your named environment. Use theazd env get-valuescommand to review all of the variables in your environment that were used when creating Azure resources.
azd
azd
azd env get-values
Clean up resources
When you're done working with your function app and related resources, you can use this command to delete the function app and its related resources from Azure and avoid incurring any further costs:
azd down --no-prompt
azd down --no-prompt
Note
The--no-promptoption instructsazdto delete your resource group without a confirmation from you.
--no-prompt
azd
This command doesn't affect your local code project.
Related content
Flex Consumption plan
Azure Developer CLI (azd)
azd reference
Azure Functions Core Tools reference
Code and test Azure Functions locally
Feedback
Was this page helpful?
Additional resources