Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Create Standard logic app workflows with Visual Studio Code
Article
2025-03-20
1 contributor
In this article
Applies to:Azure Logic Apps (Standard)
This guide shows how to locally create an example Standard logic app workflow that you can run in single-tenant Azure Logic Apps when you use Visual Studio Code with theAzure Logic Apps (Standard)extension.
In this guide, you create a Standard logic app workspace and project, build your workflow, and deploy your project as a Standard logic app resource in Azure where your workflow can run in single-tenant Azure Logic Apps or in App Service Environment v3 (Windows-based App Service plans only). You can also deploy and run your workflow anywhere that Kubernetes can run, such as Azure, Azure Kubernetes Service, on premises, or even other cloud providers, due to the containerized runtime for Azure Logic Apps (Standard).
Here are just some benefits that Standard logic apps provide:
You can locally create, debug, run, and test workflows in the local Visual Studio Code development environment. Both the Azure portal and Visual Studio Code provide the capability to build, run, and deploy Standard logic app resources and workflows. However, with Visual Studio Code, you can perform these tasks locally.
You can locally create, debug, run, and test workflows in the local Visual Studio Code development environment. Both the Azure portal and Visual Studio Code provide the capability to build, run, and deploy Standard logic app resources and workflows. However, with Visual Studio Code, you can perform these tasks locally.
Your Standard logic app project can include bothstateful and stateless workflows.
Your Standard logic app project can include bothstateful and stateless workflows.
Workflows in the same Standard logic app resource and tenant run in the same process as the Azure Logic Apps (Standard) runtime, so they share the same resources and provide better performance.
Workflows in the same Standard logic app resource and tenant run in the same process as the Azure Logic Apps (Standard) runtime, so they share the same resources and provide better performance.
This guide's example workflow initially starts with aRequesttrigger followed by anOffice 365 Outlookaction. TheRequesttrigger creates a callable endpoint for the workflow and waits for an inbound HTTPS request from any caller. When the trigger receives a request and fires, the next action runs by sending email to the specified recipient along with any trigger outputs that you select. Later, you can add aResponseaction that returns a reply and processed data to the caller.

While this guide's example is cloud-based and only has a few steps, you can create workflows using operations from1,400+ connectorsthat help you integrate a vast range of services, systems, apps, and data across cloud, on premises, and hybrid environments.
As you progress through the guide, you complete the following high-level tasks:
Create a Standard logic app workspace and project with a blank stateful workflow.
Add a trigger and actions to your workflow.
Run, debug, and test locally.
Review workflow run history.
Find domain name details for firewall access.
Enable run history for stateless workflows.
Deploy to Azure, which includes optionally enabling Application Insights.
Enable or open the Application Insights after deployment.
Manage your deployed logic app resource in Visual Studio Code and the Azure portal.
Prerequisites
Access and connectivity requirements
If you plan to locally create and run workflows using onlybuilt-in operations, which run natively on the Azure Logic Apps (Standard) runtime, you don't need the access and connectivity requirements in this section. However, for the following scenarios, you need to meet these requirements:
Deploy your logic app to Azure from Visual Studio Code.
Build a workflow that usesmanaged connector operationsthat run in global Azure.
Access existing Standard logic app resources and workflows in Azure or other deployed Azure resources.
These requirements include the following items:
An Azure account and subscription. If you don't have a subscription,sign up for a free Azure account.
An Azure account and subscription. If you don't have a subscription,sign up for a free Azure account.
Access to the internet so that you can download the required extension, connect from Visual Studio Code to your Azure account, test workflows that include managed connector operations, and deploy to Azure from Visual Studio Code.
Access to the internet so that you can download the required extension, connect from Visual Studio Code to your Azure account, test workflows that include managed connector operations, and deploy to Azure from Visual Studio Code.
To create the same example workflow in this guide, you need an Office 365 Outlook email account that uses a Microsoft work or school account to sign in.If you don't have an Office 365 account, you can use any other available action that can send messages from your email account, for example, Outlook.com. If you choose adifferent email connector, such as Outlook.com, you can still follow the example, and the general overall steps are the same. However, your experience and options might differ in some ways. For example, with the Outlook.com connector, use your personal Microsoft account to sign in.
To create the same example workflow in this guide, you need an Office 365 Outlook email account that uses a Microsoft work or school account to sign in.
If you don't have an Office 365 account, you can use any other available action that can send messages from your email account, for example, Outlook.com. If you choose adifferent email connector, such as Outlook.com, you can still follow the example, and the general overall steps are the same. However, your experience and options might differ in some ways. For example, with the Outlook.com connector, use your personal Microsoft account to sign in.
Tools
Download and installVisual Studio Code, which is free.
Download and installVisual Studio Code, which is free.
Download and install theAzure Logic Apps (Standard) extension for Visual Studio Codeby following these steps:In Visual Studio Code, on the Activity bar, selectExtensions. (Keyboard: Press Ctrl+Shift+X)In the extensions search box, enterazure logic apps standard. From the results list, selectAzure Logic Apps (Standard)>Install.The extension downloads and installs all required dependencies and the correct versions for the following frameworks:Azure Functions Core Tools.NET SDKNode.jsAfter the installation completes, the extension appears in theExtensions: Installedlist.Reload or restart Visual Studio Code to make sure the extension and all dependencies correctly install.To confirm that the extension and all dependencies correctly installed, seeCheck extension installation.Currently, you can have both Consumption (multitenant) and Standard (single-tenant) extensions installed at the same time. The development experiences differ from each other in some ways, but your Azure subscription can include both Standard and Consumption logic app resource types. In Visual Studio Code, the Azure pane shows all the Azure-deployed and hosted logic apps in your Azure subscription, but organizes your apps in the following ways:Resourcessection: All the Standard logic apps in your subscription.Logic Apps (Consumption)section: All the Consumption logic apps in your subscription.
Download and install theAzure Logic Apps (Standard) extension for Visual Studio Codeby following these steps:
In Visual Studio Code, on the Activity bar, selectExtensions. (Keyboard: Press Ctrl+Shift+X)
In Visual Studio Code, on the Activity bar, selectExtensions. (Keyboard: Press Ctrl+Shift+X)
In the extensions search box, enterazure logic apps standard. From the results list, selectAzure Logic Apps (Standard)>Install.The extension downloads and installs all required dependencies and the correct versions for the following frameworks:Azure Functions Core Tools.NET SDKNode.jsAfter the installation completes, the extension appears in theExtensions: Installedlist.
In the extensions search box, enterazure logic apps standard. From the results list, selectAzure Logic Apps (Standard)>Install.
The extension downloads and installs all required dependencies and the correct versions for the following frameworks:
Azure Functions Core Tools
.NET SDK
Node.js
After the installation completes, the extension appears in theExtensions: Installedlist.

Reload or restart Visual Studio Code to make sure the extension and all dependencies correctly install.
Reload or restart Visual Studio Code to make sure the extension and all dependencies correctly install.
To confirm that the extension and all dependencies correctly installed, seeCheck extension installation.
To confirm that the extension and all dependencies correctly installed, seeCheck extension installation.
Currently, you can have both Consumption (multitenant) and Standard (single-tenant) extensions installed at the same time. The development experiences differ from each other in some ways, but your Azure subscription can include both Standard and Consumption logic app resource types. In Visual Studio Code, the Azure pane shows all the Azure-deployed and hosted logic apps in your Azure subscription, but organizes your apps in the following ways:
Resourcessection: All the Standard logic apps in your subscription.
Logic Apps (Consumption)section: All the Consumption logic apps in your subscription.
To locally run webhook-based triggers and actions, such as thebuilt-inHTTP Webhooktrigger, you need toset up forwarding for the callback URLin Visual Studio Code.
To locally run webhook-based triggers and actions, such as thebuilt-inHTTP Webhooktrigger, you need toset up forwarding for the callback URLin Visual Studio Code.
To enable diagnostics logging and tracing withApplication Insightsfor your Standard logic app, you can complete this task either during logic app deployment or after deployment. You need to have an Application Insights resource, but you cancreate this resource in advance, during deployment, or after deployment.
To enable diagnostics logging and tracing withApplication Insightsfor your Standard logic app, you can complete this task either during logic app deployment or after deployment. You need to have an Application Insights resource, but you cancreate this resource in advance, during deployment, or after deployment.
Install or use a tool that can send HTTP requests to test the sample workflow, for example:Visual Studio Codewith anextension from Visual Studio MarketplacePowerShell Invoke-RestMethodMicrosoft Edge - Network Console toolBrunocurlCautionFor scenarios where you have sensitive data, such as credentials, secrets, access tokens, API keys, and other
similar information, make sure to use a tool that protects your data with the necessary security features.
The tool should work offline or locally, and not require sign in to an online account or sync data to the cloud.
When you use a tool with these characteristics, you reduce the risk of exposing sensitive data to the public.
Install or use a tool that can send HTTP requests to test the sample workflow, for example:
Visual Studio Codewith anextension from Visual Studio Marketplace
PowerShell Invoke-RestMethod
Microsoft Edge - Network Console tool
Bruno
curl
Caution
For scenarios where you have sensitive data, such as credentials, secrets, access tokens, API keys, and other
similar information, make sure to use a tool that protects your data with the necessary security features.
The tool should work offline or locally, and not require sign in to an online account or sync data to the cloud.
When you use a tool with these characteristics, you reduce the risk of exposing sensitive data to the public.

To make sure that the extension and all dependencies are correctly installed, reload or restart Visual Studio Code.
To make sure that the extension and all dependencies are correctly installed, reload or restart Visual Studio Code.
Confirm that Visual Studio Code automatically finds and installs extension updates so that all your extensions get the latest updates. Otherwise, you have to manually uninstall the outdated version and install the latest version.On theFilemenu, go toPreferences>Settings.On theUsertab, go toFeatures>Extensions.Make sureAuto Check Updatesis selected, and thatAuto Updateis set toAll Extensions.
Confirm that Visual Studio Code automatically finds and installs extension updates so that all your extensions get the latest updates. Otherwise, you have to manually uninstall the outdated version and install the latest version.
On theFilemenu, go toPreferences>Settings.
On theFilemenu, go toPreferences>Settings.
On theUsertab, go toFeatures>Extensions.
On theUsertab, go toFeatures>Extensions.
Make sureAuto Check Updatesis selected, and thatAuto Updateis set toAll Extensions.
Make sureAuto Check Updatesis selected, and thatAuto Updateis set toAll Extensions.
Confirm that theAzure Logic Apps Standard: Project Runtimesetting is set to the correct version:On theUsertab, go to>Extensions>Azure Logic Apps (Standard).Make sureProject Runtimeis set to version~4, for example:NoteThis version is required to use theInline Code Operations actions.
Confirm that theAzure Logic Apps Standard: Project Runtimesetting is set to the correct version:
On theUsertab, go to>Extensions>Azure Logic Apps (Standard).
On theUsertab, go to>Extensions>Azure Logic Apps (Standard).
Make sureProject Runtimeis set to version~4, for example:NoteThis version is required to use theInline Code Operations actions.
Make sureProject Runtimeis set to version~4, for example:

Note
This version is required to use theInline Code Operations actions.

Connect to your Azure account
If you aren't already connected to your Azure account, follow these steps to connect:
In Visual Studio Code, on the Activity Bar, select the Azure icon to open theAzurepane.
In Visual Studio Code, on the Activity Bar, select the Azure icon to open theAzurepane.

In the Azure pane, underResources, selectSign in to Azure. When the Visual Studio Code authentication page appears, sign in with your Azure account.After you sign in, the Azure pane shows the Azure subscriptions associated with your Azure account. If the expected subscriptions don't appear, or you want the pane to show only specific subscriptions, follow these steps:In the subscriptions list, move your pointer next to the first subscription until theSelect Subscriptionsbutton (filter icon) appears. Select the filter icon.Or, in the Visual Studio Code status bar, select your Azure account.When the updated subscriptions list appears, select the subscriptions that you want, and make sure that you selectOK.
In the Azure pane, underResources, selectSign in to Azure. When the Visual Studio Code authentication page appears, sign in with your Azure account.

After you sign in, the Azure pane shows the Azure subscriptions associated with your Azure account. If the expected subscriptions don't appear, or you want the pane to show only specific subscriptions, follow these steps:
In the subscriptions list, move your pointer next to the first subscription until theSelect Subscriptionsbutton (filter icon) appears. Select the filter icon.Or, in the Visual Studio Code status bar, select your Azure account.
In the subscriptions list, move your pointer next to the first subscription until theSelect Subscriptionsbutton (filter icon) appears. Select the filter icon.

Or, in the Visual Studio Code status bar, select your Azure account.
When the updated subscriptions list appears, select the subscriptions that you want, and make sure that you selectOK.
When the updated subscriptions list appears, select the subscriptions that you want, and make sure that you selectOK.

Create a local workspace
A logic app project always requires a workspace. So, before you can create your logic app, you have to create aworkspacewhere you keep your logic app project. You later use this workspace and project to manage, run, and deploy your logic app from Visual Studio Code to your deployment environment. The underlying project is similar to an Azure Functions project, also known as a function app project.
On your computer, create anemptylocal folder to use later for the workspace and project.This example creates a folder namedfabrikam-workflows.
On your computer, create anemptylocal folder to use later for the workspace and project.
This example creates a folder namedfabrikam-workflows.
In Visual Studio Code, close all open folders.
In Visual Studio Code, close all open folders.
In theAzurewindow, on theWorkspacesection toolbar, from theAzure Logic Appsmenu, selectCreate new logic app workspace.If Windows Defender Firewall prompts you to grant network access forCode.exe, which is Visual Studio Code, and forfunc.exe, which is the Azure Functions Core Tools, selectPrivate networks, such as my home or work network>Allow access.
In theAzurewindow, on theWorkspacesection toolbar, from theAzure Logic Appsmenu, selectCreate new logic app workspace.

If Windows Defender Firewall prompts you to grant network access forCode.exe, which is Visual Studio Code, and forfunc.exe, which is the Azure Functions Core Tools, selectPrivate networks, such as my home or work network>Allow access.
In theSelect Folderwindow, go to the location where you created your folder, select the folder, and chooseSelect(don't double-select the folder).On the Visual Studio Code toolbar, a prompt appears for you to name your workspace.
In theSelect Folderwindow, go to the location where you created your folder, select the folder, and chooseSelect(don't double-select the folder).

On the Visual Studio Code toolbar, a prompt appears for you to name your workspace.
ForProvide a workspace name, enter the workspace name to use.This example usesFabrikam-Workflows.
ForProvide a workspace name, enter the workspace name to use.
This example usesFabrikam-Workflows.

Next, create your logic app project.

Create your logic app project
After you create the required workspace, follow the prompts to create your project.
For your project template, selectLogic app. Enter a project name to use.This example usesFabrikam-Workflows.
For your project template, selectLogic app. Enter a project name to use.
This example usesFabrikam-Workflows.

For your workflow template, select eitherStateful WorkfloworStateless Workflow, based on your scenario. Enter a workflow name to use.This example selectsStateful Workflow, which stores workflow history, inputs, and outputs, and usesStateful-Workflowas the name.Stateless workflows don't store this data and currently support onlymanaged connectoractions, not triggers. Although you have the option to enable connectors in Azure for your stateless workflow, the designer doesn't show any managed connector triggers for you to select.NoteIf you get an error namedazureLogicAppsStandard.createNewProjectwith the error message,Unable to write to Workspace Settings because azureFunctions.suppressProject is not a registered configuration,
try reinstalling theAzure Functions extension for Visual Studio Code,
either directly from the Visual Studio Marketplace or from inside Visual Studio Code.
For your workflow template, select eitherStateful WorkfloworStateless Workflow, based on your scenario. Enter a workflow name to use.
This example selectsStateful Workflow, which stores workflow history, inputs, and outputs, and usesStateful-Workflowas the name.
Stateless workflows don't store this data and currently support onlymanaged connectoractions, not triggers. Although you have the option to enable connectors in Azure for your stateless workflow, the designer doesn't show any managed connector triggers for you to select.
Note
If you get an error namedazureLogicAppsStandard.createNewProjectwith the error message,Unable to write to Workspace Settings because azureFunctions.suppressProject is not a registered configuration,
try reinstalling theAzure Functions extension for Visual Studio Code,
either directly from the Visual Studio Marketplace or from inside Visual Studio Code.
Now, choose whether you want to open your project in the current Visual Studio Code window or a new window. SelectOpen in current windoworOpen in new window, based on your preference.The Explorer pane opens to show your workspace, project, and the automatically openedworkflow.jsonfile. This file exists in the folder namedStateful-Workflowand stores the underlying JSON definition for the workflow that you build in the designer. For information about your project structure, seeStandard logic app project structure.You also get a prompt to enable multitenant Azure-hosted "shared" connectors, for example:
Now, choose whether you want to open your project in the current Visual Studio Code window or a new window. SelectOpen in current windoworOpen in new window, based on your preference.
The Explorer pane opens to show your workspace, project, and the automatically openedworkflow.jsonfile. This file exists in the folder namedStateful-Workflowand stores the underlying JSON definition for the workflow that you build in the designer. For information about your project structure, seeStandard logic app project structure.
You also get a prompt to enable multitenant Azure-hosted "shared" connectors, for example:

To enable all the managed "shared" connectors that run in multitenant Azure so you can view and choose to use them in your workflow, selectUse connectors from Azure.NoteIf you don't select this option, and you later try to add a managed connector
operation when you build your workflow, you can't continue because the operation
information pane shows a spinning circle that doesn't stop.
To enable all the managed "shared" connectors that run in multitenant Azure so you can view and choose to use them in your workflow, selectUse connectors from Azure.
Note
If you don't select this option, and you later try to add a managed connector
operation when you build your workflow, you can't continue because the operation
information pane shows a spinning circle that doesn't stop.
For the Azure resource group, selectCreate new resource group. Enter the resource group name to use.This example usesFabrikam-Workflows-RG.
For the Azure resource group, selectCreate new resource group. Enter the resource group name to use.
This example usesFabrikam-Workflows-RG.
For the subscription, select the Azure subscription to use with your logic app project.
For the subscription, select the Azure subscription to use with your logic app project.
For the location where to create your group and resources, select the Azure region.This example usesWest Central US.
For the location where to create your group and resources, select the Azure region.
This example usesWest Central US.
If your project needs other setup for development or needs supporting artifacts to build your workflow, see the following scenarios and related tasks:ScenarioTaskLocally run webhook-based triggers or actions.Set up forwarding for webhook callback URLs.Set up stateless workflow run history.Enable run history for stateless workflows.Add artifacts and dependencies, such as maps, schemas, and assemblies.Add artifacts and dependencies.Work with a NuGet-based (.NET) projectConvert an extension-based bundle (Node.js) project to a NuGet package-based (.NET) project.Note: To convert an extension bundle-based (Node.js) project that you created before assemblies support existed, see alsoMigrate NuGet package-based projects to use assemblies in thelibfolder.Create your own built-in connectors.1.Convert an extension bundle-based (Node.js) project to a NuGet package-based (.NET) project.2.Enable-built-in-connector-authoring.
If your project needs other setup for development or needs supporting artifacts to build your workflow, see the following scenarios and related tasks:
Now, open the workflow designer.

Open the workflow designer
After your project opens in the Explorer pane, open the designer so you can build your workflow.
From theworkflow.jsonfile shortcut menu, selectOpen Designer.

Note
After you select this option, you might get the message that startup might take a few seconds
due to "starting the workflow design-time API". You can ignore this message or selectOK.
Visual Studio Code opens the workflow designer and shows theAdd a triggerprompt, for example:

Note
If the designer won't open, see the troubleshooting section,Designer fails to open.
Next, add a trigger and actions to create your workflow.

Add a trigger and an action
To create your workflow, start your workflow with a trigger, and then initially add a single action. That way, you can test your workflow before you add the next action. The example workflow uses the following trigger and actions, collectively known asoperations:
Add the Request trigger
On the workflow designer, selectAdd a trigger, if not already selected.TheAdd a triggerpane opens and shows a gallery where you can select from available connectors and operation groups, for example:
On the workflow designer, selectAdd a trigger, if not already selected.
TheAdd a triggerpane opens and shows a gallery where you can select from available connectors and operation groups, for example:

In theAdd a triggerpane,follow these general steps to add theRequesttrigger namedWhen an HTTP request is received.The following example selects theGroup by Connectoroption and hasRuntimeset toIn-appso only the built-in triggers appear:When the trigger appears on the designer, the trigger information pane opens and shows the trigger's parameters, settings, and other related tasks.NoteIf the trigger information pane doesn't appear, makes sure that the trigger is selected on the designer.
In theAdd a triggerpane,follow these general steps to add theRequesttrigger namedWhen an HTTP request is received.
The following example selects theGroup by Connectoroption and hasRuntimeset toIn-appso only the built-in triggers appear:

When the trigger appears on the designer, the trigger information pane opens and shows the trigger's parameters, settings, and other related tasks.

Note
If the trigger information pane doesn't appear, makes sure that the trigger is selected on the designer.
Save your workflow. On the designer toolbar, selectSave.
Save your workflow. On the designer toolbar, selectSave.
Add the Office 365 Outlook action
On the designer, under theRequesttrigger,follow these general steps to add theOffice 365 Outlookaction namedSend an email (V2).If the action doesn't appear in the initial results, next to the connector name, selectSee more, for example:
On the designer, under theRequesttrigger,follow these general steps to add theOffice 365 Outlookaction namedSend an email (V2).
If the action doesn't appear in the initial results, next to the connector name, selectSee more, for example:

When the action's authentication pane appears, selectSign into create a connection to your email account.
When the action's authentication pane appears, selectSign into create a connection to your email account.

Follow the subsequent prompts to authenticate your credentials, allow access, and allow returning to Visual Studio Code.NoteIf too much time passes before you complete the prompts, the authentication process times out
and fails. In this case, return to the designer and retry signing in to create the connection.When the Microsoft authentication prompt appears, select your user account for Office 365 Outlook. On the confirmation required page that opens, selectAllow access.When Azure Logic Apps prompts to open a Visual Studio Code link, selectOpen.When Visual Studio Code prompts you to have the extension open the Microsoft Azure Tools, selectOpen.After Visual Studio Code creates your connection, some connectors show the message thatThe connection will be valid for <n> days only. This time limit applies only to the duration while you author your logic app workflow in Visual Studio Code. After deployment, this limit no longer applies because your workflow can authenticate at runtime by using its automatically enabledsystem-assigned managed identity. This managed identity differs from the authentication credentials or connection string that you use when you create a connection. If you disable this system-assigned managed identity, connections won't work at runtime.
Follow the subsequent prompts to authenticate your credentials, allow access, and allow returning to Visual Studio Code.
Note
If too much time passes before you complete the prompts, the authentication process times out
and fails. In this case, return to the designer and retry signing in to create the connection.
When the Microsoft authentication prompt appears, select your user account for Office 365 Outlook. On the confirmation required page that opens, selectAllow access.
When the Microsoft authentication prompt appears, select your user account for Office 365 Outlook. On the confirmation required page that opens, selectAllow access.
When Azure Logic Apps prompts to open a Visual Studio Code link, selectOpen.
When Azure Logic Apps prompts to open a Visual Studio Code link, selectOpen.

When Visual Studio Code prompts you to have the extension open the Microsoft Azure Tools, selectOpen.
When Visual Studio Code prompts you to have the extension open the Microsoft Azure Tools, selectOpen.

After Visual Studio Code creates your connection, some connectors show the message thatThe connection will be valid for <n> days only. This time limit applies only to the duration while you author your logic app workflow in Visual Studio Code. After deployment, this limit no longer applies because your workflow can authenticate at runtime by using its automatically enabledsystem-assigned managed identity. This managed identity differs from the authentication credentials or connection string that you use when you create a connection. If you disable this system-assigned managed identity, connections won't work at runtime.
In theSend an emailinformation pane that opens, on theParameterstab, provide the required information for the action.NoteIf the action information pane didn't automatically open,
select theSend an emailaction on the designer.PropertyRequiredValueDescriptionToYes<your-email-address>The email recipient, which can be your email address for test purposes. This example uses the fictitious email,sophia.owen@fabrikam.com.SubjectYesAn email from your example workflowThe email subjectBodyYesHello from your example workflow!The email body contentFor example:
In theSend an emailinformation pane that opens, on theParameterstab, provide the required information for the action.
Note
If the action information pane didn't automatically open,
select theSend an emailaction on the designer.
For example:

Save your workflow. On the designer, selectSave.
Save your workflow. On the designer, selectSave.

Standard logic app project structure
In Visual Studio Code, your logic app project has either of the following types:
Extension bundle-based (Node.js), which is the default type
NuGet package-based (.NET), which you can convert from the default type
Based on these types, your project might include slightly different folders or files. For example, a Nuget package-based project has a.binfolder that contains packages and other library files. An extension bundle-based project doesn't include this.binfolder.
Some scenarios require a NuGet package-based project for your app to run, for example, when you want to develop and run custom built-in operations. For more information about converting your project to use NuGet, reviewEnable built-connector authoring.
The default extension bundle-based project has a folder and file structure that is similar to the following example:
MyWorkspaceName
| MyBundleBasedLogicAppProjectName
  || .vscode
  || Artifacts
     ||| Maps 
         |||| MapName1
         |||| ...
     ||| Rules
     ||| Schemas
         |||| SchemaName1
         |||| ...
  || lib
     ||| builtinOperationSdks
         |||| JAR
         |||| net472
     ||| custom
  || WorkflowName1
     ||| workflow.json
     ||| ...
  || WorkflowName2
     ||| workflow.json
     ||| ...
  || workflow-designtime
     ||| host.json
     ||| local.settings.json
  || .funcignore
  || connections.json
  || host.json
  || local.settings.json
MyWorkspaceName
| MyBundleBasedLogicAppProjectName
  || .vscode
  || Artifacts
     ||| Maps 
         |||| MapName1
         |||| ...
     ||| Rules
     ||| Schemas
         |||| SchemaName1
         |||| ...
  || lib
     ||| builtinOperationSdks
         |||| JAR
         |||| net472
     ||| custom
  || WorkflowName1
     ||| workflow.json
     ||| ...
  || WorkflowName2
     ||| workflow.json
     ||| ...
  || workflow-designtime
     ||| host.json
     ||| local.settings.json
  || .funcignore
  || connections.json
  || host.json
  || local.settings.json
At your project's root level, you can find the following folders and files along with other items:
Microsoft.Azure.WebJobs.Script.WebHost: Repository has more than 10 non-decryptable secrets backups (host))
appSettings

Other development setup tasks
After you create your project, you might still have other setup tasks to support specific local development scenarios around building, running, and deploying Standard logic apps using Visual Studio Code. The following sections describe the tasks for these scenarios.

Enable locally running webhooks
Awebhookoperation is a workflow trigger or action that waits for an event to happen before the operation can execute. Specifically, the webhook operation waits for an HTTPS request to arrive from a caller service or workflow before the operation can continue. For example, webhooks include operations such as theRequesttrigger and theHTTP + Webhooktrigger.
In the Azure portal, the Azure Logic Apps runtime automatically subscribes the webhook to the caller service or workflow. The runtime registers a callback URL for the webhook with the caller service or workflow. The webhook then waits for the caller to send the request using the callback URL.
However, in Visual Studio Code, you have to complete some setup tasks for webhook operations to work correctly. In this scenario, the callback URL uses yourlocalhostserver (http://localhost:7071/...), which is private, so the caller can't directly send a request over the internet to this URL.
http://localhost:7071/...
For webhook operations in locally running workflows, you need to set up a public URL that exposes yourlocalhostserver and securely forwards calls from the caller to the callback URL. You can use a forwarding service and tool such asngrok, which opens an HTTP tunnel to your localhost port, or you can use your own equivalent tool.
Go to thengrokwebsite. Sign up for a new account or sign in to your account, if you have one already.
Go to thengrokwebsite. Sign up for a new account or sign in to your account, if you have one already.
Get your personal authentication token, which yourngrokclient needs to connect and authenticate access to your account.To find your authentication token page, on your account dashboard menu, expandAuthentication, and selectYour Authtoken.From theYour Authtokenbox, copy the token to a safe location.
Get your personal authentication token, which yourngrokclient needs to connect and authenticate access to your account.
To find your authentication token page, on your account dashboard menu, expandAuthentication, and selectYour Authtoken.
To find your authentication token page, on your account dashboard menu, expandAuthentication, and selectYour Authtoken.
From theYour Authtokenbox, copy the token to a safe location.
From theYour Authtokenbox, copy the token to a safe location.
From thengrokdownload pageoryour account dashboard, download thengrokversion that you want, and extract the .zip file.For more information, seeStep 1: Unzip to install.
From thengrokdownload pageoryour account dashboard, download thengrokversion that you want, and extract the .zip file.
For more information, seeStep 1: Unzip to install.
On your computer, open your command prompt tool. Browse to the location where you have thengrok.exefile.
On your computer, open your command prompt tool. Browse to the location where you have thengrok.exefile.
Connect thengrokclient to yourngrokaccount by running the following command:ngrok authtoken <your-authentication-token>For more information, seeStep 2: Connect your account.
Connect thengrokclient to yourngrokaccount by running the following command:
ngrok authtoken <your-authentication-token>
ngrok authtoken <your-authentication-token>
For more information, seeStep 2: Connect your account.
Open the HTTP tunnel to localhost port 7071 by running the following command:ngrok http 7071For more information, seeStep 3: Fire it up.
Open the HTTP tunnel to localhost port 7071 by running the following command:
ngrok http 7071
ngrok http 7071
For more information, seeStep 3: Fire it up.
From the output, find the following line:http://<domain>.ngrok.io -> http://localhost:7071
From the output, find the following line:
http://<domain>.ngrok.io -> http://localhost:7071
http://<domain>.ngrok.io -> http://localhost:7071
Copy and save the URL that has this format:http://<domain>.ngrok.io
Copy and save the URL that has this format:http://<domain>.ngrok.io
http://<domain>.ngrok.io
In Visual Studio Code, on the designer, add the webhook operation that you want to use in your workflow.This example continues with theHTTP + Webhooktrigger.
In Visual Studio Code, on the designer, add the webhook operation that you want to use in your workflow.
This example continues with theHTTP + Webhooktrigger.
When the prompt appears for the host endpoint location, enter the forwarding (redirection) URL that you previously created.NoteIgnoring the prompt causes a warning to appear that you must provide the forwarding URL,
so selectConfigure, and enter the URL. After you finish this step, the prompt won't
appear for subsequent webhook operations that you might add.To make the prompt appear, at your project's root level, open thelocal.settings.jsonfile's shortcut menu, and selectConfigure Webhook Redirect Endpoint. The prompt now
appears so you can provide the forwarding URL.Visual Studio Code adds the forwarding URL to thelocal.settings.jsonfile in your project's root folder. In theValuesobject, the property namedWorkflows.WebhookRedirectHostUrinow appears and is set to the forwarding URL, for example:{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "FUNCTIONS_V2_COMPATIBILITY_MODE": "true",
      <...>
      "Workflows.WebhookRedirectHostUri": "http://xxxXXXXxxxXXX.ngrok.io",
      <...>
   }
}For more information about these app settings, seeEdit app settings and host settings for Standard logic apps.
When the prompt appears for the host endpoint location, enter the forwarding (redirection) URL that you previously created.
Note
Ignoring the prompt causes a warning to appear that you must provide the forwarding URL,
so selectConfigure, and enter the URL. After you finish this step, the prompt won't
appear for subsequent webhook operations that you might add.
To make the prompt appear, at your project's root level, open thelocal.settings.jsonfile's shortcut menu, and selectConfigure Webhook Redirect Endpoint. The prompt now
appears so you can provide the forwarding URL.
Visual Studio Code adds the forwarding URL to thelocal.settings.jsonfile in your project's root folder. In theValuesobject, the property namedWorkflows.WebhookRedirectHostUrinow appears and is set to the forwarding URL, for example:
Values
Workflows.WebhookRedirectHostUri
{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "FUNCTIONS_V2_COMPATIBILITY_MODE": "true",
      <...>
      "Workflows.WebhookRedirectHostUri": "http://xxxXXXXxxxXXX.ngrok.io",
      <...>
   }
}
{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "FUNCTIONS_V2_COMPATIBILITY_MODE": "true",
      <...>
      "Workflows.WebhookRedirectHostUri": "http://xxxXXXXxxxXXX.ngrok.io",
      <...>
   }
}
For more information about these app settings, seeEdit app settings and host settings for Standard logic apps.
The first time when you start a local debugging session or run the workflow without debugging, the Azure Logic Apps runtime registers the workflow with the caller and subscribes to the caller endpoint that notifies webhook operations. The next time that your workflow runs, the runtime won't register or resubscribe because the subscription registration already exists in local storage.
When you stop the debugging session for a workflow that uses locally run webhook operations, the existing subscription registrations aren't deleted. To unregister, you have to manually remove or delete the subscription registrations.
Note
After your workflow starts running, the terminal window might show errors like this example:
message='Http request failed with unhandled exception of type 'InvalidOperationException' and message: 'System.InvalidOperationException: Synchronous operations are disallowed. Call ReadAsync or set AllowSynchronousIO to true instead.'
message='Http request failed with unhandled exception of type 'InvalidOperationException' and message: 'System.InvalidOperationException: Synchronous operations are disallowed. Call ReadAsync or set AllowSynchronousIO to true instead.'
In this case, open thelocal.settings.jsonfile in your project's root folder, and make sure that the property is set totrue:
true
"FUNCTIONS_V2_COMPATIBILITY_MODE": "true"
"FUNCTIONS_V2_COMPATIBILITY_MODE": "true"

Enable run history for stateless workflows
To debug a stateless workflow more easily, you can enable the run history for that workflow, and then disable the run history when you're done. Follow these steps for Visual Studio Code, or if you're working in the Azure portal, seeCreate single-tenant based workflows in the Azure portal.
In your Visual Studio Code project, at the root folder level, open thelocal.settings.jsonfile.
In your Visual Studio Code project, at the root folder level, open thelocal.settings.jsonfile.
Add theWorkflows.<workflow-name>.operationOptionsproperty, and set the value toWithStatelessRunHistory, for example:Windows{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "Workflows.<workflow-name>.OperationOptions": "WithStatelessRunHistory"
   }
}macOS or Linux{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "DefaultEndpointsProtocol=https;AccountName=fabrikamstorageacct; \
          AccountKey=<access-key>;EndpointSuffix=core.windows.net",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "Workflows.<workflow-name>.OperationOptions": "WithStatelessRunHistory"
   }
}
Add theWorkflows.<workflow-name>.operationOptionsproperty, and set the value toWithStatelessRunHistory, for example:
Workflows.<workflow-name>.operationOptions
WithStatelessRunHistory
Windows
{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "Workflows.<workflow-name>.OperationOptions": "WithStatelessRunHistory"
   }
}
{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "Workflows.<workflow-name>.OperationOptions": "WithStatelessRunHistory"
   }
}
macOS or Linux
{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "DefaultEndpointsProtocol=https;AccountName=fabrikamstorageacct; \
          AccountKey=<access-key>;EndpointSuffix=core.windows.net",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "Workflows.<workflow-name>.OperationOptions": "WithStatelessRunHistory"
   }
}
{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "DefaultEndpointsProtocol=https;AccountName=fabrikamstorageacct; \
          AccountKey=<access-key>;EndpointSuffix=core.windows.net",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "Workflows.<workflow-name>.OperationOptions": "WithStatelessRunHistory"
   }
}
In the project folder namedworkflow-designtime, open thelocal.settings.jsonfile, and make the same change.
In the project folder namedworkflow-designtime, open thelocal.settings.jsonfile, and make the same change.
To disable the run history when you're done, either set theWorkflows.<workflow-name>.OperationOptionsproperty toNone, or delete the property and its value.
To disable the run history when you're done, either set theWorkflows.<workflow-name>.OperationOptionsproperty toNone, or delete the property and its value.
Workflows.<workflow-name>.OperationOptions
None

Add artifacts and dependencies to your project
In specific scenarios, your workflow might include operations that require dependencies such as assemblies, or artifacts such as maps, schemas, or rules. In Visual Studio Code, you can add these items to the corresponding folders in your project, for example:

Convert your project to NuGet package-based (.NET)
By default, Visual Studio Code creates your logic app project as an extension bundle-based (Node.js) project. If you need a project that is NuGet package-based (.NET), for example, to create your own built-in connectors, you must convert your default project to a NuGet package-based (.NET) project.
Important
This action is a one-way operation that you can't undo.
In the Explorer pane, move your mouse pointer over any blank area below your project's folders and files, open the shortcut menu, and selectConvert to NuGet-based logic app project.
In the Explorer pane, move your mouse pointer over any blank area below your project's folders and files, open the shortcut menu, and selectConvert to NuGet-based logic app project.

When the prompt appears, confirm the project conversion.
When the prompt appears, confirm the project conversion.

Important
This task is required only for NuGet package-based (.NET) logic
app projects created before assemblies support became available.
If you created your logic app project when assemblies support wasn't available for Standard logic app workflows, you can add the following lines to your<project-name>.csprojfile to work with projects that use assemblies:
<ItemGroup>
    <LibDirectory Include="$(MSBuildProjectDirectory)\lib\**\*"/>
  </ItemGroup>
  <Target Name="CopyDynamicLibraries" AfterTargets="_GenerateFunctionsExtensionsMetadataPostPublish">
    <Copy SourceFiles="@(LibDirectory)" DestinationFiles="@(LibDirectory->'$(MSBuildProjectDirectory)\$(PublishUrl)\lib\%(RecursiveDir)%(Filename)%(Extension)')"/>
  </Target>
<ItemGroup>
    <LibDirectory Include="$(MSBuildProjectDirectory)\lib\**\*"/>
  </ItemGroup>
  <Target Name="CopyDynamicLibraries" AfterTargets="_GenerateFunctionsExtensionsMetadataPostPublish">
    <Copy SourceFiles="@(LibDirectory)" DestinationFiles="@(LibDirectory->'$(MSBuildProjectDirectory)\$(PublishUrl)\lib\%(RecursiveDir)%(Filename)%(Extension)')"/>
  </Target>
Important
For a project that runs on Linux or macOS, make sure to update the
directory separator. For example, review the following image that
shows the previous code added to the<project-name>.csprojfile:


Enable built-in connector authoring
You can create your own built-in connectors for any service you need by using thesingle-tenant Azure Logic Apps extensibility framework. Similar to built-in connectors such as Azure Service Bus and SQL Server, these connectors provide higher throughput, low latency, local connectivity, and run natively in the same process as the single-tenant Azure Logic Apps runtime.
The authoring capability is currently available only in Visual Studio Code, but isn't enabled by default. To create these connectors, follow these steps:
If you haven't already,convert your extension bundle-based (Node.js) project to a NuGet package-based (.NET) project.
If you haven't already,convert your extension bundle-based (Node.js) project to a NuGet package-based (.NET) project.
Review and follow the steps in the article,Azure Logic Apps Running Anywhere - Built-in connector extensibility.
Review and follow the steps in the article,Azure Logic Apps Running Anywhere - Built-in connector extensibility.

Run, debug, and test workflows locally
The following sections show how you can set breakpoints and start a debugging session to run and test your workflow locally.

Set breakpoints for debugging
Before you run and test your logic app workflow by starting a debugging session, you can setbreakpointsinside theworkflow.jsonfile for each workflow. No other setup is required.
Breakpoints are currently supported only for actions, not triggers. Each action definition has these breakpoint locations:
Set the starting breakpoint on the line that shows the action's name. When this breakpoint hits during the debugging session, you can review the action's inputs before they're evaluated.
Set the starting breakpoint on the line that shows the action's name. When this breakpoint hits during the debugging session, you can review the action's inputs before they're evaluated.
Set the ending breakpoint on the line that shows the action's closing curly brace (}). When this breakpoint hits during the debugging session, you can review the action's results before the action finishes running.
Set the ending breakpoint on the line that shows the action's closing curly brace (}). When this breakpoint hits during the debugging session, you can review the action's results before the action finishes running.
To add a breakpoint, follow these steps:
Open theworkflow.jsonfile for the workflow that you want to debug.
Open theworkflow.jsonfile for the workflow that you want to debug.
On the line where you want to set the breakpoint, in the left column, select inside that column. To remove the breakpoint, select that breakpoint.When you start your debugging session, the Run view appears on the left side of the code window, while the Debug toolbar appears near the top.NoteIf the Run view doesn't automatically appear, press Ctrl+Shift+D.
On the line where you want to set the breakpoint, in the left column, select inside that column. To remove the breakpoint, select that breakpoint.
When you start your debugging session, the Run view appears on the left side of the code window, while the Debug toolbar appears near the top.
Note
If the Run view doesn't automatically appear, press Ctrl+Shift+D.
To review the available information when a breakpoint hits, in the Run view, examine theVariablespane.
To review the available information when a breakpoint hits, in the Run view, examine theVariablespane.
To continue workflow execution, on the Debug toolbar, selectContinue(play button).
To continue workflow execution, on the Debug toolbar, selectContinue(play button).
You can add and remove breakpoints at any time during the workflow run. However, if you update theworkflow.jsonfile after the run starts, breakpoints don't automatically update. To update the breakpoints, restart the logic app.
For general information, seeBreakpoints - Visual Studio Code.

Debug and test your workflow
To test your workflow, follow these steps to run a debugging session and find the URL for the endpoint that's created by theRequesttrigger. You need this URL so that you can later send a request to that endpoint.
If you have a stateless workflow,enable run history for the workflowto make debugging easier.
If you have a stateless workflow,enable run history for the workflowto make debugging easier.
From theRunmenu, selectStart Debugging(F5).TheTerminalwindow opens so that you can review the debugging session.NoteIf you get the error,"Error exists after running preLaunchTask 'generateDebugSymbols'",
see the troubleshooting section,Debugging session fails to start.
From theRunmenu, selectStart Debugging(F5).
TheTerminalwindow opens so that you can review the debugging session.
Note
If you get the error,"Error exists after running preLaunchTask 'generateDebugSymbols'",
see the troubleshooting section,Debugging session fails to start.
Now, find the callback URL for the endpoint created by theRequesttrigger.Reopen the Explorer pane to view your project.From theworkflow.jsonfile shortcut menu, selectOverview.Copy and save theCallback URL, which looks similar to the following URL for theWhen an HTTP request is receivedtrigger in this example:http://localhost:7071/api/<workflow-name>/triggers/manual/invoke?api-version=2020-05-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=<shared-access-signature>
Now, find the callback URL for the endpoint created by theRequesttrigger.
Reopen the Explorer pane to view your project.
Reopen the Explorer pane to view your project.
From theworkflow.jsonfile shortcut menu, selectOverview.
From theworkflow.jsonfile shortcut menu, selectOverview.

Copy and save theCallback URL, which looks similar to the following URL for theWhen an HTTP request is receivedtrigger in this example:http://localhost:7071/api/<workflow-name>/triggers/manual/invoke?api-version=2020-05-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=<shared-access-signature>
Copy and save theCallback URL, which looks similar to the following URL for theWhen an HTTP request is receivedtrigger in this example:
http://localhost:7071/api/<workflow-name>/triggers/manual/invoke?api-version=2020-05-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=<shared-access-signature>
http://localhost:7071/api/<workflow-name>/triggers/manual/invoke?api-version=2020-05-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=<shared-access-signature>

To test the callback URL and trigger the workflow, send an HTTP request to the URL, including the method that the trigger expects, by using your HTTP request tool and its instructions.This example uses theGETmethod with the copied URL, which looks like the following sample:GET http://localhost:7071/api/Stateful-Workflow/triggers/manual/invoke?api-version=2020-05-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=<shared-access-signature>When the trigger fires, the example workflow runs and sends an email that appears similar to this example:
To test the callback URL and trigger the workflow, send an HTTP request to the URL, including the method that the trigger expects, by using your HTTP request tool and its instructions.
This example uses theGETmethod with the copied URL, which looks like the following sample:
GET http://localhost:7071/api/Stateful-Workflow/triggers/manual/invoke?api-version=2020-05-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=<shared-access-signature>
GET http://localhost:7071/api/Stateful-Workflow/triggers/manual/invoke?api-version=2020-05-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=<shared-access-signature>
When the trigger fires, the example workflow runs and sends an email that appears similar to this example:

In Visual Studio Code, return to your workflow's overview page. UnderRun history, check the status for the workflow run.TipIf the run status doesn't appear, try refreshing the overview page by selectingRefresh.
A run doesn't happen for a trigger that's skipped due to unmet criteria or finding no data.The following table shows the possible final statuses that each workflow run can have and show in Visual Studio Code:Run statusDescriptionAbortedThe run stopped or didn't finish due to external problems, for example, a system outage or lapsed Azure subscription.CancelledThe run was triggered and started but received a cancellation request.FailedAt least one action in the run failed. No subsequent actions in the workflow were set up to handle the failure.RunningThe run was triggered and is in progress, but this status can also appear for a run that is throttled due toaction limitsor thecurrent pricing plan.Tip: If you set updiagnostics logging, you can get information about any throttle events that happen.SucceededThe run succeeded. If any action failed, a subsequent action in the workflow handled that failure.Timed outThe run timed out because the current duration exceeded the run duration limit, which is controlled by the setting namedRun history retention in days. A run's duration is calculated by using the run's start time and run duration limit at that start time.Note: If the run's duration also exceeds the currentrun history retention limit, which is also controlled by theRun history retention in dayssetting, the run is cleared from the run history by a daily cleanup job. Whether the run times out or completes, the retention period is always calculated by using the run's start time andcurrentretention limit. So, if you reduce the duration limit for an in-flight run, the run times out. However, the run either stays or is cleared from the run history based on whether the run's duration exceeded the retention limit.WaitingThe run hasn't started or is paused, for example, due to an earlier workflow instance that's still running.
In Visual Studio Code, return to your workflow's overview page. UnderRun history, check the status for the workflow run.
Tip
If the run status doesn't appear, try refreshing the overview page by selectingRefresh.
A run doesn't happen for a trigger that's skipped due to unmet criteria or finding no data.

The following table shows the possible final statuses that each workflow run can have and show in Visual Studio Code:

Note: If the run's duration also exceeds the currentrun history retention limit, which is also controlled by theRun history retention in dayssetting, the run is cleared from the run history by a daily cleanup job. Whether the run times out or completes, the retention period is always calculated by using the run's start time andcurrentretention limit. So, if you reduce the duration limit for an in-flight run, the run times out. However, the run either stays or is cleared from the run history based on whether the run's duration exceeded the retention limit.
To view each step's status, inputs, and outputs for a specific workflow run, choose either step:In theIdentifiercolumn, select the workflow run ID.Next to theDurationcolumn, open the ellipses (...) menu for a workflow run, and selectShow run, for example:Visual Studio Code opens the run details view and shows the status for each step in the workflow run.NoteIf a run failed and a step in run details view shows the400 Bad Requesterror, this problem might
result from a longer trigger name or action name that causes the underlying Uniform Resource Identifier (URI)
to exceed the default character limit. For more information, see"400 Bad Request".The following table shows the possible statuses that each workflow action can have and show in Visual Studio Code:Action statusDescriptionAbortedThe action stopped or didn't finish due to external problems, for example, a system outage or lapsed Azure subscription.CancelledThe action was running but received a request to cancel.FailedThe action failed.RunningThe action is currently running.SkippedThe action was skipped because the immediately preceding action failed. An action has arunAftercondition that requires that the preceding action finishes successfully before the current action can run.SucceededThe action succeeded.Succeeded with retriesThe action succeeded but only after one or more retries. To review the retry history, in the run history details view, select that action so that you can view the inputs and outputs.Timed outThe action stopped due to the time-out limit specified by that action's settings.WaitingApplies to a webhook action that's waiting for an inbound request from a caller.
To view each step's status, inputs, and outputs for a specific workflow run, choose either step:
In theIdentifiercolumn, select the workflow run ID.
In theIdentifiercolumn, select the workflow run ID.
Next to theDurationcolumn, open the ellipses (...) menu for a workflow run, and selectShow run, for example:
Next to theDurationcolumn, open the ellipses (...) menu for a workflow run, and selectShow run, for example:

Visual Studio Code opens the run details view and shows the status for each step in the workflow run.

Note
If a run failed and a step in run details view shows the400 Bad Requesterror, this problem might
result from a longer trigger name or action name that causes the underlying Uniform Resource Identifier (URI)
to exceed the default character limit. For more information, see"400 Bad Request".
The following table shows the possible statuses that each workflow action can have and show in Visual Studio Code:
runAfter
To view the inputs and outputs for each step, select the step that you want, for example:To view the raw inputs and outputs, selectShow raw inputsorShow raw outputs.
To view the inputs and outputs for each step, select the step that you want, for example:

To view the raw inputs and outputs, selectShow raw inputsorShow raw outputs.
To stop the debugging session, on theRunmenu, selectStop Debugging(Shift + F5).
To stop the debugging session, on theRunmenu, selectStop Debugging(Shift + F5).

Return a response
When you have a workflow that starts with theWhen an HTTP request is receivedtrigger, your workflow can return a response to the caller that sent the initial request by using theRequestaction namedResponse.
In the workflow designer, under theSend an emailaction,follow these general steps to add theRequestaction namedResponse.
In the workflow designer, under theSend an emailaction,follow these general steps to add theRequestaction namedResponse.

In theResponseaction's information pane, on theParameterstab, provide the required information for response to the caller.This example returns theBodyparameter value, which is the output from theSend an emailaction.For theBodyparameter, select inside the edit box, and select the lightning icon, which opens the dynamic content list. This list shows the available output values from the preceding trigger and actions in the workflow.In the dynamic content list, underSend an email, selectBody.When you're done, theResponseaction'sBodyproperty is now set to theSend an emailaction'sBodyoutput value, for example:
In theResponseaction's information pane, on theParameterstab, provide the required information for response to the caller.
This example returns theBodyparameter value, which is the output from theSend an emailaction.
For theBodyparameter, select inside the edit box, and select the lightning icon, which opens the dynamic content list. This list shows the available output values from the preceding trigger and actions in the workflow.
For theBodyparameter, select inside the edit box, and select the lightning icon, which opens the dynamic content list. This list shows the available output values from the preceding trigger and actions in the workflow.
In the dynamic content list, underSend an email, selectBody.When you're done, theResponseaction'sBodyproperty is now set to theSend an emailaction'sBodyoutput value, for example:
In the dynamic content list, underSend an email, selectBody.

When you're done, theResponseaction'sBodyproperty is now set to theSend an emailaction'sBodyoutput value, for example:

Save your workflow.
Save your workflow.

Retest your workflow
To test your updates, you can rerun the debugger and send another request that triggers your workflow, similar to the steps inRun, debug, and test workflows locally.
On the Visual Studio Code toolbar, from theRunmenu, and selectStart Debugging(F5).
On the Visual Studio Code toolbar, from theRunmenu, and selectStart Debugging(F5).
In your tool for creating and sending requests, send another request to trigger your workflow.
In your tool for creating and sending requests, send another request to trigger your workflow.
On the workflow's overview page, underRun history, check the status for the most recent run, and open the run details view.For example, here's the step-by-step status for a run after the example workflow was updated with theResponseaction.
On the workflow's overview page, underRun history, check the status for the most recent run, and open the run details view.
For example, here's the step-by-step status for a run after the example workflow was updated with theResponseaction.

To stop the debugging session, on theRunmenu, selectStop Debugging(Shift + F5).
To stop the debugging session, on theRunmenu, selectStop Debugging(Shift + F5).

Prepare for deployment
Before you deploy your Standard logic app to the Azure portal, review this section for any preparation that you might need to make.

Set up firewall access
If your environment has strict network requirements or firewalls that limit traffic, you have to set up permissions for any connections created byAzure managed, hosted, and shared connectorsand used in your workflow.
To find the fully qualified domain names (FQDNs) for these connections, follow these steps:
In your logic app project, open thelocal.settings.jsonfile.
In your logic app project, open thelocal.settings.jsonfile.
For each connection that you created, find the property named<connection-name>-ConnectionRuntimeUrl, which uses the following syntax:"<connection-name>-ConnectionRuntimeUrl": <connection-runtime-URL>For example, suppose you have a samplelocal.settings.jsonfile that contains these connections: an Office 365 connection and an AS2 connection. These connections use the following respective sample values for the<connection-name>-ConnectionRuntimeUrlproperties:Office 365:"office365-ConnectionRuntimeUrl": https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/office365/a0a0a0a0-bbbb-cccc-dddd-e1e1e1e1e1e1"AS2:"as2-ConnectionRuntimeUrl": https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/as2/b1b1b1b1-cccc-dddd-eeee-f2f2f2f2f2f2The samplelocal.settings.jsonfile looks similar to the following version:{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "node",
      "APP_KIND": "workflowapp",
      "ProjectDirectoryPath": "c:\\Users\\<local-username>\\Desktop\\Visual Studio Code projects\\Azure Logic Apps\fabrikam-workflows\\Fabrikam-Workflows\\Fabrikam-Workflows",
      "WORKFLOWS_TENANT_ID": "<Microsoft-Entra-tenant-ID>",
      "WORKFLOWS_SUBSCRIPTION_ID": "<Azure-subscription-ID>",
      "WORKFLOWS_RESOURCE_GROUP_NAME": "Fabrikam-Workflows-RG",
      "WORKFLOWS_LOCATION_NAME": "westcentralus",
      "WORKFLOWS_MANAGEMENT_BASE_URI": "https://management.azure.com/",
      "as2-connectionKey": "<connection-key>",
      "as2-ConnectionRuntimeUrl": "https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/as2/b1b1b1b1-cccc-dddd-eeee-f2f2f2f2f2f2",
      "office365-connectionKey": "<connection-key>",
      "office365-ConnectionRuntimeUrl": "https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/office365/a0a0a0a0-bbbb-cccc-dddd-e1e1e1e1e1e1",
   }
}
For each connection that you created, find the property named<connection-name>-ConnectionRuntimeUrl, which uses the following syntax:
<connection-name>-ConnectionRuntimeUrl
"<connection-name>-ConnectionRuntimeUrl": <connection-runtime-URL>
"<connection-name>-ConnectionRuntimeUrl": <connection-runtime-URL>
For example, suppose you have a samplelocal.settings.jsonfile that contains these connections: an Office 365 connection and an AS2 connection. These connections use the following respective sample values for the<connection-name>-ConnectionRuntimeUrlproperties:
<connection-name>-ConnectionRuntimeUrl
Office 365:"office365-ConnectionRuntimeUrl": https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/office365/a0a0a0a0-bbbb-cccc-dddd-e1e1e1e1e1e1"
Office 365:"office365-ConnectionRuntimeUrl": https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/office365/a0a0a0a0-bbbb-cccc-dddd-e1e1e1e1e1e1"
"office365-ConnectionRuntimeUrl": https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/office365/a0a0a0a0-bbbb-cccc-dddd-e1e1e1e1e1e1"
AS2:"as2-ConnectionRuntimeUrl": https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/as2/b1b1b1b1-cccc-dddd-eeee-f2f2f2f2f2f2
AS2:"as2-ConnectionRuntimeUrl": https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/as2/b1b1b1b1-cccc-dddd-eeee-f2f2f2f2f2f2
"as2-ConnectionRuntimeUrl": https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/as2/b1b1b1b1-cccc-dddd-eeee-f2f2f2f2f2f2
The samplelocal.settings.jsonfile looks similar to the following version:
{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "node",
      "APP_KIND": "workflowapp",
      "ProjectDirectoryPath": "c:\\Users\\<local-username>\\Desktop\\Visual Studio Code projects\\Azure Logic Apps\fabrikam-workflows\\Fabrikam-Workflows\\Fabrikam-Workflows",
      "WORKFLOWS_TENANT_ID": "<Microsoft-Entra-tenant-ID>",
      "WORKFLOWS_SUBSCRIPTION_ID": "<Azure-subscription-ID>",
      "WORKFLOWS_RESOURCE_GROUP_NAME": "Fabrikam-Workflows-RG",
      "WORKFLOWS_LOCATION_NAME": "westcentralus",
      "WORKFLOWS_MANAGEMENT_BASE_URI": "https://management.azure.com/",
      "as2-connectionKey": "<connection-key>",
      "as2-ConnectionRuntimeUrl": "https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/as2/b1b1b1b1-cccc-dddd-eeee-f2f2f2f2f2f2",
      "office365-connectionKey": "<connection-key>",
      "office365-ConnectionRuntimeUrl": "https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/office365/a0a0a0a0-bbbb-cccc-dddd-e1e1e1e1e1e1",
   }
}
{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "node",
      "APP_KIND": "workflowapp",
      "ProjectDirectoryPath": "c:\\Users\\<local-username>\\Desktop\\Visual Studio Code projects\\Azure Logic Apps\fabrikam-workflows\\Fabrikam-Workflows\\Fabrikam-Workflows",
      "WORKFLOWS_TENANT_ID": "<Microsoft-Entra-tenant-ID>",
      "WORKFLOWS_SUBSCRIPTION_ID": "<Azure-subscription-ID>",
      "WORKFLOWS_RESOURCE_GROUP_NAME": "Fabrikam-Workflows-RG",
      "WORKFLOWS_LOCATION_NAME": "westcentralus",
      "WORKFLOWS_MANAGEMENT_BASE_URI": "https://management.azure.com/",
      "as2-connectionKey": "<connection-key>",
      "as2-ConnectionRuntimeUrl": "https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/as2/b1b1b1b1-cccc-dddd-eeee-f2f2f2f2f2f2",
      "office365-connectionKey": "<connection-key>",
      "office365-ConnectionRuntimeUrl": "https://A1bC2dE3fH4iJ5kL6mN7oP8qR9sT0u.00.common.logic-<Azure-region>.azure-apihub.net/apim/office365/a0a0a0a0-bbbb-cccc-dddd-e1e1e1e1e1e1",
   }
}
Copy and save these connection runtime URLs somewhere safe so that you can set up your firewall with this information.
Copy and save these connection runtime URLs somewhere safe so that you can set up your firewall with this information.
When you're ready, set up your firewall using the saved URLs. For more information, see the following documentation:Azure Firewall Manager Policy overviewDeploy and configure Azure Firewall using the Azure portal - classic.
When you're ready, set up your firewall using the saved URLs. For more information, see the following documentation:
Azure Firewall Manager Policy overview
Deploy and configure Azure Firewall using the Azure portal - classic.

Deploy to Azure
To deploy your Standard logic app from Visual Studio Code, you can directly publish your project to Azure. You can publish your logic app as a new resource, which automatically creates any required resources, such as anAzure storage account, similar to the function app requirements. Or, you can publish your logic app to a previously deployed Standard logic app resource, which overwrites the deployed version.
Deployment for the Standard logic app resource requires a hosting plan and pricing tier, which you select during deployment. For more information, seeHosting plans and pricing tiers.

Publish to a new Standard logic app resource
In the Explorer pane, move your mouse pointer over any blank area below your project's folders and files, open the shortcut menu, and selectDeploy to logic app.Although you don't need to have any files open to deploy, make sure that you saved everything that you plan to deploy.You are prompted with the following options for the destination Standard logic app resource. You can create a new Standard logic app or select an existing deployed Standard logic app in Azure:Create new Logic App (Standard) in Azure(quick)Create new Logic App (Standard) in Azure AdvancedSelect from previously deployed Standard logic app resources, if any exist.
In the Explorer pane, move your mouse pointer over any blank area below your project's folders and files, open the shortcut menu, and selectDeploy to logic app.
Although you don't need to have any files open to deploy, make sure that you saved everything that you plan to deploy.

You are prompted with the following options for the destination Standard logic app resource. You can create a new Standard logic app or select an existing deployed Standard logic app in Azure:
Create new Logic App (Standard) in Azure(quick)
Create new Logic App (Standard) in Azure Advanced
Select from previously deployed Standard logic app resources, if any exist.
For the deployment options, select whether to create or use an existing destination logic app resource.This example continues withCreate new Logic App (Standard) in Azure Advanced.
For the deployment options, select whether to create or use an existing destination logic app resource.
This example continues withCreate new Logic App (Standard) in Azure Advanced.

Follow these steps to create the new destination logic app resource:Enter a globally unique name for the destination logic app.This example usesFabrikam-Workflows-App.For the location where to deploy, select the Azure region.This example usesWest Central US.For the hosting plan, choose from the following options:Hosting planDescriptionWorkflow StandardDeploy as a new Standard logic app resource hosted in single-tenant Azure Logic Apps.HybridDeploy as a Standard logic app hosted on your own infrastructure.Note: Before you select this option, make sure that you have set up the necessary infrastructure. For more information, seeSet up your own infrastructure for Standard logic apps using hybrid deployment.For the Windows App Service plan, choose one of the following options:Create new App Service planSelect from existing App Service plans in the selected Azure region (Windows-based plans only), if any exist.This example selectsCreate new App Service plan.For the new plan, provide a globally unique name, and select a pricing tier.This example usesFabrikam-Workflows-App-Service-Plan, and selects theWS1 Workflow Standardtier.For more information, seeHosting plans and pricing tiers.For the destination Azure resource group, select the same resource group as your project for optimal performance.This example uses the same previously created group namedFabrikam-Workflows-RG.NoteAlthough you can create or use a different resource group, doing so might
affect performance. If you create or choose a different resource group,
but cancel after the confirmation prompt appears, your deployment is also canceled.For the Azure storage account to use with workflows that enable saving run history information, choose from the following options:Create new storage accountSelect from existing Azure storage accounts, if any.This example selectsCreate new storage account.Enter a globally unique name for the storage account. You can use only lowercase letters and numbers.This example usesfabrikamstorageaccount<number>.For the option to use SQL storage in this example, selectNo.If you already set up an SQL database to use for storage by followingSet up SQL database storage for Standard logic app workflows, you can selectYes.For the Application Insights resource, which enables diagnostic logging and tracing for your logic app, choose from the following options:Create new Application Insights resourceSkip for now. You can set up Application Insights after deployment.Select an existing Application Insights resource, if any exist.This example selectsSkip for now.NoteIf you have an Application Insights resource that you want to use, you can select that resource.To create a new Application Insights resource at this time so you can enable diagnostics logging
and tracing, seeEnable Application Insights during deployment.For more information about Application Insights, see the following documentation:Application Insights overviewCreate and configure Application Insights resourcesAfter you selectSkip for nowor an existing Application Insights resource, Visual Studio Code shows a confirmation message to start deployment. The message also recommends that for the best performance, put connection resources for managed operations in the same resource group as your logic app resource and workflows. In Azure Logic Apps, managed operation connections exist as individual Azure resources.
Follow these steps to create the new destination logic app resource:
Enter a globally unique name for the destination logic app.This example usesFabrikam-Workflows-App.
Enter a globally unique name for the destination logic app.
This example usesFabrikam-Workflows-App.

For the location where to deploy, select the Azure region.This example usesWest Central US.
For the location where to deploy, select the Azure region.
This example usesWest Central US.
For the hosting plan, choose from the following options:Hosting planDescriptionWorkflow StandardDeploy as a new Standard logic app resource hosted in single-tenant Azure Logic Apps.HybridDeploy as a Standard logic app hosted on your own infrastructure.Note: Before you select this option, make sure that you have set up the necessary infrastructure. For more information, seeSet up your own infrastructure for Standard logic apps using hybrid deployment.
For the hosting plan, choose from the following options:
For the Windows App Service plan, choose one of the following options:Create new App Service planSelect from existing App Service plans in the selected Azure region (Windows-based plans only), if any exist.This example selectsCreate new App Service plan.
For the Windows App Service plan, choose one of the following options:
Create new App Service plan
Select from existing App Service plans in the selected Azure region (Windows-based plans only), if any exist.
This example selectsCreate new App Service plan.
For the new plan, provide a globally unique name, and select a pricing tier.This example usesFabrikam-Workflows-App-Service-Plan, and selects theWS1 Workflow Standardtier.For more information, seeHosting plans and pricing tiers.
For the new plan, provide a globally unique name, and select a pricing tier.
This example usesFabrikam-Workflows-App-Service-Plan, and selects theWS1 Workflow Standardtier.
For more information, seeHosting plans and pricing tiers.
For the destination Azure resource group, select the same resource group as your project for optimal performance.This example uses the same previously created group namedFabrikam-Workflows-RG.NoteAlthough you can create or use a different resource group, doing so might
affect performance. If you create or choose a different resource group,
but cancel after the confirmation prompt appears, your deployment is also canceled.
For the destination Azure resource group, select the same resource group as your project for optimal performance.
This example uses the same previously created group namedFabrikam-Workflows-RG.
Note
Although you can create or use a different resource group, doing so might
affect performance. If you create or choose a different resource group,
but cancel after the confirmation prompt appears, your deployment is also canceled.
For the Azure storage account to use with workflows that enable saving run history information, choose from the following options:Create new storage accountSelect from existing Azure storage accounts, if any.This example selectsCreate new storage account.
For the Azure storage account to use with workflows that enable saving run history information, choose from the following options:
Create new storage account
Select from existing Azure storage accounts, if any.
This example selectsCreate new storage account.
Enter a globally unique name for the storage account. You can use only lowercase letters and numbers.This example usesfabrikamstorageaccount<number>.
Enter a globally unique name for the storage account. You can use only lowercase letters and numbers.
This example usesfabrikamstorageaccount<number>.
For the option to use SQL storage in this example, selectNo.If you already set up an SQL database to use for storage by followingSet up SQL database storage for Standard logic app workflows, you can selectYes.
For the option to use SQL storage in this example, selectNo.
If you already set up an SQL database to use for storage by followingSet up SQL database storage for Standard logic app workflows, you can selectYes.
For the Application Insights resource, which enables diagnostic logging and tracing for your logic app, choose from the following options:Create new Application Insights resourceSkip for now. You can set up Application Insights after deployment.Select an existing Application Insights resource, if any exist.This example selectsSkip for now.NoteIf you have an Application Insights resource that you want to use, you can select that resource.To create a new Application Insights resource at this time so you can enable diagnostics logging
and tracing, seeEnable Application Insights during deployment.For more information about Application Insights, see the following documentation:Application Insights overviewCreate and configure Application Insights resourcesAfter you selectSkip for nowor an existing Application Insights resource, Visual Studio Code shows a confirmation message to start deployment. The message also recommends that for the best performance, put connection resources for managed operations in the same resource group as your logic app resource and workflows. In Azure Logic Apps, managed operation connections exist as individual Azure resources.
For the Application Insights resource, which enables diagnostic logging and tracing for your logic app, choose from the following options:
Create new Application Insights resource
Skip for now. You can set up Application Insights after deployment.
Select an existing Application Insights resource, if any exist.
This example selectsSkip for now.
Note
If you have an Application Insights resource that you want to use, you can select that resource.
If you have an Application Insights resource that you want to use, you can select that resource.
To create a new Application Insights resource at this time so you can enable diagnostics logging
and tracing, seeEnable Application Insights during deployment.
To create a new Application Insights resource at this time so you can enable diagnostics logging
and tracing, seeEnable Application Insights during deployment.
For more information about Application Insights, see the following documentation:
Application Insights overview
Create and configure Application Insights resources
After you selectSkip for nowor an existing Application Insights resource, Visual Studio Code shows a confirmation message to start deployment. The message also recommends that for the best performance, put connection resources for managed operations in the same resource group as your logic app resource and workflows. In Azure Logic Apps, managed operation connections exist as individual Azure resources.

When you're ready to deploy, in the confirmation message, selectDeploy.Visual Studio Code starts to create and deploy the necessary resources to publish your logic app to Azure.
When you're ready to deploy, in the confirmation message, selectDeploy.
Visual Studio Code starts to create and deploy the necessary resources to publish your logic app to Azure.
To view and monitor the deployment process, on theViewmenu, selectOutput.
To view and monitor the deployment process, on theViewmenu, selectOutput.
In theOutputwindow toolbar, from the scope list, selectAzure Logic Apps (Standard).When Visual Studio Code finishes deploying your logic app to Azure, a message appears that logic app creation successfully completed, for example:Your logic app resource and workflow are now live, enabled, and running in Azure.
In theOutputwindow toolbar, from the scope list, selectAzure Logic Apps (Standard).

When Visual Studio Code finishes deploying your logic app to Azure, a message appears that logic app creation successfully completed, for example:

Your logic app resource and workflow are now live, enabled, and running in Azure.

Enable Application Insights during deployment
To enable diagnostics logging and tracing with Application Insights during deployment for your logic app, follow these steps:
Select either an existing Application Insights resource orCreate new Application Insights resource.
Select either an existing Application Insights resource orCreate new Application Insights resource.
In theAzure portal, go to your Application Insights resource.
In theAzure portal, go to your Application Insights resource.
On the resource menu, selectOverview. Find and copy theInstrumentation Keyvalue.
On the resource menu, selectOverview. Find and copy theInstrumentation Keyvalue.
In Visual Studio Code, in your project's root folder, open thelocal.settings.jsonfile.In theValuesobject, add theAPPINSIGHTS_INSTRUMENTATIONKEYproperty, and set the value to the instrumentation key, for example:{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "APPINSIGHTS_INSTRUMENTATIONKEY": <instrumentation-key>
   }
}Check whether the workflow trigger and action names correctly appear in your Application Insights instance.In the Azure portal, go to your Application Insights resource.On the resource menu, underInvestigate, selectApplication map.Review the operation names that appear in the map.Some inbound requests from built-in triggers might appear as duplicates in the Application Map. Rather than use theWorkflowName.ActionNameformat, these duplicates use the workflow name as the operation name and originate from the Azure Functions host.Optionally adjust the severity level for the tracing data that your logic app collects and sends to your Application Insights instance.Each time that a workflow-related event happens, such as when a workflow is triggered or when an action runs, the runtime emits various traces. These traces cover the workflow's lifetime and include, but aren't limited to, the following event types:Service activity, such as start, stop, and errors.Jobs and dispatcher activity.Workflow activity, such as trigger, action, and run.Storage request activity, such as success or failure.HTTP request activity, such as inbound, outbound, success, and failure.Any development traces, such as debug messages.Each event type is assigned to a severity level. For example, theTracelevel captures the most detailed messages, while theInformationlevel captures general activity in your workflow, such as when your logic app, workflow, trigger, and actions start and stop.The following table describes the severity levels and their trace types:Severity levelTrace typeCriticalLogs that describe an unrecoverable failure in your logic app workflow.DebugLogs that you can use for investigation during development, for example, inbound and outbound HTTP calls.ErrorLogs that indicate a failure in workflow execution, but not a general failure in your logic app.InformationLogs that track the general activity in your logic app or workflow, for example:- When a trigger, action, or run starts and ends.- When your logic app starts or ends.TraceLogs that contain the most detailed messages, for example, storage requests or dispatcher activity, plus all the messages that are related to workflow execution activity.WarningLogs that highlight an abnormal state in your logic app but doesn't prevent its running.To set the severity level, at your project's root level, open thehost.jsonfile, and find theloggingobject. This object controls the log filtering for all the workflows in your logic app and follows theASP.NET Core layout for log type filtering.{
   "version": "2.0",
   "logging": {
      "applicationInsights": {
         "samplingExcludedTypes": "Request",
         "samplingSettings": {
            "isEnabled": true
         }
      }
   }
}If theloggingobject doesn't contain alogLevelobject that includes theHost.Triggers.Workflowproperty, add those items. Set the property to the severity level for the trace type that you want, for example:{
   "version": "2.0",
   "logging": {
      "applicationInsights": {
         "samplingExcludedTypes": "Request",
         "samplingSettings": {
            "isEnabled": true
         }
      },
      "logLevel": {
         "Host.Triggers.Workflow": "Information"
      }
   }
}
In Visual Studio Code, in your project's root folder, open thelocal.settings.jsonfile.
In theValuesobject, add theAPPINSIGHTS_INSTRUMENTATIONKEYproperty, and set the value to the instrumentation key, for example:{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "APPINSIGHTS_INSTRUMENTATIONKEY": <instrumentation-key>
   }
}
In theValuesobject, add theAPPINSIGHTS_INSTRUMENTATIONKEYproperty, and set the value to the instrumentation key, for example:
Values
APPINSIGHTS_INSTRUMENTATIONKEY
{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "APPINSIGHTS_INSTRUMENTATIONKEY": <instrumentation-key>
   }
}
{
   "IsEncrypted": false,
   "Values": {
      "AzureWebJobsStorage": "UseDevelopmentStorage=true",
      "FUNCTIONS_WORKER_RUNTIME": "dotnet",
      "APPINSIGHTS_INSTRUMENTATIONKEY": <instrumentation-key>
   }
}
Check whether the workflow trigger and action names correctly appear in your Application Insights instance.In the Azure portal, go to your Application Insights resource.On the resource menu, underInvestigate, selectApplication map.Review the operation names that appear in the map.Some inbound requests from built-in triggers might appear as duplicates in the Application Map. Rather than use theWorkflowName.ActionNameformat, these duplicates use the workflow name as the operation name and originate from the Azure Functions host.
Check whether the workflow trigger and action names correctly appear in your Application Insights instance.
In the Azure portal, go to your Application Insights resource.
In the Azure portal, go to your Application Insights resource.
On the resource menu, underInvestigate, selectApplication map.
On the resource menu, underInvestigate, selectApplication map.
Review the operation names that appear in the map.Some inbound requests from built-in triggers might appear as duplicates in the Application Map. Rather than use theWorkflowName.ActionNameformat, these duplicates use the workflow name as the operation name and originate from the Azure Functions host.
Review the operation names that appear in the map.
Some inbound requests from built-in triggers might appear as duplicates in the Application Map. Rather than use theWorkflowName.ActionNameformat, these duplicates use the workflow name as the operation name and originate from the Azure Functions host.
WorkflowName.ActionName
Optionally adjust the severity level for the tracing data that your logic app collects and sends to your Application Insights instance.Each time that a workflow-related event happens, such as when a workflow is triggered or when an action runs, the runtime emits various traces. These traces cover the workflow's lifetime and include, but aren't limited to, the following event types:Service activity, such as start, stop, and errors.Jobs and dispatcher activity.Workflow activity, such as trigger, action, and run.Storage request activity, such as success or failure.HTTP request activity, such as inbound, outbound, success, and failure.Any development traces, such as debug messages.Each event type is assigned to a severity level. For example, theTracelevel captures the most detailed messages, while theInformationlevel captures general activity in your workflow, such as when your logic app, workflow, trigger, and actions start and stop.The following table describes the severity levels and their trace types:Severity levelTrace typeCriticalLogs that describe an unrecoverable failure in your logic app workflow.DebugLogs that you can use for investigation during development, for example, inbound and outbound HTTP calls.ErrorLogs that indicate a failure in workflow execution, but not a general failure in your logic app.InformationLogs that track the general activity in your logic app or workflow, for example:- When a trigger, action, or run starts and ends.- When your logic app starts or ends.TraceLogs that contain the most detailed messages, for example, storage requests or dispatcher activity, plus all the messages that are related to workflow execution activity.WarningLogs that highlight an abnormal state in your logic app but doesn't prevent its running.To set the severity level, at your project's root level, open thehost.jsonfile, and find theloggingobject. This object controls the log filtering for all the workflows in your logic app and follows theASP.NET Core layout for log type filtering.{
   "version": "2.0",
   "logging": {
      "applicationInsights": {
         "samplingExcludedTypes": "Request",
         "samplingSettings": {
            "isEnabled": true
         }
      }
   }
}If theloggingobject doesn't contain alogLevelobject that includes theHost.Triggers.Workflowproperty, add those items. Set the property to the severity level for the trace type that you want, for example:{
   "version": "2.0",
   "logging": {
      "applicationInsights": {
         "samplingExcludedTypes": "Request",
         "samplingSettings": {
            "isEnabled": true
         }
      },
      "logLevel": {
         "Host.Triggers.Workflow": "Information"
      }
   }
}
Optionally adjust the severity level for the tracing data that your logic app collects and sends to your Application Insights instance.
Each time that a workflow-related event happens, such as when a workflow is triggered or when an action runs, the runtime emits various traces. These traces cover the workflow's lifetime and include, but aren't limited to, the following event types:
Service activity, such as start, stop, and errors.
Jobs and dispatcher activity.
Workflow activity, such as trigger, action, and run.
Storage request activity, such as success or failure.
HTTP request activity, such as inbound, outbound, success, and failure.
Any development traces, such as debug messages.
Each event type is assigned to a severity level. For example, theTracelevel captures the most detailed messages, while theInformationlevel captures general activity in your workflow, such as when your logic app, workflow, trigger, and actions start and stop.
Trace
Information
The following table describes the severity levels and their trace types:
To set the severity level, at your project's root level, open thehost.jsonfile, and find theloggingobject. This object controls the log filtering for all the workflows in your logic app and follows theASP.NET Core layout for log type filtering.
logging
{
   "version": "2.0",
   "logging": {
      "applicationInsights": {
         "samplingExcludedTypes": "Request",
         "samplingSettings": {
            "isEnabled": true
         }
      }
   }
}
{
   "version": "2.0",
   "logging": {
      "applicationInsights": {
         "samplingExcludedTypes": "Request",
         "samplingSettings": {
            "isEnabled": true
         }
      }
   }
}
If theloggingobject doesn't contain alogLevelobject that includes theHost.Triggers.Workflowproperty, add those items. Set the property to the severity level for the trace type that you want, for example:
logging
logLevel
Host.Triggers.Workflow
{
   "version": "2.0",
   "logging": {
      "applicationInsights": {
         "samplingExcludedTypes": "Request",
         "samplingSettings": {
            "isEnabled": true
         }
      },
      "logLevel": {
         "Host.Triggers.Workflow": "Information"
      }
   }
}
{
   "version": "2.0",
   "logging": {
      "applicationInsights": {
         "samplingExcludedTypes": "Request",
         "samplingSettings": {
            "isEnabled": true
         }
      },
      "logLevel": {
         "Host.Triggers.Workflow": "Information"
      }
   }
}
Post deployment tasks
The following sections describe tasks to perform after your logic app completes deployment.

Confirm deployment in Azure portal
After you deploy your logic app from Visual Studio Code to the Azure portal, confirm that your logic app appears in the portal. Azure resources are organized and grouped in the portal based on their resource type. To find Standard logic apps, follow these steps:
Sign in to theAzure portalwith your Azure account.
Sign in to theAzure portalwith your Azure account.
In the Azure title search box, enter your logic app name, which should appear as a result in theResourcessection. Select your logic app to open the resource.
In the Azure title search box, enter your logic app name, which should appear as a result in theResourcessection. Select your logic app to open the resource.

On the logic app menu, underWorkflows, selectWorkflows.
On the logic app menu, underWorkflows, selectWorkflows.
On theWorkflowspage, select your workflow.
On theWorkflowspage, select your workflow.
On the workflow menu, underTools, selectDesigner. Confirm that the workflow appears as expected.You can now make changes to this workflow in the Azure portal.
On the workflow menu, underTools, selectDesigner. Confirm that the workflow appears as expected.

You can now make changes to this workflow in the Azure portal.
Make sure toenable the monitoring experience for your deployed logic appso you can view workflow run history, inputs, outputs, and other related information.
Make sure toenable the monitoring experience for your deployed logic appso you can view workflow run history, inputs, outputs, and other related information.

Enable monitoring experience for deployed logic app
Before you can review any workflow run history, inputs, outputs, and related information for a deployed Standard logic app resource with the monitoring experience in the Azure portal, you must first enable that experience on the logic app resource.
In theAzure portal, open the deployed Standard logic app resource.
In theAzure portal, open the deployed Standard logic app resource.
On the resource menu, underAPI, selectCORS.
On the resource menu, underAPI, selectCORS.
On theCORSpane, underAllowed Origins, add the wildcard character (*).
On theCORSpane, underAllowed Origins, add the wildcard character (*).
When you're done, on theCORStoolbar, selectSave.
When you're done, on theCORStoolbar, selectSave.


Enable or open Application Insights after deployment
During workflow execution, your logic app workflow emits telemetry along with other events. You can use this telemetry to get better visibility into how well your workflow runs and how the Azure Logic Apps runtime works.Application Insightsprovides the capability for you to enable diagnostics logging, tracing, and monitoring for your logic app using near real-time telemetry (live metrics). This capability helps you investigate failures and performance problems more easily when you use the telemetry data to diagnose issues, set up alerts, and build charts.
If you didn't previously set up Application Insights, you can enable this capability in the Azure portal after logic app deployment from Visual Studio Code. You need to have an Application Insights resource in Azure, but you can create this resourceseparately in advanceor when you enable this capability after deployment.
If you didn't previously set up Application Insights, you can enable this capability in the Azure portal after logic app deployment from Visual Studio Code. You need to have an Application Insights resource in Azure, but you can create this resourceseparately in advanceor when you enable this capability after deployment.
If you previously set up Application Insights during deployment from Visual Studio Code, you can just open your Application Insights resource from your logic app in the Azure portal.
If you previously set up Application Insights during deployment from Visual Studio Code, you can just open your Application Insights resource from your logic app in the Azure portal.
In theAzure portal, find and open your deployed logic app.
In theAzure portal, find and open your deployed logic app.
On the logic app menu, underMonitoring, selectApplication Insights.
On the logic app menu, underMonitoring, selectApplication Insights.
On theApplication Insightspage, selectTurn on Application Insights.
On theApplication Insightspage, selectTurn on Application Insights.
After theApplication Insightspage updates, in theChange your resourcesection, select from the following options:Create new resourceAzure creates resources for Application Insights and a Log Analytics workspace using the current subscription and resource group. If you want to use a different subscription and resource group, seeCreate a new Application Insights resource, and then return to this page.PropertyDescriptionNew resource nameEither accept the generated name or provide another name.LocationSelect an Azure region.Log Analytics workspaceSelect an existing workspace, if any. Otherwise, a default workspace is created for you. For more information, seeLog Analytics workspace overview.Select existing resource:Select the Azure subscription for your Application Insights resource.Select your Application Insights resource.
After theApplication Insightspage updates, in theChange your resourcesection, select from the following options:
Create new resourceAzure creates resources for Application Insights and a Log Analytics workspace using the current subscription and resource group. If you want to use a different subscription and resource group, seeCreate a new Application Insights resource, and then return to this page.PropertyDescriptionNew resource nameEither accept the generated name or provide another name.LocationSelect an Azure region.Log Analytics workspaceSelect an existing workspace, if any. Otherwise, a default workspace is created for you. For more information, seeLog Analytics workspace overview.
Create new resource
Azure creates resources for Application Insights and a Log Analytics workspace using the current subscription and resource group. If you want to use a different subscription and resource group, seeCreate a new Application Insights resource, and then return to this page.
Select existing resource:Select the Azure subscription for your Application Insights resource.Select your Application Insights resource.
Select existing resource:
Select the Azure subscription for your Application Insights resource.
Select the Azure subscription for your Application Insights resource.
Select your Application Insights resource.
Select your Application Insights resource.
When you're done, at the page bottom, selectApply.
When you're done, at the page bottom, selectApply.
In theAzure portal, find and open your deployed logic app.
In theAzure portal, find and open your deployed logic app.
On the logic app menu, underMonitoring, selectApplication Insights.
On the logic app menu, underMonitoring, selectApplication Insights.
On theApplication Insightspage, select the link for your Application Insights resource.
On theApplication Insightspage, select the link for your Application Insights resource.
After Application Insights opens, you can review various metrics for your logic app. For more information, see these articles:
Azure Logic Apps Running Anywhere - Monitor with Application Insights - part 1
Azure Logic Apps Running Anywhere - Monitor with Application Insights - part 2

Troubleshoot errors and problems

Designer fails to open
When you try to open the designer, you get this error,"Workflow design time could not be started". If you previously tried to open the designer, but you discontinued or deleted your project, the extension bundle might not correctly download. To check whether this reason is the cause, follow these steps:
In Visual Studio Code, open the Output window. From theViewmenu, selectOutput.
In Visual Studio Code, open the Output window. From theViewmenu, selectOutput.
From the list in the Output window's title bar, selectAzure Logic Apps (Standard)so that you can review output from the extension, for example:
From the list in the Output window's title bar, selectAzure Logic Apps (Standard)so that you can review output from the extension, for example:

Review the output and check whether this error message appears:A host error has occurred during startup operation '<operation-ID>'.
System.Private.CoreLib: The file 'C:\Users\<user-name>\AppData\Local\Temp\Functions\
ExtensionBundles\Microsoft.Azure.Functions.ExtensionBundle.Workflows\1.1.7\bin\
DurableTask.AzureStorage.dll' already exists.
Value cannot be null. (Parameter 'provider')
Application is shutting down...
Initialization cancellation requested by runtime.
Stopping host...
Host shutdown completed.
Review the output and check whether this error message appears:
A host error has occurred during startup operation '<operation-ID>'.
System.Private.CoreLib: The file 'C:\Users\<user-name>\AppData\Local\Temp\Functions\
ExtensionBundles\Microsoft.Azure.Functions.ExtensionBundle.Workflows\1.1.7\bin\
DurableTask.AzureStorage.dll' already exists.
Value cannot be null. (Parameter 'provider')
Application is shutting down...
Initialization cancellation requested by runtime.
Stopping host...
Host shutdown completed.
A host error has occurred during startup operation '<operation-ID>'.
System.Private.CoreLib: The file 'C:\Users\<user-name>\AppData\Local\Temp\Functions\
ExtensionBundles\Microsoft.Azure.Functions.ExtensionBundle.Workflows\1.1.7\bin\
DurableTask.AzureStorage.dll' already exists.
Value cannot be null. (Parameter 'provider')
Application is shutting down...
Initialization cancellation requested by runtime.
Stopping host...
Host shutdown completed.
To resolve this error, delete theExtensionBundlesfolder at this location...\Users\<user-name>\AppData\Local\Temp\Functions\ExtensionBundles, and retry opening theworkflow.jsonfile in the designer.

New triggers and actions are missing from the designer picker for previously created workflows
Single-tenant Azure Logic Apps supports built-in actions for Azure Function Operations, Liquid Operations, and XML Operations, such asXML ValidationandTransform XML. However, for previously created logic apps, these actions might not appear in the designer picker for you to select if Visual Studio Code uses an outdated version of the extension bundle,Microsoft.Azure.Functions.ExtensionBundle.Workflows.
Microsoft.Azure.Functions.ExtensionBundle.Workflows
Also, theAzure Function Operationsconnector and actions don't appear in the designer picker unless you enabled or selectedUse connectors from Azurewhen you created your logic app. If you didn't enable the Azure-deployed connectors at app creation time, you can enable them from your project in Visual Studio Code. Open theworkflow.jsonshortcut menu, and selectUse Connectors from Azure.
To fix the outdated bundle, follow these steps to delete the outdated bundle, which makes Visual Studio Code automatically update the extension bundle to the latest version.
Note
This solution applies only to logic apps that you create and deploy using Visual Studio Code with
the Azure Logic Apps (Standard) extension, not the logic apps that you create using the Azure portal.
SeeSupported triggers and actions are missing from the designer in the Azure portal.
Save any work that you don't want to lose, and close Visual Studio Code.
Save any work that you don't want to lose, and close Visual Studio Code.
On your computer, browse to the following folder, which contains versioned folders for the existing bundle:...\Users\<user-name>\.azure-functions-core-tools\Functions\ExtensionBundles\Microsoft.Azure.Functions.ExtensionBundle.Workflows
On your computer, browse to the following folder, which contains versioned folders for the existing bundle:
...\Users\<user-name>\.azure-functions-core-tools\Functions\ExtensionBundles\Microsoft.Azure.Functions.ExtensionBundle.Workflows
...\Users\<user-name>\.azure-functions-core-tools\Functions\ExtensionBundles\Microsoft.Azure.Functions.ExtensionBundle.Workflows
Delete the version folder for the earlier bundle, for example, if you have a folder for version 1.1.3, delete that folder.
Delete the version folder for the earlier bundle, for example, if you have a folder for version 1.1.3, delete that folder.
Now, browse to the following folder, which contains versioned folders for required NuGet package:...\Users\<user-name>\.nuget\packages\microsoft.azure.workflows.webjobs.extension
Now, browse to the following folder, which contains versioned folders for required NuGet package:
...\Users\<user-name>\.nuget\packages\microsoft.azure.workflows.webjobs.extension
...\Users\<user-name>\.nuget\packages\microsoft.azure.workflows.webjobs.extension
Delete the version folder for the earlier package.
Delete the version folder for the earlier package.
Reopen Visual Studio Code, your project, and theworkflow.jsonfile in the designer.
Reopen Visual Studio Code, your project, and theworkflow.jsonfile in the designer.
The missing triggers and actions now appear in the designer.

"400 Bad Request" appears on a trigger or action
When a run fails, and you inspect the run in monitoring view, this error might appear on a trigger or action that has a longer name, which causes the underlying Uniform Resource Identifier (URI) to exceed the default character limit.
To resolve this problem and adjust for the longer URI, edit theUrlSegmentMaxCountandUrlSegmentMaxLengthregistry keys on your computer by following these steps. These key's default values are described in this article,Http.sys registry settings for Windows.
UrlSegmentMaxCount
UrlSegmentMaxLength
Important
Before you start, make sure that you save your work. This solution requires you
to restart your computer after you're done so that the changes can take effect.
On your computer, open theRunwindow, and run theregeditcommand, which opens the registry editor.
On your computer, open theRunwindow, and run theregeditcommand, which opens the registry editor.
regedit
In theUser Account Controlbox, selectYesto permit your changes to your computer.
In theUser Account Controlbox, selectYesto permit your changes to your computer.
In the left pane, underComputer, expand the nodes along the path,HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\HTTP\Parameters, and then selectParameters.
In the left pane, underComputer, expand the nodes along the path,HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\HTTP\Parameters, and then selectParameters.
In the right pane, find theUrlSegmentMaxCountandUrlSegmentMaxLengthregistry keys.
In the right pane, find theUrlSegmentMaxCountandUrlSegmentMaxLengthregistry keys.
UrlSegmentMaxCount
UrlSegmentMaxLength
Increase these key values enough so that the URIs can accommodate the names that you want to use. If these keys don't exist, add them to theParametersfolder by following these steps:From theParametersshortcut menu, selectNew>DWORD (32-bit) Value.In the edit box that appears, enterUrlSegmentMaxCountas the new key name.Open the new key's shortcut menu, and selectModify.In theEdit Stringbox that appears, enter theValue datakey value that you want in hexadecimal or decimal format. For example,400in hexadecimal is equivalent to1024in decimal.To add theUrlSegmentMaxLengthkey value, repeat these steps.After you increase or add these key values, the registry editor looks like this example:
Increase these key values enough so that the URIs can accommodate the names that you want to use. If these keys don't exist, add them to theParametersfolder by following these steps:
From theParametersshortcut menu, selectNew>DWORD (32-bit) Value.
From theParametersshortcut menu, selectNew>DWORD (32-bit) Value.
In the edit box that appears, enterUrlSegmentMaxCountas the new key name.
In the edit box that appears, enterUrlSegmentMaxCountas the new key name.
UrlSegmentMaxCount
Open the new key's shortcut menu, and selectModify.
Open the new key's shortcut menu, and selectModify.
In theEdit Stringbox that appears, enter theValue datakey value that you want in hexadecimal or decimal format. For example,400in hexadecimal is equivalent to1024in decimal.
In theEdit Stringbox that appears, enter theValue datakey value that you want in hexadecimal or decimal format. For example,400in hexadecimal is equivalent to1024in decimal.
400
1024
To add theUrlSegmentMaxLengthkey value, repeat these steps.
To add theUrlSegmentMaxLengthkey value, repeat these steps.
UrlSegmentMaxLength
After you increase or add these key values, the registry editor looks like this example:

When you're ready, restart your computer so that the changes can take effect.
When you're ready, restart your computer so that the changes can take effect.

Debugging session fails to start
When you try to start a debugging session, you get the error,"Error exists after running preLaunchTask 'generateDebugSymbols'". To resolve this problem, edit thetasks.jsonfile in your project to skip symbol generation.
In your project, expand the.vscode** folder, and open thetasks.jsonfile.
In your project, expand the.vscode** folder, and open thetasks.jsonfile.
In the following task, delete the line,"dependsOn: "generateDebugSymbols", along with the comma that ends the preceding line, for example:Before:{
   "type": "func",
   "command": "host start",
   "problemMatcher": "$func-watch",
   "isBackground": true,
   "dependsOn": "generateDebugSymbols"
 }After:{
   "type": "func",
   "command": "host start",
   "problemMatcher": "$func-watch",
   "isBackground": true
 }
In the following task, delete the line,"dependsOn: "generateDebugSymbols", along with the comma that ends the preceding line, for example:
"dependsOn: "generateDebugSymbols"
Before:
{
   "type": "func",
   "command": "host start",
   "problemMatcher": "$func-watch",
   "isBackground": true,
   "dependsOn": "generateDebugSymbols"
 }
{
   "type": "func",
   "command": "host start",
   "problemMatcher": "$func-watch",
   "isBackground": true,
   "dependsOn": "generateDebugSymbols"
 }
After:
{
   "type": "func",
   "command": "host start",
   "problemMatcher": "$func-watch",
   "isBackground": true
 }
{
   "type": "func",
   "command": "host start",
   "problemMatcher": "$func-watch",
   "isBackground": true
 }
Related content
Single-tenant versus multitenant in Azure Logic Apps
Manage logic apps in Visual Studio Code
Feedback
Was this page helpful?
Additional resources