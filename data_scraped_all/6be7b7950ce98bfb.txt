Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Build GitHub repositories
Article
2024-12-11
16 contributors
In this article
Azure DevOps Services
Azure Pipelines can automatically build and validate every pull request and commit to your GitHub repository. This article describes how to configure the integration between GitHub and Azure Pipelines.
If you're new to pipelines integration with GitHub, follow the steps inCreate your first pipeline. Come back to this article to learn more about configuring and customizing the integration between GitHub and Azure Pipelines.
Organizations and users
GitHub and Azure Pipelines are two independent services that integrate well together. Each of them have their own organization and user management. This section makes a recommendation on how to replicate the organization and users from GitHub to Azure Pipelines.
Organizations
GitHub's structure consists oforganizations and user accountsthat containrepositories. SeeGitHub's documentation.

Azure DevOps' structure consists oforganizationsthat containprojects. SeePlan your organizational structure.

Azure DevOps can reflect your GitHub structure with:
A DevOpsorganizationfor your GitHuborganization or user account
DevOpsProjectsfor your GitHubrepositories

To set up an identical structure in Azure DevOps:
Create a DevOps organization named after your GitHub organization or user account. It will have a URL likehttps://dev.azure.com/your-organization.
https://dev.azure.com/your-organization
In the DevOps organization, create projects named after your repositories. Theyâll have URLs likehttps://dev.azure.com/your-organization/your-repository.
https://dev.azure.com/your-organization/your-repository
In the DevOps Project, create pipelines named after the GitHub organization and repository they build, such asyour-organization.your-repository. Then, it's clear which repositories they're for.
your-organization.your-repository
Following this pattern, your GitHub repositories and Azure DevOps Projects will have matching URL paths. For example:
https://github.com/python/cpython
https://dev.azure.com/python/cpython
Users
Your GitHub users donât automatically get access to Azure Pipelines. Azure Pipelines is unaware of GitHub identities. For this reason, thereâs no way to configure Azure Pipelines to automatically notify users of a build failure or a PR validation failure using their GitHub identity and email address. You must explicitly create new users in Azure Pipelines to replicate GitHub users. Once you create new users, you can configure their permissions in Azure DevOps to reflect their permissions in GitHub. You can also configure notifications in DevOps using their DevOps identity.
GitHub organization member roles are found athttps://github.com/orgs/your-organization/people(replaceyour-organization).
https://github.com/orgs/your-organization/people
your-organization
DevOps organization member permissions are found athttps://dev.azure.com/your-organization/_settings/security(replaceyour-organization).
https://dev.azure.com/your-organization/_settings/security
your-organization
Roles in a GitHub organization and equivalent roles in an Azure DevOps organization are shown below.
Project Collection Administrators
Project Collection Administrators
Project Collection Valid Users
Create new projects
Allow
A GitHub user account has one role, which is ownership of the account.
DevOps organization member permissions are found athttps://dev.azure.com/your-organization/_settings/security(replaceyour-organization).
https://dev.azure.com/your-organization/_settings/security
your-organization
The GitHub user account role maps to DevOps organization permissions as follows.
Project Collection Administrators
GitHub repository permissions are found athttps://github.com/your-organization/your-repository/settings/collaboration(replaceyour-organizationandyour-repository).
https://github.com/your-organization/your-repository/settings/collaboration
your-organization
your-repository
DevOps project permissions are found athttps://dev.azure.com/your-organization/your-project/_settings/security(replaceyour-organizationandyour-project).
https://dev.azure.com/your-organization/your-project/_settings/security
your-organization
your-project
Equivalent permissions between GitHub repositories and Azure DevOps Projects are as follows.
Project Administrators
Contributors
Readers
If your GitHub repository grants permission to teams, you can create matching teams in theTeamssection of your Azure DevOps project settings. Then, add the teams to the security groups above, just like users.
Teams
To grant permissions to users or teams for specific pipelines in a DevOps project, follow these steps:
Visit the project's Pipelines page (for example,https://dev.azure.com/your-organization/your-project/_build).
https://dev.azure.com/your-organization/your-project/_build
Select the pipeline for which to set specific permissions.
From the '...' context menu, selectSecurity.
SelectAdd...to add a specific user, team, or group and customize their permissions for the pipeline.
Access to GitHub repositories
YAML
Classic
You create a new pipeline by first selecting a GitHub repository and then a YAML file in that repository. The repository in which the YAML file is present is calledselfrepository. By default, this is the repository that your pipeline builds.
self
You can later configure your pipeline to check out a different repository or multiple repositories. To learn how to do this, seemulti-repo checkout.
You create a new pipeline by first selectingGitHubfor repository type, and then one of the repositories you have access to.
Azure Pipelines must be granted access to your repositories to trigger their builds, and fetch their code during builds.
There are three authentication types for granting Azure Pipelines access to your GitHub repositories while creating a pipeline.
GitHub app authentication
The Azure Pipelines GitHub App is therecommendedauthentication type for continuous integration pipelines. After you install the GitHub App in your GitHub account or organization, your pipeline will run without using your personal GitHub identity. Builds and GitHub status updates will be performed using the Azure Pipelines identity. The app works withGitHub Checksto display build, test, and code coverage results in GitHub.
To use the GitHub App, install it in your GitHub organization or user account for some or all repositories. The GitHub App can be installed and uninstalled from the app'shomepage.
After installation, the GitHub App will become Azure Pipelines' default method of authentication to GitHub (instead of OAuth) when pipelines are created for the repositories.
If you install the GitHub App for all repositories in a GitHub organization, you don't need to worry about Azure Pipelines sending mass emails or automatically setting up pipelines on your behalf. However, if the app is installed for all repositories, the token used by the application will have access to all repositories, including private ones. For security reasons, it is recommended to separate private and public repositories at the organization level. This means having a dedicated organization only for public projects without private repositories. If, for some reason, there is a need to have public and private repositories in the same organization, instead of using access for all repositories, explicitly select the repositories to which the application should have access. This requires more work for admins but ensures better security management.
Installation of Azure Pipelines GitHub app requires you to be a GitHub organization owner or repository admin. In addition, to create a pipeline for a GitHub repository with continuous integration and pull request triggers, you must have the required GitHub permissions configured. Otherwise,the repository will not appearin the repository list while creating a pipeline. Depending on the authentication type and ownership of the repository, ensure that the appropriate access is configured.
If the repo is in your personal GitHub account, install the Azure Pipelines GitHub App in your personal GitHub account, and youâll be able to list this repository when creating the pipeline in Azure Pipelines.
If the repo is in your personal GitHub account, install the Azure Pipelines GitHub App in your personal GitHub account, and youâll be able to list this repository when creating the pipeline in Azure Pipelines.
If the repo is in someone else's personal GitHub account, the other person must install the Azure Pipelines GitHub App in their personal GitHub account. You must be added as a collaborator in the repository's settings under "Collaborators". Accept the invitation to be a collaborator using the link that is emailed to you. Once youâve done so, you can create a pipeline for that repository.
If the repo is in someone else's personal GitHub account, the other person must install the Azure Pipelines GitHub App in their personal GitHub account. You must be added as a collaborator in the repository's settings under "Collaborators". Accept the invitation to be a collaborator using the link that is emailed to you. Once youâve done so, you can create a pipeline for that repository.
If the repo is in a GitHub organization that you own, install the Azure Pipelines GitHub App in the GitHub organization. You must also be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams".
If the repo is in a GitHub organization that you own, install the Azure Pipelines GitHub App in the GitHub organization. You must also be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams".
If the repo is in a GitHub organization that someone else owns, a GitHub organization owner or repository admin must install the Azure Pipelines GitHub App in the organization. You must be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams". Accept the invitation to be a collaborator using the link that is emailed to you.
If the repo is in a GitHub organization that someone else owns, a GitHub organization owner or repository admin must install the Azure Pipelines GitHub App in the organization. You must be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams". Accept the invitation to be a collaborator using the link that is emailed to you.
The GitHub App requests the following permissions during installation:
GitHub may display an error such as:
You do not have permission to modify this app on your-organization. Please contact an Organization Owner.
You do not have permission to modify this app on your-organization. Please contact an Organization Owner.
This means that the GitHub App is likely already installed for your organization. When you create a pipeline for a repository in the organization, the GitHub App will automatically be used to connect to GitHub.
Once the GitHub App is installed, pipelines can be created for the organization's repositories in different Azure DevOps organizations and projects. However, if you create pipelines for a single repository in multiple Azure DevOps organizations, only the first organization's pipelines can be automatically triggered by GitHub commits or pull requests. Manual or scheduled builds are still possible in secondary Azure DevOps organizations.
OAuth authentication
OAuthis the simplest authentication type to get started with for repositories in your personal GitHub account. GitHub status updates will be performed on behalf of your personal GitHub identity. For pipelines to keep working, your repository access must remain active. Some GitHub features, like Checks, are unavailable with OAuth and require the GitHub App.
To use OAuth, selectChoose a different connectionbelow the list of repositories while creating a pipeline. Then, selectAuthorizeto sign into GitHub and authorize with OAuth. An OAuth connection will be saved in your Azure DevOps project for later use, and used in the pipeline being created.
To create a pipeline for a GitHub repository with continuous integration and pull request triggers, you must have the required GitHub permissions configured. Otherwise,the repository will not appearin the repository list while creating a pipeline. Depending on the authentication type and ownership of the repository, ensure that the appropriate access is configured.
If the repo is in your personal GitHub account, at least once, authenticate to GitHub with OAuth using your personal GitHub account credentials. This can be done in Azure DevOps project settings under Pipelines > Service connections > New service connection > GitHub > Authorize. Grant Azure Pipelines access to your repositories under "Permissions"here.
If the repo is in your personal GitHub account, at least once, authenticate to GitHub with OAuth using your personal GitHub account credentials. This can be done in Azure DevOps project settings under Pipelines > Service connections > New service connection > GitHub > Authorize. Grant Azure Pipelines access to your repositories under "Permissions"here.
If the repo is in someone else's personal GitHub account, at least once, the other person must authenticate to GitHub with OAuth using their personal GitHub account credentials. This can be done in Azure DevOps project settings under Pipelines > Service connections > New service connection > GitHub > Authorize. The other person must grant Azure Pipelines access to their repositories under "Permissions"here. You must be added as a collaborator in the repository's settings under "Collaborators". Accept the invitation to be a collaborator using the link that is emailed to you.
If the repo is in someone else's personal GitHub account, at least once, the other person must authenticate to GitHub with OAuth using their personal GitHub account credentials. This can be done in Azure DevOps project settings under Pipelines > Service connections > New service connection > GitHub > Authorize. The other person must grant Azure Pipelines access to their repositories under "Permissions"here. You must be added as a collaborator in the repository's settings under "Collaborators". Accept the invitation to be a collaborator using the link that is emailed to you.
If the repo is in a GitHub organization that you own, at least once, authenticate to GitHub with OAuth using your personal GitHub account credentials. This can be done in Azure DevOps project settings under Pipelines > Service connections > New service connection > GitHub > Authorize. Grant Azure Pipelines access to your organization under "Organization access"here. You must be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams".
If the repo is in a GitHub organization that you own, at least once, authenticate to GitHub with OAuth using your personal GitHub account credentials. This can be done in Azure DevOps project settings under Pipelines > Service connections > New service connection > GitHub > Authorize. Grant Azure Pipelines access to your organization under "Organization access"here. You must be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams".
If the repo is in a GitHub organization that someone else owns, at least once, a GitHub organization owner must authenticate to GitHub with OAuth using their personal GitHub account credentials. This can be done in Azure DevOps project settings under Pipelines > Service connections > New service connection > GitHub > Authorize. The organization owner must grant Azure Pipelines access to the organization under "Organization access"here. You must be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams". Accept the invitation to be a collaborator using the link that is emailed to you.
If the repo is in a GitHub organization that someone else owns, at least once, a GitHub organization owner must authenticate to GitHub with OAuth using their personal GitHub account credentials. This can be done in Azure DevOps project settings under Pipelines > Service connections > New service connection > GitHub > Authorize. The organization owner must grant Azure Pipelines access to the organization under "Organization access"here. You must be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams". Accept the invitation to be a collaborator using the link that is emailed to you.
After authorizing Azure Pipelines to use OAuth, to later revoke it and prevent further use, visitOAuth Appsin your GitHub settings. You can also delete it from the list of GitHubservice connectionsin your Azure DevOps project settings.
Personal access token (PAT) authentication
PATsare effectively the same as OAuth, but allow you to control which permissions are granted to Azure Pipelines. Builds and GitHub status updates will be performed on behalf of your personal GitHub identity. For builds to keep working, your repository access must remain active.
To create a PAT, visitPersonal access tokensin your GitHub settings.
The required permissions arerepo,admin:repo_hook,read:user, anduser:email. These are the same permissions required when using OAuth above. Copy the generated PAT to the clipboard and paste it into a new GitHubservice connectionin your Azure DevOps project settings.
For future recall, name the service connection after your GitHub username. It will be available in your Azure DevOps project for later use when creating pipelines.
repo
admin:repo_hook
read:user
user:email
To create a pipeline for a GitHub repository with continuous integration and pull request triggers, you must have the required GitHub permissions configured. Otherwise,the repository will not appearin the repository list while creating a pipeline. Depending on the authentication type and ownership of the repository, ensure that the following access is configured.
If the repo is in your personal GitHub account, the PAT must have the required access scopes underPersonal access tokens:repo,admin:repo_hook,read:user, anduser:email.
If the repo is in your personal GitHub account, the PAT must have the required access scopes underPersonal access tokens:repo,admin:repo_hook,read:user, anduser:email.
repo
admin:repo_hook
read:user
user:email
If the repo is in someone else's personal GitHub account, the PAT must have the required access scopes underPersonal access tokens:repo,admin:repo_hook,read:user, anduser:email. You must be added as a collaborator in the repository's settings under "Collaborators". Accept the invitation to be a collaborator using the link that is emailed to you.
If the repo is in someone else's personal GitHub account, the PAT must have the required access scopes underPersonal access tokens:repo,admin:repo_hook,read:user, anduser:email. You must be added as a collaborator in the repository's settings under "Collaborators". Accept the invitation to be a collaborator using the link that is emailed to you.
repo
admin:repo_hook
read:user
user:email
If the repo is in a GitHub organization that you own, the PAT must have the required access scopes underPersonal access tokens:repo,admin:repo_hook,read:user, anduser:email. You must be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams".
If the repo is in a GitHub organization that you own, the PAT must have the required access scopes underPersonal access tokens:repo,admin:repo_hook,read:user, anduser:email. You must be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams".
repo
admin:repo_hook
read:user
user:email
If the repo is in a GitHub organization that someone else owns, the PAT must have the required access scopes underPersonal access tokens:repo,admin:repo_hook,read:user, anduser:email. You must be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams". Accept the invitation to be a collaborator using the link that is emailed to you.
If the repo is in a GitHub organization that someone else owns, the PAT must have the required access scopes underPersonal access tokens:repo,admin:repo_hook,read:user, anduser:email. You must be added as a collaborator, or your team must be added, in the repository's settings under "Collaborators and teams". Accept the invitation to be a collaborator using the link that is emailed to you.
repo
admin:repo_hook
read:user
user:email
After authorizing Azure Pipelines to use a PAT, to later delete it and prevent further use, visitPersonal access tokensin your GitHub settings. You can also delete it from the list of GitHubservice connectionsin your Azure DevOps project settings.
CI triggers
Continuous integration (CI) triggers cause a pipeline to run whenever you push an update to the specified branches or you push  specified tags.
YAML
Classic
YAML pipelines are configured by default with a CI trigger on all branches, unless theDisable implied YAML CI triggersetting, introduced inAzure DevOps sprint 227, is enabled. TheDisable implied YAML CI triggersetting can be configured at the organization level or at the project level. When theDisable implied YAML CI triggersetting is enabled, CI triggers for YAML pipelines are not enabled if the YAML pipeline doesn't have atriggersection. By default,Disable implied YAML CI triggeris not enabled.
trigger
Branches
You can control which branches get CI triggers with a simple syntax:
trigger:
- main
- releases/*
trigger:
- main
- releases/*
You can specify the full name of the branch (for example,main) or a wildcard (for example,releases/*).
SeeWildcardsfor information on the wildcard syntax.
main
releases/*
Note
You cannot usevariablesin triggers, as variables are evaluated at runtime (after the trigger has fired).
Note
If you usetemplatesto author YAML files, then you can only specify triggers in the main YAML file for the pipeline. You cannot specify triggers in the template files.
For more complex triggers that useexcludeorbatch, you must use the full syntax as shown in the following example.
exclude
batch
# specific branch build
trigger:
  branches:
    include:
    - main
    - releases/*
    exclude:
    - releases/old*
# specific branch build
trigger:
  branches:
    include:
    - main
    - releases/*
    exclude:
    - releases/old*
In the above example, the pipeline will be triggered if a change is pushed tomainor to any releases branch. However, it won't be triggered if a change is made to a releases branch that starts withold.
main
old
If you specify anexcludeclause without anincludeclause, then it is equivalent to specifying*in theincludeclause.
exclude
include
*
include
In addition to specifying branch names in thebrancheslists, you can also configure triggers based on tags by using the following format:
branches
trigger:
  branches:
    include:
      - refs/tags/{tagname}
    exclude:
      - refs/tags/{othertagname}
trigger:
  branches:
    include:
      - refs/tags/{tagname}
    exclude:
      - refs/tags/{othertagname}
If you didn't specify any triggers, and theDisable implied YAML CI triggersetting is not enabled, the default is as if you wrote:
trigger:
  branches:
    include:
    - '*'  # must quote since "*" is a YAML reserved character; we want a string
trigger:
  branches:
    include:
    - '*'  # must quote since "*" is a YAML reserved character; we want a string
Important
When you specify a trigger, it replaces the default implicit trigger, and only pushes to branches that are explicitly configured to be included will trigger a pipeline. Includes are processed first, and then excludes are removed from that list.
Batching CI runs
If you have many team members uploading changes often, you may want to reduce the number of runs you start.
If you setbatchtotrue, when a pipeline is running, the system waits until the run is completed, then starts another run with all changes that have not yet been built.
batch
true
# specific branch build with batching
trigger:
  batch: true
  branches:
    include:
    - main
# specific branch build with batching
trigger:
  batch: true
  branches:
    include:
    - main
Note
batchis not supported in repository resource triggers.
batch
To clarify this example, let us say that a pushAtomaincaused the above pipeline to run. While that pipeline is running, additional pushesBandCoccur into the repository. These updates do not start new independent runs immediately. But after the first run is completed, all pushes until that point of time are batched together and a new run is started.
A
main
B
C
Note
If the pipeline has multiple jobs and stages, then the first run should still reach a terminal state by completing or skipping all its jobs and stages before the second run can start. For this reason, you must exercise caution when using this feature in a pipeline with multiple stages or approvals. If you wish to batch your builds in such cases, it is recommended that you split your CI/CD process into two pipelines - one for build (with batching) and one for deployments.
Paths
You can specify file paths to include or exclude.
# specific path build
trigger:
  branches:
    include:
    - main
    - releases/*
  paths:
    include:
    - docs
    exclude:
    - docs/README.md
# specific path build
trigger:
  branches:
    include:
    - main
    - releases/*
  paths:
    include:
    - docs
    exclude:
    - docs/README.md
When you specify paths, you must explicitly specify branches to trigger on if you are using Azure DevOps Server 2019.1 or lower. You can't trigger a pipeline with only a path filter; you must also have a branch filter, and the changed files that match the path filter must be from a branch that matches the branch filter. If you are using Azure DevOps Server 2020 or newer, you can omitbranchesto filter on all branches in conjunction with the path filter.
branches
Wildcards are supported for path filters. For instance, you can include all paths that matchsrc/app/**/myapp*. You can use wildcard characters (**,*, or?)when specifying path filters.
src/app/**/myapp*
**
*
?)
Paths are always specified relative to the root of the repository.
If you don't set path filters, then the root folder of the repo is implicitly included by default.
If you exclude a path, you cannot also include it unless you qualify it to a deeper folder. For example if you exclude/toolsthen you could include/tools/trigger-runs-on-these
The order of path filters doesn't matter.
Paths in Gitare case-sensitive. Be sure to use the same case as the real folders.
You cannot usevariablesin paths, as variables are evaluated at runtime (after the trigger has fired).
Tags
In addition to specifying tags in thebrancheslists as covered in the previous section, you can directly specify tags to include or exclude:
branches
# specific tag
trigger:
  tags:
    include:
    - v2.*
    exclude:
    - v2.0
# specific tag
trigger:
  tags:
    include:
    - v2.*
    exclude:
    - v2.0
If you don't specify any tag triggers, then by default, tags will not trigger pipelines.
Important
If you specify tags in combination with branch filters, the trigger will fire if either the branch filter is satisfied or the tag filter is satisfied. For example, if a pushed tag satisfies the branch filter, the pipeline triggers even if the tag is excluded by the tag filter, because the push satisfied the branch filter.
Opting out of CI
You can opt out of CI triggers entirely by specifyingtrigger: none.
trigger: none
# A pipeline with no CI trigger
trigger: none
# A pipeline with no CI trigger
trigger: none
Important
When you push a change to a branch, the YAML file in that branch is evaluated to determine if a CI run should be started.
SelectEnable continuous integrationon theTriggerstab to enable this trigger if you want the build to run whenever someone checks in code.
Batch changes
Select this check box if you have many team members uploading changes often and you want to reduce the number of builds you are running. If you select this option, when a build is running, the system waits until the run is completed and then queues another run of all changes that have not yet been built.
You can batch changes and build them together.
Note
If you use batching with a multi-stage YAML pipeline, then a run must reach a terminal state before the next one can start. This is often not desirable as a multi-stage pipeline may go through approvals and long-running deployment stages. In these cases, it is recommended that you follow one of these solutions:
do not use batching
split the pipeline into two separate pipelines - one for CI and one CD
set appropriate conditions on stages to skip them and make a run terminate quickly
Branch filters
You can specify the branches where you want to trigger builds. If you want to use wildcard characters, then type the branch specification (for example,features/modules/*) and then press Enter.
features/modules/*
Path filters
If your Git repo is in Azure Repos or TFS, you can also specify path filters to reduce the set of files that you want to trigger a build.
Tips:
Paths are always specified relative to the root of the repository.
If you don't set path filters, then the root folder of the repo is implicitly included by default.
If you exclude a path, you cannot also include it unless you qualify it to a deeper folder. For example if you exclude/toolsthen you could include/tools/trigger-runs-on-these
The order of path filters doesn't matter.
Paths in Git are case-sensitive. Be sure to use the same case as the real folders.
For example, you want your build to be triggered by changes inmainand most, but not all, of your feature branches. You also don't want builds to be triggered by changes to files in the tools folder.
main

Skipping CI for individual commits
You can also tell Azure Pipelines to skip running a pipeline that a push would normally trigger. Just include[skip ci]in the message or description of any of the commits that are part of a push, and Azure Pipelines will skip running CI for this push. You can also use any of the following variations.
[skip ci]
[skip ci]or[ci skip]
[skip ci]
[ci skip]
skip-checks: trueorskip-checks:true
skip-checks: true
skip-checks:true
[skip azurepipelines]or[azurepipelines skip]
[skip azurepipelines]
[azurepipelines skip]
[skip azpipelines]or[azpipelines skip]
[skip azpipelines]
[azpipelines skip]
[skip azp]or[azp skip]
[skip azp]
[azp skip]
***NO_CI***
***NO_CI***
Using the trigger type in conditions
It is a common scenario to run different steps, jobs, or stages in your pipeline depending on the type of trigger that started the run. You can do this using the system variableBuild.Reason. For example, add the following condition to your step, job, or stage to exclude it from PR validations.
Build.Reason
condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
Behavior of triggers when new branches are pushed
It is common to configure multiple pipelines for the same repository. For instance, you may have one pipeline to build the docs for your app and another to build the source code. You may configure CI triggers with appropriate branch filters and path filters in each of these pipelines. For instance, you may want one pipeline to trigger when you push an update to thedocsfolder, and another one to trigger when you push an update to your application code. In these cases, you need to understand how the pipelines are triggered when a new branch is created.
docs
Here is the behavior when you push a new branch (that matches the branch filters) to your repository:
If your pipeline has path filters, it will be triggered only if the new branch has changes to files that match that path filter.
If your pipeline does not have path filters, it will be triggered even if there are no changes in the new branch.
Wildcards
When specifying a branch, tag, or path, you may use an exact name or a wildcard.
Wildcards patterns allow*to match zero or more characters and?to match a single character.
*
?
If you start your pattern with*in a YAML pipeline, you must wrap the pattern in quotes, like"*-releases".
*
"*-releases"
For branches and tags:A wildcard may appear anywhere in the pattern.
A wildcard may appear anywhere in the pattern.
For paths:In Azure DevOps Server 2022 and higher, including Azure DevOps Services, a wildcard may appear anywhere within a path pattern and you may use*or?.In Azure DevOps Server 2020 and lower, you may include*as the final character, but it doesn't do anything differently from specifying the directory name by itself. You maynotinclude*in the middle of a path filter, and you may not use?.
In Azure DevOps Server 2022 and higher, including Azure DevOps Services, a wildcard may appear anywhere within a path pattern and you may use*or?.
*
?
In Azure DevOps Server 2020 and lower, you may include*as the final character, but it doesn't do anything differently from specifying the directory name by itself. You maynotinclude*in the middle of a path filter, and you may not use?.
*
*
?
trigger:
  branches:
    include:
    - main
    - releases/*
    - feature/*
    exclude:
    - releases/old*
    - feature/*-working
  paths:
    include:
    - docs/*.md
trigger:
  branches:
    include:
    - main
    - releases/*
    - feature/*
    exclude:
    - releases/old*
    - feature/*-working
  paths:
    include:
    - docs/*.md
PR triggers
Pull request (PR) triggers cause a pipeline to run whenever a pull request is opened with one of the specified target branches,
or when updates are made to such a pull request.
YAML
Classic
Branches
You can specify the target branches when validating your pull requests.
For example, to validate pull requests that
targetmainandreleases/*, you can use the followingprtrigger.
main
releases/*
pr
pr:
- main
- releases/*
pr:
- main
- releases/*
This configuration starts a new run the first time a new pull request is created, and after every update made to the pull request.
You can specify the full name of the branch (for example,main) or a wildcard (for example,releases/*).
main
releases/*
Note
You cannot usevariablesin triggers, as variables are evaluated at runtime (after the trigger has fired).
Note
If you usetemplatesto author YAML files, then you can only specify triggers in the main YAML file for the pipeline. You cannot specify triggers in the template files.
GitHub creates a newrefwhen a pull request is created. The ref points to amerge commit, which is the merged code between the source and target branches of the pull request. The PR validation pipeline builds the commit that thisrefpoints to. This means that the YAML file that is used to run the pipeline is also a merge between the source and the target branch. As a result, the changes you make to the YAML file in source branch of the pull request can override the behavior defined by the YAML file in target branch.
If noprtriggers appear in your YAML file, pull request validations are automatically enabled for all
branches, as if you wrote the followingprtrigger. This configuration triggers a build when any
pull request is created, and when commits come into the source branch of any active pull request.
pr
pr
pr:
  branches:
    include:
    - '*'  # must quote since "*" is a YAML reserved character; we want a string
pr:
  branches:
    include:
    - '*'  # must quote since "*" is a YAML reserved character; we want a string
Important
When you specify aprtrigger with a subset of branches, a pipeline is triggered only when updates are pushed to those branches.
pr
For more complex triggers that need to exclude certain branches, you must use the full syntax as shown in the following example. In this example, pull requests are validated that targetmainorreleases/*and the branchreleases/old*is excluded.
main
releases/*
releases/old*
# specific branch
pr:
  branches:
    include:
    - main
    - releases/*
    exclude:
    - releases/old*
# specific branch
pr:
  branches:
    include:
    - main
    - releases/*
    exclude:
    - releases/old*
Paths
You can specify file paths to include or exclude. For example:
# specific path
pr:
  branches:
    include:
    - main
    - releases/*
  paths:
    include:
    - docs
    exclude:
    - docs/README.md
# specific path
pr:
  branches:
    include:
    - main
    - releases/*
  paths:
    include:
    - docs
    exclude:
    - docs/README.md
Tips:
Azure Pipelines posts a neutral status back to GitHub when it decides not to run a validation build because of a path exclusion rule. This provides a clear direction to GitHub indicating that Azure Pipelines has completed its processing. For more information, seePost neutral status to GitHub when a build is skipped.
Wild cards are now supported with path filters.
Paths are always specified relative to the root of the repository.
If you don't set path filters, then the root folder of the repo is implicitly included by default.
If you exclude a path, you cannot also include it unless you qualify it to a deeper folder. For example if you exclude/toolsthen you could include/tools/trigger-runs-on-these
The order of path filters doesn't matter.
Paths in Gitare case-sensitive. Be sure to use the same case as the real folders.
You cannot usevariablesin paths, as variables are evaluated at runtime (after the trigger has fired).
Azure Pipelines posts a neutral status back to GitHub when it decides not to run a validation build because of a path exclusion rule.
Multiple PR updates
You can specify whether more updates to a PR should cancel in-progress validation runs for the same PR. The default istrue.
true
# auto cancel false
pr:
  autoCancel: false
  branches:
    include:
    - main
# auto cancel false
pr:
  autoCancel: false
  branches:
    include:
    - main
Draft PR validation
By default, pull request triggers fire on draft pull requests and pull requests that are ready for review. To disable pull request triggers for draft pull requests, set thedraftsproperty tofalse.
drafts
false
pr:
  autoCancel: boolean # indicates whether additional pushes to a PR should cancel in-progress runs for the same PR. Defaults to true
  branches:
    include: [ string ] # branch names which will trigger a build
    exclude: [ string ] # branch names which will not
  paths:
    include: [ string ] # file paths which must match to trigger a build
    exclude: [ string ] # file paths which will not trigger a build
  drafts: boolean # whether to build draft PRs, defaults to true
pr:
  autoCancel: boolean # indicates whether additional pushes to a PR should cancel in-progress runs for the same PR. Defaults to true
  branches:
    include: [ string ] # branch names which will trigger a build
    exclude: [ string ] # branch names which will not
  paths:
    include: [ string ] # file paths which must match to trigger a build
    exclude: [ string ] # file paths which will not trigger a build
  drafts: boolean # whether to build draft PRs, defaults to true
Opting out of PR validation
You can opt out of pull request validation entirely by specifyingpr: none.
pr: none
# no PR triggers
pr: none
# no PR triggers
pr: none
For more information, seePR triggerin theYAML schema.
Note
If yourprtrigger isn't firing, follow the troubleshooting steps in theFAQ.
pr
Select thePull request validationtrigger and check theEnable pull request validationcheck box to enable builds on pull requests.

You can specify branches to include and exclude.
Select a branch name from the drop-down menu and selectIncludeorExcludeas appropriate.
For included branches, a build will be triggered on each push to a pull request targeting that branch.
If you have an open PR and you push changes to its source branch, multiple pipelines may run:
The pipelines that have a PR trigger on the PR's target branch will run on themerge commit(the merged code between the source and target branches of the pull request), regardless if there exist pushed commits whose messages or descriptions contain[skip ci](or any of its variants).
[skip ci]
The pipelines triggered by changes to the PR's source branch, if there arenopushed commits whose messages or descriptions contain[skip ci](or any of its variants). If at least one pushed commit contains[skip ci], the pipelines will not run.
[skip ci]
[skip ci]
Finally, after you merge the PR, Azure Pipelines will run the CI pipelines triggered by pushes to the target branch, if the merge commit's message or description doesn't contain[skip ci](or any of its variants).
[skip ci]
Protected branches
You can run a validation build with each commit or pull request that targets a branch, and even prevent pull requests from merging until a validation build succeeds.
To configure mandatory validation builds for a GitHub repository, you must be its owner, a collaborator with the Admin role, or a GitHub organization member with the Write role.
First, create a pipeline for the repository and build it at least once so that its status is posted to GitHub, thereby making GitHub aware of the pipeline's name.
First, create a pipeline for the repository and build it at least once so that its status is posted to GitHub, thereby making GitHub aware of the pipeline's name.
Next, follow GitHub's documentation forconfiguring protected branchesin the repository's settings.For the status check, select the name of your pipeline in theStatus checkslist.
Next, follow GitHub's documentation forconfiguring protected branchesin the repository's settings.
For the status check, select the name of your pipeline in theStatus checkslist.

Important
If your pipeline doesn't show up in this list, please ensure the following:
You are usingGitHub app authentication
Your pipeline has run at least once in the last week
Contributions from external sources
If your GitHub repository is open source, you canmake your Azure DevOps project publicso that anyone can view your pipeline's build results, logs, and test results without signing in. When users outside your organization fork your repository and submit pull requests, they can view the status of builds that automatically validate those pull requests.
You should keep in mind the following considerations when using Azure Pipelines in a public project when accepting contributions from external sources.
Access restrictions
Validate contributions from forks
Important security considerations
Be aware of the following access restrictions when you're running pipelines in Azure DevOps public projects:
Secrets:By default, secrets associated with your pipeline arenât made available to pull request validations of forks. SeeValidate contributions from forks.
Cross-project access:All pipelines in an Azure DevOps public project run with an access token restricted to the project. Pipelines in a public project can access resources such as build artifacts or test results only within the project and not in other projects of the Azure DevOps organization.
Azure Artifacts packages:If your pipelines need access to packages from Azure Artifacts, you must explicitly grant permission to theProject Build Serviceaccount to access the package feeds.
Important
These settings affect the security of your pipeline.
When you create a pipeline, itâs automatically triggered for pull requests from forks of your repository. You can change this behavior, carefully considering how it affects security. To enable or disable this behavior:
Go to your Azure DevOps project. SelectPipelines, locate your pipeline, and selectEdit.
Select theTriggerstab. After enabling thePull request trigger, enable or disable theBuild pull requests from forks of this repositorycheck box.
By default with GitHub pipelines, secrets associated with your build pipeline arenât made available to pull request builds of forks. These secrets are enabled by default with GitHub Enterprise Server pipelines. Secrets include:
A security token with access to your GitHub repository.
These items, if your pipeline uses them:Service connectioncredentialsFiles from thesecure files libraryBuildvariablesmarkedsecret
Service connectioncredentials
Files from thesecure files library
Buildvariablesmarkedsecret
To bypass this precaution on GitHub pipelines, enable theMake secrets available to builds of forkscheck box. Be aware of this setting's effect on security.
Note
When you enable fork builds to access secrets, Azure Pipelines by default restricts the access token used for fork builds.
It has more limited access to open resources than a normal access token.
To give fork builds the same permissions as regular builds, enable theMake fork builds have the same permissions as regular buildssetting.
For more information, seeRepository protection - Forks.
You can define centrally how pipelines build PRs from forked GitHub repositories using theLimit building pull requests from forked GitHub repositoriescontrol. It's available at organization and project level. You can choose to:
Disable building pull requests from forked repositories
Securely build pull requests from forked repositories
Customize rules for building pull requests from forked repositories

Starting withSprint 229, to improve the security of your pipelines,Azure Pipelines no longer automatically builds pull requests from forked GitHub repositories. For new projects and organizations, the default value of theLimit building pull requests from forked GitHub repositoriessetting isDisable building pull requests from forked repositories.
When you choose theSecurely build pull requests from forked repositoriesoption, all pipelines, organization or project-wide,cannotmake secrets available to builds of PRs from forked repositories,cannotmake these builds have the same permissions as normal builds, andmustbe triggered by a PR comment. Projects can still decide tonotallow pipelines to build such PRs.
When you choose theCustomizeoption, you can define how to restrict pipeline settings. For example, you can ensure that all pipelines require a comment in order to build a PR from a forked GitHub repo, when the PR belongs to non-team members and non-contributors. But, you can choose to allow them to make secrets available to such builds. Projects can decide tonotallow pipelines to build such PRs, or to build them securely, or have even more restrictive settings than what is specified at the organization level.
The control is off for existing organizations.Starting September 2023, new organizations haveSecurely build pull requests from forked repositoriesturned on by default.
A GitHub user can fork your repository, change it, and create a pull request to propose changes to your repository. This pull request could contain malicious code to run as part of your triggered build. Such code can cause harm in the following ways:
Leak secrets from your pipeline. To mitigate this risk, donât enable theMake secrets available to builds of forkscheck box if your repository is public or untrusted users can submit pull requests that automatically trigger builds. This option is disabled by default.
Leak secrets from your pipeline. To mitigate this risk, donât enable theMake secrets available to builds of forkscheck box if your repository is public or untrusted users can submit pull requests that automatically trigger builds. This option is disabled by default.
Compromise the machine running the agent to steal code or secrets from other pipelines. To mitigate this:Use aMicrosoft-hosted agent poolto build pull requests from forks. Microsoft-hosted agent machines are immediately deleted after they complete a build, so thereâs no lasting impact if they're compromised.If you must use aself-hosted agent, donât store any secrets or perform other builds and releases that use secrets on the same agent, unless your repository is private and you trust pull request creators.
Compromise the machine running the agent to steal code or secrets from other pipelines. To mitigate this:
Use aMicrosoft-hosted agent poolto build pull requests from forks. Microsoft-hosted agent machines are immediately deleted after they complete a build, so thereâs no lasting impact if they're compromised.
Use aMicrosoft-hosted agent poolto build pull requests from forks. Microsoft-hosted agent machines are immediately deleted after they complete a build, so thereâs no lasting impact if they're compromised.
If you must use aself-hosted agent, donât store any secrets or perform other builds and releases that use secrets on the same agent, unless your repository is private and you trust pull request creators.
If you must use aself-hosted agent, donât store any secrets or perform other builds and releases that use secrets on the same agent, unless your repository is private and you trust pull request creators.
Comment triggers
Repository collaborators can comment on a pull request to manually run a pipeline. Here are a few common reasons for why you might want to do this:
You may not want to automatically build pull requests from unknown users until their changes can be reviewed. You want one of your team members to first review their code and then run the pipeline. This is commonly used as a security measure when building contributed code from forked repositories.
You may want to run an optional test suite or one more validation build.
To enable comment triggers, you must follow the following two steps:
Enable pull request triggers for your pipeline, and make sure that you didnât exclude the target branch.
In the Azure Pipelines web portal, edit your pipeline and chooseMore actions,Triggers. Then, underPull request validation, enableRequire a team member's comment before building a pull request.ChooseOn all pull requeststo require a team member's comment before building a pull request. With this workflow, a team member reviews the pull request and triggers the build with a comment once the pull request is deemed safe.ChooseOnly on pull requests from non-team membersto require a team member's comment only when a PR is made by a non-team member. In this workflow, a team member doesn't need a secondary team member's review to trigger a build.
ChooseOn all pull requeststo require a team member's comment before building a pull request. With this workflow, a team member reviews the pull request and triggers the build with a comment once the pull request is deemed safe.
ChooseOnly on pull requests from non-team membersto require a team member's comment only when a PR is made by a non-team member. In this workflow, a team member doesn't need a secondary team member's review to trigger a build.
With these two changes, the pull request validation build wonât be triggered automatically, unlessOnly on pull requests from non-team membersis selected and the PR is made by a team member. Only repository owners and collaborators with 'Write' permission can trigger the build by commenting on the pull request with/AzurePipelines runor/AzurePipelines run <pipeline-name>.
/AzurePipelines run
/AzurePipelines run <pipeline-name>
The following commands can be issued to Azure Pipelines in comments:
/AzurePipelines help
/AzurePipelines help <command-name>
/AzurePipelines run
/AzurePipelines run <pipeline-name>
Note
For brevity, you can comment using/azpinstead of/AzurePipelines.
/azp
/AzurePipelines
Important
Responses to these commands will appear in the pull request discussion only if your pipeline uses theAzure Pipelines GitHub App.
Troubleshoot pull request comment triggers
If you have the necessary repository permissions, but pipelines aren't getting triggered by your comments, make sure that your membership ispublicin the repository's organization, or directly add yourself as a repository collaborator. Pipelines canât see private organization members unless they are direct collaborators or belong to a team that is a direct collaborator. You can change your GitHub organization membership from private to public here (replaceYour-Organizationwith your organization name):https://github.com/orgs/Your-Organization/people.
Your-Organization
https://github.com/orgs/Your-Organization/people
Informational runs
An informational run tells you Azure DevOps failed to retrieve a YAML pipeline's source code. Source code retrieval happens in response to external events, for example, a pushed commit. It also happens in response to internal triggers, for example, to check if there are code changes and start a scheduled run or not. Source code retrieval can fail for multiple reasons, with a frequent one being request throttling by the git repository provider. The existence of an informational run doesn't necessarily mean Azure DevOps was going to run the pipeline.
An informational run looks like in the following screenshot.

You can recognize an informational run by the following attributes:
Status isCanceled
Canceled
Duration is< 1s
< 1s
Run name contains one of the following texts:Could not retrieve file content for {file_path} from repository {repo_name} hosted on {host} using commit {commit_sha}.Could not retrieve content for object {commit_sha} from repository {repo_name} hosted on {host}.Could not retrieve the tree object {tree_sha} from the repository {repo_name} hosted on {host}.Could not find {file_path} from repository {repo_name} hosted on {host} using version {commit_sha}. One of the directories in the path contains too many files or subdirectories.
Could not retrieve file content for {file_path} from repository {repo_name} hosted on {host} using commit {commit_sha}.
Could not retrieve file content for {file_path} from repository {repo_name} hosted on {host} using commit {commit_sha}.
Could not retrieve content for object {commit_sha} from repository {repo_name} hosted on {host}.
Could not retrieve content for object {commit_sha} from repository {repo_name} hosted on {host}.
Could not retrieve the tree object {tree_sha} from the repository {repo_name} hosted on {host}.
Could not retrieve the tree object {tree_sha} from the repository {repo_name} hosted on {host}.
Could not find {file_path} from repository {repo_name} hosted on {host} using version {commit_sha}. One of the directories in the path contains too many files or subdirectories.
Could not find {file_path} from repository {repo_name} hosted on {host} using version {commit_sha}. One of the directories in the path contains too many files or subdirectories.
Run name generally contains the BitBucket / GitHub error that caused the YAML pipeline load to fail
No stages / jobs / steps
Learn more aboutinformational runs.
Checkout
When a pipeline is triggered, Azure Pipelines pulls your source code from the Azure Repos Git repository. You can control various aspects of how your code is checked out.
Note
When you include a checkout step in your pipeline, we run the following command:git -c fetch --force --tags --prune --prune-tags --progress --no-recurse-submodules origin --depth=1.
If this default doesn't meet your needs, you can choose to exclude built-in checkout bycheckout: noneand then use a script task to perform your own checkout.
git -c fetch --force --tags --prune --prune-tags --progress --no-recurse-submodules origin --depth=1
checkout: none
Preferred version of Git
The Windows agent comes with its own copy of Git.
If you prefer to supply your own Git rather than use the included copy, setSystem.PreferGitFromPathtotrue.
TheSystem.PreferGitFromPathsetting is always true on non-Windows agents.
System.PreferGitFromPath
true
System.PreferGitFromPath
Checkout path
YAML
Classic
If you're checking out a single repository, by default, your source code is checked out into a directory calleds. For YAML pipelines, you can change this by specifyingcheckoutwith apath. The specified path is relative to$(Agent.BuildDirectory). For example: if the checkout path value ismycustompathand$(Agent.BuildDirectory)isC:\agent\_work\1, then the source code is checked out intoC:\agent\_work\1\mycustompath.
s
checkout
path
$(Agent.BuildDirectory)
mycustompath
$(Agent.BuildDirectory)
C:\agent\_work\1
C:\agent\_work\1\mycustompath
If you're using multiplecheckoutsteps and checking out multiple repositories, and not explicitly specifying the folder usingpath, each repository is placed in a subfolder ofsnamed after the repository. For example if you check out two repositories namedtoolsandcode, the source code is checked out intoC:\agent\_work\1\s\toolsandC:\agent\_work\1\s\code.
checkout
path
s
tools
code
C:\agent\_work\1\s\tools
C:\agent\_work\1\s\code
Please note that the checkout path value can't be set to go up any directory levels above$(Agent.BuildDirectory), sopath\..\anotherpathwill result in a valid checkout path (i.e.C:\agent\_work\1\anotherpath), but a value like..\invalidpathwill not (i.e.C:\agent\_work\invalidpath).
$(Agent.BuildDirectory)
path\..\anotherpath
C:\agent\_work\1\anotherpath
..\invalidpath
C:\agent\_work\invalidpath
You can configure thepathsetting in theCheckoutstep of your pipeline.
path
steps:
- checkout: self  # self represents the repo where the initial Pipelines YAML file was found
  clean: boolean  # whether to fetch clean each time
  fetchDepth: number  # the depth of commits to ask Git to fetch
  lfs: boolean  # whether to download Git-LFS files
  submodules: true | recursive  # set to 'true' for a single level of submodules or 'recursive' to get submodules of submodules
  path: string  # path to check out source code, relative to the agent's build directory (e.g. \_work\1)
  persistCredentials: boolean  # set to 'true' to leave the OAuth token in the Git config after the initial fetch
steps:
- checkout: self  # self represents the repo where the initial Pipelines YAML file was found
  clean: boolean  # whether to fetch clean each time
  fetchDepth: number  # the depth of commits to ask Git to fetch
  lfs: boolean  # whether to download Git-LFS files
  submodules: true | recursive  # set to 'true' for a single level of submodules or 'recursive' to get submodules of submodules
  path: string  # path to check out source code, relative to the agent's build directory (e.g. \_work\1)
  persistCredentials: boolean  # set to 'true' to leave the OAuth token in the Git config after the initial fetch
The path setting isn't configurable in the classic editor. Your source code is checked out into a directory calleds, which is relative to$(Agent.BuildDirectory). For example: if$(Agent.BuildDirectory)isC:\agent\_work\1, then the source code is checked out intoC:\agent\_work\1\mycustompath.
s
$(Agent.BuildDirectory)
$(Agent.BuildDirectory)
C:\agent\_work\1
C:\agent\_work\1\mycustompath
Submodules
YAML
Classic
You can configure thesubmodulessetting in theCheckoutstep of your pipeline if you want to download files fromsubmodules.
submodules
steps:
- checkout: self  # self represents the repo where the initial Pipelines YAML file was found
  clean: boolean  # whether to fetch clean each time
  fetchDepth: number  # the depth of commits to ask Git to fetch
  lfs: boolean  # whether to download Git-LFS files
  submodules: true | recursive  # set to 'true' for a single level of submodules or 'recursive' to get submodules of submodules
  path: string  # path to check out source code, relative to the agent's build directory (e.g. \_work\1)
  persistCredentials: boolean  # set to 'true' to leave the OAuth token in the Git config after the initial fetch
steps:
- checkout: self  # self represents the repo where the initial Pipelines YAML file was found
  clean: boolean  # whether to fetch clean each time
  fetchDepth: number  # the depth of commits to ask Git to fetch
  lfs: boolean  # whether to download Git-LFS files
  submodules: true | recursive  # set to 'true' for a single level of submodules or 'recursive' to get submodules of submodules
  path: string  # path to check out source code, relative to the agent's build directory (e.g. \_work\1)
  persistCredentials: boolean  # set to 'true' to leave the OAuth token in the Git config after the initial fetch
You can configure theSubmodulessetting from the properties of theGet sourcestask in your pipeline if you want to download files fromsubmodules.
Get sources

The build pipeline will check out your Git submodules as long as they are:
Unauthenticated:A public, unauthenticated repo with no credentials required to clone or fetch.
Unauthenticated:A public, unauthenticated repo with no credentials required to clone or fetch.
Authenticated:Contained in the same project as the Azure Repos Git repo specified above.  The same credentials that are used by the agent to get the sources from the main repository are also used to get the sources for submodules.Added by using a URL relative to the main repository. For exampleThis one would be checked out:git submodule add ../../../FabrikamFiberProject/_git/FabrikamFiber FabrikamFiberIn this example the submodule refers to a repo (FabrikamFiber) in the same Azure DevOps organization, but in a different project (FabrikamFiberProject).  The same credentials that are used by the agent to get the sources from the main repository are also used to get the sources for submodules. This requires that the job access token has access to the repository in the second project. If you restricted the job access token as explained in the section above, then you won't be able to do this. You can allow the job access token to access the repo in the second project by either (a) explicitly granting access to the project build service account in the second project or (b) using collection-scoped access tokens instead of project-scoped tokens for the entire organization. For more information about these options and their security implications, seeAccess repositories, artifacts, and other resources.This one would not be checked out:git submodule add https://fabrikam-fiber@dev.azure.com/fabrikam-fiber/FabrikamFiberProject/_git/FabrikamFiber FabrikamFiber
Authenticated:
Contained in the same project as the Azure Repos Git repo specified above.  The same credentials that are used by the agent to get the sources from the main repository are also used to get the sources for submodules.
Contained in the same project as the Azure Repos Git repo specified above.  The same credentials that are used by the agent to get the sources from the main repository are also used to get the sources for submodules.
Added by using a URL relative to the main repository. For exampleThis one would be checked out:git submodule add ../../../FabrikamFiberProject/_git/FabrikamFiber FabrikamFiberIn this example the submodule refers to a repo (FabrikamFiber) in the same Azure DevOps organization, but in a different project (FabrikamFiberProject).  The same credentials that are used by the agent to get the sources from the main repository are also used to get the sources for submodules. This requires that the job access token has access to the repository in the second project. If you restricted the job access token as explained in the section above, then you won't be able to do this. You can allow the job access token to access the repo in the second project by either (a) explicitly granting access to the project build service account in the second project or (b) using collection-scoped access tokens instead of project-scoped tokens for the entire organization. For more information about these options and their security implications, seeAccess repositories, artifacts, and other resources.This one would not be checked out:git submodule add https://fabrikam-fiber@dev.azure.com/fabrikam-fiber/FabrikamFiberProject/_git/FabrikamFiber FabrikamFiber
Added by using a URL relative to the main repository. For example
This one would be checked out:git submodule add ../../../FabrikamFiberProject/_git/FabrikamFiber FabrikamFiberIn this example the submodule refers to a repo (FabrikamFiber) in the same Azure DevOps organization, but in a different project (FabrikamFiberProject).  The same credentials that are used by the agent to get the sources from the main repository are also used to get the sources for submodules. This requires that the job access token has access to the repository in the second project. If you restricted the job access token as explained in the section above, then you won't be able to do this. You can allow the job access token to access the repo in the second project by either (a) explicitly granting access to the project build service account in the second project or (b) using collection-scoped access tokens instead of project-scoped tokens for the entire organization. For more information about these options and their security implications, seeAccess repositories, artifacts, and other resources.
This one would be checked out:git submodule add ../../../FabrikamFiberProject/_git/FabrikamFiber FabrikamFiber
git submodule add ../../../FabrikamFiberProject/_git/FabrikamFiber FabrikamFiber
In this example the submodule refers to a repo (FabrikamFiber) in the same Azure DevOps organization, but in a different project (FabrikamFiberProject).  The same credentials that are used by the agent to get the sources from the main repository are also used to get the sources for submodules. This requires that the job access token has access to the repository in the second project. If you restricted the job access token as explained in the section above, then you won't be able to do this. You can allow the job access token to access the repo in the second project by either (a) explicitly granting access to the project build service account in the second project or (b) using collection-scoped access tokens instead of project-scoped tokens for the entire organization. For more information about these options and their security implications, seeAccess repositories, artifacts, and other resources.
This one would not be checked out:git submodule add https://fabrikam-fiber@dev.azure.com/fabrikam-fiber/FabrikamFiberProject/_git/FabrikamFiber FabrikamFiber
This one would not be checked out:git submodule add https://fabrikam-fiber@dev.azure.com/fabrikam-fiber/FabrikamFiberProject/_git/FabrikamFiber FabrikamFiber
git submodule add https://fabrikam-fiber@dev.azure.com/fabrikam-fiber/FabrikamFiberProject/_git/FabrikamFiber FabrikamFiber
In some cases you can't use theCheckout submodulesoption.
You might have a scenario where a different set of credentials are needed to access the submodules.
This can happen, for example, if your main repository and submodule repositories aren't stored in the same Azure DevOps organization, or if your job access token doesn't have access to the repository in a different project.
If you can't use theCheckout submodulesoption, then you can instead use a custom script step to fetch submodules.
First, get a personal access token (PAT) and prefix it withpat:.
Next,base64-encodethis prefixed string to create a basic auth token.
Finally, add this script to your pipeline:
pat:
git -c http.https://<url of submodule repository>.extraheader="AUTHORIZATION: Basic <BASE64_ENCODED_STRING>" submodule update --init --recursive
git -c http.https://<url of submodule repository>.extraheader="AUTHORIZATION: Basic <BASE64_ENCODED_STRING>" submodule update --init --recursive
Be sure to replace "<BASE64_ENCODED_STRING>" with your Base64-encoded "pat:token" string.
Use a secret variable in your project or build pipeline to store the basic auth token that you generated.
Use that variable to populate the secret in the above Git command.
Note
Q: Why can't I use a Git credential manager on the agent?A:Storing the submodule credentials in a Git credential manager installed on your private build agent is usually not effective as the credential manager may prompt you to re-enter the credentials whenever the submodule is updated. This isn't desirable during automated builds when user interaction isn't possible.
Sync tags
Important
The sync tags feature is supported in Azure Repos Git with Azure DevOps Server 2022.1 and higher.
The checkout step uses the--tagsoption when fetching the contents of a Git repository. This causes the server to fetch all tags as well as all objects that are pointed to by those tags. This increases the time to run the task in a pipeline, particularly if you have a large repository with a number of tags. Furthermore, the checkout step syncs tags even when you enable the shallow fetch option, thereby possibly defeating its purpose. To reduce the amount of data fetched or pulled from a Git repository, Microsoft has added a new option to check out to control the behavior of syncing tags. This option is available both in classic and YAML pipelines.
--tags
Whether to synchronize tags when checking out a repository can be configured in YAML by setting thefetchTagsproperty, and in the UI by configuring theSync tagssetting.
fetchTags
YAML
Classic
You can configure thefetchTagssetting in theCheckoutstep of your pipeline.
fetchTags
To configure the setting in YAML, set thefetchTagsproperty.
fetchTags
steps:
- checkout: self
  fetchTags: true
steps:
- checkout: self
  fetchTags: true
You can also configure this setting by using theSync tagsoption in the pipeline settings UI.
Edit your YAML pipeline and chooseMore actions,Triggers.
Edit your YAML pipeline and chooseMore actions,Triggers.

ChooseYAML,Get sources.
ChooseYAML,Get sources.
Get sources

Configure theSync tagssetting.
Configure theSync tagssetting.

Note
If you explicitly setfetchTagsin yourcheckoutstep, that setting takes priority over the setting configured in the pipeline settings UI.
fetchTags
checkout
You can configure theSync tagssetting from the properties of theGet sourcestask in your pipeline.
Get sources

For existing pipelines created before the release ofAzure DevOps sprint 209, released in September 2022, the default for syncing tags remains the same as the existing behavior before theSync tagsoptions was added, which istrue.
true
For new pipelines created after Azure DevOps sprint release 209, the default for syncing tags isfalse.
false
Note
If you explicitly setfetchTagsin yourcheckoutstep, that setting takes priority over the setting configured in the pipeline settings UI.
fetchTags
checkout
Shallow fetch
You may want to limit how far back in history to download. Effectively this results ingit fetch --depth=n. If your repository is large, this option might make your build pipeline more efficient. Your repository might be large if it has been in use for a long time and has sizeable history. It also might be large if you added and later deleted large files.
git fetch --depth=n
Note
In some organizations, new pipelines created after theSeptember 2022 Azure DevOps sprint 209 updatehaveShallow fetchenabled by default and configured with a depth of 1. Previously the default wasn't to shallow fetch.
To check your pipeline, view theShallow fetchsetting in the pipeline settings UI as described in the following section.
YAML
Classic
You can configure thefetchDepthsetting in theCheckoutstep of your pipeline.
fetchDepth
steps:
- checkout: self  # self represents the repo where the initial Pipelines YAML file was found
  clean: boolean  # whether to fetch clean each time
  fetchDepth: number  # the depth of commits to ask Git to fetch
  lfs: boolean  # whether to download Git-LFS files
  submodules: true | recursive  # set to 'true' for a single level of submodules or 'recursive' to get submodules of submodules
  path: string  # path to check out source code, relative to the agent's build directory (e.g. \_work\1)
  persistCredentials: boolean  # set to 'true' to leave the OAuth token in the Git config after the initial fetch
steps:
- checkout: self  # self represents the repo where the initial Pipelines YAML file was found
  clean: boolean  # whether to fetch clean each time
  fetchDepth: number  # the depth of commits to ask Git to fetch
  lfs: boolean  # whether to download Git-LFS files
  submodules: true | recursive  # set to 'true' for a single level of submodules or 'recursive' to get submodules of submodules
  path: string  # path to check out source code, relative to the agent's build directory (e.g. \_work\1)
  persistCredentials: boolean  # set to 'true' to leave the OAuth token in the Git config after the initial fetch
You can also configure fetch depth by setting theShallow depthoption in the pipeline settings UI.
Edit your YAML pipeline and chooseMore actions,Triggers.
Edit your YAML pipeline and chooseMore actions,Triggers.

ChooseYAML,Get sources.
ChooseYAML,Get sources.
Get sources

Configure theShallow fetchsetting. UncheckShallow fetchto disable shallow fetch, or check the box and enter aDepthto enable shallow fetch.
Configure theShallow fetchsetting. UncheckShallow fetchto disable shallow fetch, or check the box and enter aDepthto enable shallow fetch.

Note
If you explicitly setfetchDepthin yourcheckoutstep, that setting takes priority over the setting configured in the pipeline settings UI. SettingfetchDepth: 0fetches all history and overrides theShallow fetchsetting.
fetchDepth
checkout
fetchDepth: 0
You can configure theShallow fetchsetting from the properties of theGet sourcestask in your pipeline.
Get sources

In these cases this option can help you conserve network and storage resources. It might also save time. The reason it doesn't always save time is because in some situations the server might need to spend time calculating the commits to download for the depth you specify.
Note
When the pipeline is started, the branch to build is resolved to a commit ID. Then, the agent
fetches the branch and checks out the desired commit. There is a small window between when a branch
is resolved to a commit ID and when the agent performs the checkout. If the branch updates rapidly
and you set a very small value for shallow fetch, the commit may not exist when the agent attempts
to check it out. If that happens, increase the shallow fetch depth setting.
Don't sync sources
You may want to skip fetching new commits. This option can be useful in cases when you want to:
Git init, config, and fetch using your own custom options.
Git init, config, and fetch using your own custom options.
Use a build pipeline to just run automation (for example some scripts) that do not depend on code in version control.
Use a build pipeline to just run automation (for example some scripts) that do not depend on code in version control.
YAML
Classic
You can configure theDon't sync sourcessetting in theCheckoutstep of your pipeline, by settingcheckout: none.
checkout: none
steps:
- checkout: none  # Don't sync sources
steps:
- checkout: none  # Don't sync sources
Select theDon't sync sourcessetting from the properties of theGet sourcestask in your pipeline.
Get sources

Note
When you use this option, the agent also skips running Git commands that clean the repo.
Clean build
You can perform different forms of cleaning the working directory of your self-hosted agent before a build runs.
In general, for faster performance of your self-hosted agents, don't clean the repo. In this case, to get the best performance, make sure you're also building incrementally by disabling anyCleanoption of the task or tool you're using to build.
If you do need to clean the repo (for example to avoid problems caused by residual files from a previous build), your options are below.
Note
Cleaning isn't effective if you're using aMicrosoft-hosted agentbecause you'll get a new agent every time.
YAML
Classic
You can configure thecleansetting in theCheckoutstep of your pipeline.
clean
steps:
- checkout: self  # self represents the repo where the initial Pipelines YAML file was found
  clean: boolean  # whether to fetch clean each time
  fetchDepth: number  # the depth of commits to ask Git to fetch
  lfs: boolean  # whether to download Git-LFS files
  submodules: true | recursive  # set to 'true' for a single level of submodules or 'recursive' to get submodules of submodules
  path: string  # path to check out source code, relative to the agent's build directory (e.g. \_work\1)
  persistCredentials: boolean  # set to 'true' to leave the OAuth token in the Git config after the initial fetch
steps:
- checkout: self  # self represents the repo where the initial Pipelines YAML file was found
  clean: boolean  # whether to fetch clean each time
  fetchDepth: number  # the depth of commits to ask Git to fetch
  lfs: boolean  # whether to download Git-LFS files
  submodules: true | recursive  # set to 'true' for a single level of submodules or 'recursive' to get submodules of submodules
  path: string  # path to check out source code, relative to the agent's build directory (e.g. \_work\1)
  persistCredentials: boolean  # set to 'true' to leave the OAuth token in the Git config after the initial fetch
Whencleanis set totruethe build pipeline performs an undo of any changes in$(Build.SourcesDirectory). More specifically, the following Git commands are executed prior to fetching the source.
clean
true
$(Build.SourcesDirectory)
git clean -ffdx
git reset --hard HEAD
git clean -ffdx
git reset --hard HEAD
For more options, you can configure theworkspacesetting of aJob.
workspace
jobs:
- job: string  # name of the job, A-Z, a-z, 0-9, and underscore
  ...
  workspace:
    clean: outputs | resources | all # what to clean up before the job runs
jobs:
- job: string  # name of the job, A-Z, a-z, 0-9, and underscore
  ...
  workspace:
    clean: outputs | resources | all # what to clean up before the job runs
This gives the following clean options.
outputs: Same operation as the clean setting described in the previous checkout task, plus: Deletes and recreates$(Build.BinariesDirectory). Note that the$(Build.ArtifactStagingDirectory)and$(Common.TestResultsDirectory)are always deleted and recreated prior to every build regardless of any of these settings.
outputs: Same operation as the clean setting described in the previous checkout task, plus: Deletes and recreates$(Build.BinariesDirectory). Note that the$(Build.ArtifactStagingDirectory)and$(Common.TestResultsDirectory)are always deleted and recreated prior to every build regardless of any of these settings.
$(Build.BinariesDirectory)
$(Build.ArtifactStagingDirectory)
$(Common.TestResultsDirectory)
resources: Deletes and recreates$(Build.SourcesDirectory). This results in initializing a new, local Git repository for every build.
resources: Deletes and recreates$(Build.SourcesDirectory). This results in initializing a new, local Git repository for every build.
$(Build.SourcesDirectory)
all: Deletes and recreates$(Agent.BuildDirectory). This results in initializing a new, local Git repository for every build.
all: Deletes and recreates$(Agent.BuildDirectory). This results in initializing a new, local Git repository for every build.
$(Agent.BuildDirectory)
Select theCleansetting from the properties of theGet sourcestask in your pipeline and select one of the following options.
Get sources

Sources: The build pipeline performs an undo of any changes in$(Build.SourcesDirectory). More specifically, the following Git commands are executed prior to fetching the source.git clean -ffdx
git reset --hard HEAD
Sources: The build pipeline performs an undo of any changes in$(Build.SourcesDirectory). More specifically, the following Git commands are executed prior to fetching the source.
$(Build.SourcesDirectory)
git clean -ffdx
git reset --hard HEAD
git clean -ffdx
git reset --hard HEAD
Sources and output directory: Same operation asSourcesoption above, plus: Deletes and recreates$(Build.BinariesDirectory). Note that the$(Build.ArtifactStagingDirectory)and$(Common.TestResultsDirectory)are always deleted and recreated prior to every build regardless of any of these settings.
Sources and output directory: Same operation asSourcesoption above, plus: Deletes and recreates$(Build.BinariesDirectory). Note that the$(Build.ArtifactStagingDirectory)and$(Common.TestResultsDirectory)are always deleted and recreated prior to every build regardless of any of these settings.
$(Build.BinariesDirectory)
$(Build.ArtifactStagingDirectory)
$(Common.TestResultsDirectory)
Sources directory: Deletes and recreates$(Build.SourcesDirectory). This results in initializing a new, local Git repository for every build.
Sources directory: Deletes and recreates$(Build.SourcesDirectory). This results in initializing a new, local Git repository for every build.
$(Build.SourcesDirectory)
All build directories: Deletes and recreates$(Agent.BuildDirectory). This results in initializing a new, local Git repository for every build.
All build directories: Deletes and recreates$(Agent.BuildDirectory). This results in initializing a new, local Git repository for every build.
$(Agent.BuildDirectory)
Label sources
You may want to label your source code files to enable your team to easily identify which version of each file is included in the completed build. You also have the option to specify whether the source code should be labeled for all builds or only for successful builds.
YAML
Classic
You can't currently configure this setting in YAML but you can in the classic editor. When editing a YAML pipeline, you can access the classic editor by choosing eitherTriggersfrom the YAML editor menu.

From the classic editor, chooseYAML, choose theGet sourcestask, and then configure the desired properties there.
Get sources

You can configure theTag sourcessetting from the properties of theGet sourcestask in your pipeline.
Get sources

In theTag formatyou can use user-defined and predefined variables that have a scope of "All." For example:
$(Build.DefinitionName)_$(Build.DefinitionVersion)_$(Build.BuildId)_$(Build.BuildNumber)_$(My.Variable)
$(Build.DefinitionName)_$(Build.DefinitionVersion)_$(Build.BuildId)_$(Build.BuildNumber)_$(My.Variable)
The first four variables are predefined.My.Variablecan be defined by you on thevariables tab.
My.Variable
The pipeline labels your sources with aGit tag.
Some build variables might yield a value that isn't a valid label. For example, variables such as$(Build.RequestedFor)and$(Build.DefinitionName)can contain white space. If the value contains white space, the tag isn't created.
$(Build.RequestedFor)
$(Build.DefinitionName)
After the sources are tagged by your build pipeline, an artifact with the Git refrefs/tags/{tag}is automatically added to the completed build. This gives your team additional traceability and a more user-friendly way to navigate from the build to the code that was built. The tag is considered a build artifact since it is produced by the build. When the build is deleted either manually or through a retention policy, the tag is also deleted.
refs/tags/{tag}
Pre-defined variables
When you build a GitHub repository, most of thepredefined variablesare available to your jobs. However, since Azure Pipelines doesnât recognize the identity of a user making an update in GitHub, the following variables are set to system identity instead of user's identity:
Build.RequestedFor
Build.RequestedFor
Build.RequestedForId
Build.RequestedForId
Build.RequestedForEmail
Build.RequestedForEmail
Status updates
There are two types of statuses that Azure Pipelines posts back to GitHub - basic statuses and GitHub Check Runs. GitHub Checks functionality is only available with GitHub Apps.
Pipeline statuses show up in various places in the GitHub UI.
For PRs, theyâre displayed on the PR conversations tab.
For individual commits, theyâre displayed when hovering over the status mark after the commit time on the repo's commits tab.
PAT or OAuth GitHub connections
For pipelines usingPATorOAuthGitHub connections, statuses are posted back to the commit/PR that triggered the run. TheGitHub status APIis used to post such updates. These statuses contain limited information: pipeline status (failed, success), URL to link back to the build pipeline, and a brief description of the status.
Statuses for PAT or OAuth GitHub connections are only sent at the run level. In other words, you can have a single status updated for an entire run. If you have multiple jobs in a run, you canât post a separate status for each job. However, multiple pipelines can post separate statuses to the same commit.
GitHub Checks
For pipelines set up using the Azure PipelinesGitHub app, the status is posted back in the form of GitHub Checks. GitHub Checks allow for sending detailed information about the pipeline status and test, code coverage, and errors. The GitHub Checks API can be foundhere.
For every pipeline using the GitHub App, Checks are posted back for the overall run and each job in that run.
GitHub allows three options when one or more Check Runs fail for a PR/commit. You can choose to "rerun" the individual Check, rerun all the failing Checks on that PR/commit, or rerun all the Checks, whether they succeeded initially or not.

Clicking on the "Rerun" link next to the Check Run name will result in Azure Pipelines retrying the run that generated the Check Run. The resultant run will have the same run number and will use the same version of the source code, configuration, and YAML file as the initial build. Only those jobs that failed in the initial run and any dependent downstream jobs will be run again. Clicking on the "Rerun all failing checks" link will have the same effect. This is the same behavior as clicking "Retry run" in the Azure Pipelines UI. Clicking on "Rerun all checks" will result in a new run, with a new run number and will pick up changes in the configuration or YAML file.
Limitations
For best performance, we recommend a maximum of 50 pipelines in a single repository. For acceptable performance, we recommend a maximum of 100 pipelines in a single repository. The time required to process a push to a repository increases with the number of pipelines in that repository. Whenever there's push to a repository, Azure Pipelines needs to load all YAML pipelines in that repository to figure out if any of them need to run, and loading each pipeline incurs a performance penalty. In addition to performance issues, having too many pipelines in a single repository can lead to throttling on GitHub's side, as Azure Pipelines may make too many requests in a short amount of time.
For best performance, we recommend a maximum of 50 pipelines in a single repository. For acceptable performance, we recommend a maximum of 100 pipelines in a single repository. The time required to process a push to a repository increases with the number of pipelines in that repository. Whenever there's push to a repository, Azure Pipelines needs to load all YAML pipelines in that repository to figure out if any of them need to run, and loading each pipeline incurs a performance penalty. In addition to performance issues, having too many pipelines in a single repository can lead to throttling on GitHub's side, as Azure Pipelines may make too many requests in a short amount of time.
The use ofextendsandincludetemplates in a pipeline impacts the rate at which Azure Pipelines makes GitHub API requests and can lead to throttling on GitHub's side. Before running a pipeline, Azure Pipelines needs to generate the complete YAML code, so it needs to fetch all template files.
The use ofextendsandincludetemplates in a pipeline impacts the rate at which Azure Pipelines makes GitHub API requests and can lead to throttling on GitHub's side. Before running a pipeline, Azure Pipelines needs to generate the complete YAML code, so it needs to fetch all template files.
Azure Pipelines loads a maximum of 2000 branches from a repository into dropdown lists in the Azure DevOps Portal, for example in theSelect a branchwindow for theDefault branch for manual and scheduled buildssetting, or when choosing a branch when running a pipeline manually.If you don't see your desired branch in the list, type the desired branch name manually in theDefault branch for manual and scheduled buildsfield.If you click the ellipsis and open theSelect a branchdialogue and close it without choosing a valid branch from the drop-down list, you may see aSome settings need attentionmessage and aThis setting is requiredmessage belowDefault Branch for manual and scheduled builds. To work around this message, reopen the pipeline and enter the name
directly in theDefault branch for manual and scheduled buildsfield.
Azure Pipelines loads a maximum of 2000 branches from a repository into dropdown lists in the Azure DevOps Portal, for example in theSelect a branchwindow for theDefault branch for manual and scheduled buildssetting, or when choosing a branch when running a pipeline manually.
If you don't see your desired branch in the list, type the desired branch name manually in theDefault branch for manual and scheduled buildsfield.
If you click the ellipsis and open theSelect a branchdialogue and close it without choosing a valid branch from the drop-down list, you may see aSome settings need attentionmessage and aThis setting is requiredmessage belowDefault Branch for manual and scheduled builds. To work around this message, reopen the pipeline and enter the name
directly in theDefault branch for manual and scheduled buildsfield.
FAQ
Problems related to GitHub integration fall into the following categories:
Connection types:Iâm not sure what connection type Iâm using to connect my pipeline to GitHub.
Failing triggers:My pipeline isnât being triggered when I push an update to the repo.
Failing checkout:My pipeline is being triggered, but it fails in the checkout step.
Wrong version:My pipeline runs, but itâs using an unexpected version of the source/YAML.
Missing status updates:My GitHub PRs are blocked because Azure Pipelines didnât report a status update.
Connection types
Troubleshooting problems with triggers very much depends on the type of GitHub connection you use in your pipeline. There are two ways to determine the type of connection - from GitHub and from Azure Pipelines.
From GitHub: If a repo is set up to use the GitHub app, then the statuses on PRs and commits will be Check Runs. If the repo has Azure Pipelines set up with OAuth or PAT connections, the statuses will be the "old" style of statuses. A quick way to determine if the statuses are Check Runs or simple statuses is to look at the "conversation" tab on a GitHub PR.If the "Details" link redirects to the Checks tab, itâs a Check Run and the repo is using the app.If the "Details" link redirects to the Azure DevOps pipeline, then the status is an "old style" status and the repo isnât using the app.
From GitHub: If a repo is set up to use the GitHub app, then the statuses on PRs and commits will be Check Runs. If the repo has Azure Pipelines set up with OAuth or PAT connections, the statuses will be the "old" style of statuses. A quick way to determine if the statuses are Check Runs or simple statuses is to look at the "conversation" tab on a GitHub PR.
If the "Details" link redirects to the Checks tab, itâs a Check Run and the repo is using the app.
If the "Details" link redirects to the Azure DevOps pipeline, then the status is an "old style" status and the repo isnât using the app.
From Azure Pipelines: You can also determine the type of connection by inspecting the pipeline in Azure Pipelines UI. Open the editor for the pipeline. SelectTriggersto open the classic editor for the pipeline. Then, selectYAMLtab and then theGet sourcesstep. You'll notice a bannerAuthorized using connection:indicating the service connection that was used to integrate the pipeline with GitHub. The name of the service connection is a hyperlink. Select it to navigate to the service connection properties. The properties of the service connection will indicate the type of connection being used:Azure Pipelines appindicates GitHub app connectionoauthindicates OAuth connectionpersonalaccesstokenindicates PAT authentication
From Azure Pipelines: You can also determine the type of connection by inspecting the pipeline in Azure Pipelines UI. Open the editor for the pipeline. SelectTriggersto open the classic editor for the pipeline. Then, selectYAMLtab and then theGet sourcesstep. You'll notice a bannerAuthorized using connection:indicating the service connection that was used to integrate the pipeline with GitHub. The name of the service connection is a hyperlink. Select it to navigate to the service connection properties. The properties of the service connection will indicate the type of connection being used:
Azure Pipelines appindicates GitHub app connection
oauthindicates OAuth connection
personalaccesstokenindicates PAT authentication
Using a GitHub app instead of OAuth or PAT connection is the recommended integration between GitHub and Azure Pipelines. To switch to GitHub app, follow these steps:
Navigatehereand install the app in the GitHub organization of your repository.
During installation, you'll be redirected to Azure DevOps to choose an Azure DevOps organization and project. Choose the organization and project that contain the classic build pipeline you want to use the app for. This choice associates the GitHub App installation with your Azure DevOps organization. If you choose incorrectly, you can visitthis pageto uninstall the GitHub app from your GitHub org and start over.
In the next page that appears, you donât need to proceed creating a new pipeline.
Edit your pipeline by visiting the Pipelines page (e.g., https://dev.azure.com/YOUR_ORG_NAME/YOUR_PROJECT_NAME/_build), selecting your pipeline, and clicking Edit.
If this is a YAML pipeline, select theTriggersmenu to open the classic editor.
Select the "Get sources" step in the pipeline.
On the green bar with text "Authorized using connection", select "Change" and select the GitHub App connection with the same name as the GitHub organization in which you installed the app.
On the toolbar, select "Save and queue" and then "Save and queue". Select the link to the pipeline run that was queued to make sure it succeeds.
Create (or close and reopen) a pull request in your GitHub repository to verify that a build is successfully queued in its "Checks" section.
Depending on the authentication type and ownership of the repository, specific permissions are required.
If you're using the GitHub App, seeGitHub App authentication.
If you're using OAuth, seeOAuth authentication.
If you're using PATs, seePersonal access token (PAT) authentication.
This means that your repository is already associated with a pipeline in a different organization. CI and PR events from this repository won't work as theyâll be delivered to the other organization. Here are the steps you should take to remove the mapping to the other organization before proceeding to create a pipeline.
Open a pull request in your GitHub repository, and make the comment/azp where. This reports back the Azure DevOps organization that the repository is mapped to.
Open a pull request in your GitHub repository, and make the comment/azp where. This reports back the Azure DevOps organization that the repository is mapped to.
/azp where
To change the mapping, uninstall the app from the GitHub organization, and reinstall it. As you reinstall it, make sure to select the correct organization when youâre redirected to Azure DevOps.
To change the mapping, uninstall the app from the GitHub organization, and reinstall it. As you reinstall it, make sure to select the correct organization when youâre redirected to Azure DevOps.
Failing triggers
Follow each of these steps to troubleshoot your failing triggers:
Are your YAML CI or PR triggersoverridden by pipeline settings in the UI? While editing your pipeline, choose...and thenTriggers.Check theOverride the YAML trigger from heresetting for the types of trigger (Continuous integrationorPull request validation) available for your repo.
Are your YAML CI or PR triggersoverridden by pipeline settings in the UI? While editing your pipeline, choose...and thenTriggers.

Check theOverride the YAML trigger from heresetting for the types of trigger (Continuous integrationorPull request validation) available for your repo.

Are you using the GitHub app connection to connect the pipeline to GitHub? SeeConnection typesto determine the type of connection you have. If youâre using a GitHub app connection, follow these steps:Is the mapping set up properly between GitHub and Azure DevOps? Open a pull request in your GitHub repository, and make the comment/azp where. This reports back the Azure DevOps organization that the repository is mapped to.If no organizations are set up to build this repository using the app, go tohttps://github.com/<org_name>/<repo_name>/settings/installationsand complete the configuration of the app.If a different Azure DevOps organization is reported, then someone has already established a pipeline for this repo in a different organization. We currently have the limitation that we can only map a GitHub repo to a single DevOps org. Only the pipelines in the first Azure DevOps org can be automatically triggered. To change the mapping, uninstall the app from the GitHub organization, and reinstall it. As you reinstall it, make sure to select the correct organization when youâre redirected to Azure DevOps.
Are you using the GitHub app connection to connect the pipeline to GitHub? SeeConnection typesto determine the type of connection you have. If youâre using a GitHub app connection, follow these steps:
Is the mapping set up properly between GitHub and Azure DevOps? Open a pull request in your GitHub repository, and make the comment/azp where. This reports back the Azure DevOps organization that the repository is mapped to.If no organizations are set up to build this repository using the app, go tohttps://github.com/<org_name>/<repo_name>/settings/installationsand complete the configuration of the app.If a different Azure DevOps organization is reported, then someone has already established a pipeline for this repo in a different organization. We currently have the limitation that we can only map a GitHub repo to a single DevOps org. Only the pipelines in the first Azure DevOps org can be automatically triggered. To change the mapping, uninstall the app from the GitHub organization, and reinstall it. As you reinstall it, make sure to select the correct organization when youâre redirected to Azure DevOps.
Is the mapping set up properly between GitHub and Azure DevOps? Open a pull request in your GitHub repository, and make the comment/azp where. This reports back the Azure DevOps organization that the repository is mapped to.
/azp where
If no organizations are set up to build this repository using the app, go tohttps://github.com/<org_name>/<repo_name>/settings/installationsand complete the configuration of the app.
If no organizations are set up to build this repository using the app, go tohttps://github.com/<org_name>/<repo_name>/settings/installationsand complete the configuration of the app.
https://github.com/<org_name>/<repo_name>/settings/installations
If a different Azure DevOps organization is reported, then someone has already established a pipeline for this repo in a different organization. We currently have the limitation that we can only map a GitHub repo to a single DevOps org. Only the pipelines in the first Azure DevOps org can be automatically triggered. To change the mapping, uninstall the app from the GitHub organization, and reinstall it. As you reinstall it, make sure to select the correct organization when youâre redirected to Azure DevOps.
If a different Azure DevOps organization is reported, then someone has already established a pipeline for this repo in a different organization. We currently have the limitation that we can only map a GitHub repo to a single DevOps org. Only the pipelines in the first Azure DevOps org can be automatically triggered. To change the mapping, uninstall the app from the GitHub organization, and reinstall it. As you reinstall it, make sure to select the correct organization when youâre redirected to Azure DevOps.
Are you using OAuth or PAT to connect the pipeline to GitHub? SeeConnection typesto determine the type of connection you have. If youâre using a GitHub connection, follow these steps:OAuth and PAT connections rely on webhooks to communicate updates to Azure Pipelines. In GitHub, navigate to the settings for your repository, then to Webhooks. Verify that the webhooks exist. Usually you should see three webhooks - push, pull_request, and issue_comment. If you don't, then you must re-create the service connection and update the pipeline to use the new service connection.Select each of the webhooks in GitHub and verify that the payload that corresponds to the user's commit exists and was sent successfully to Azure DevOps. You may see an error here if the event couldnât be communicated to Azure DevOps.
Are you using OAuth or PAT to connect the pipeline to GitHub? SeeConnection typesto determine the type of connection you have. If youâre using a GitHub connection, follow these steps:
OAuth and PAT connections rely on webhooks to communicate updates to Azure Pipelines. In GitHub, navigate to the settings for your repository, then to Webhooks. Verify that the webhooks exist. Usually you should see three webhooks - push, pull_request, and issue_comment. If you don't, then you must re-create the service connection and update the pipeline to use the new service connection.
OAuth and PAT connections rely on webhooks to communicate updates to Azure Pipelines. In GitHub, navigate to the settings for your repository, then to Webhooks. Verify that the webhooks exist. Usually you should see three webhooks - push, pull_request, and issue_comment. If you don't, then you must re-create the service connection and update the pipeline to use the new service connection.
Select each of the webhooks in GitHub and verify that the payload that corresponds to the user's commit exists and was sent successfully to Azure DevOps. You may see an error here if the event couldnât be communicated to Azure DevOps.
Select each of the webhooks in GitHub and verify that the payload that corresponds to the user's commit exists and was sent successfully to Azure DevOps. You may see an error here if the event couldnât be communicated to Azure DevOps.
The traffic from Azure DevOps could be throttled by GitHub. When Azure Pipelines receives a notification from GitHub, it tries to contact GitHub and fetch more information about the repo and YAML file. If you have a repo with a large number of updates and pull requests, this call may fail due to such throttling. In this case, see if you can reduce the frequency of builds by using batching or stricter path/branch filters.
The traffic from Azure DevOps could be throttled by GitHub. When Azure Pipelines receives a notification from GitHub, it tries to contact GitHub and fetch more information about the repo and YAML file. If you have a repo with a large number of updates and pull requests, this call may fail due to such throttling. In this case, see if you can reduce the frequency of builds by using batching or stricter path/branch filters.
Is your pipeline paused or disabled? Open the editor for the pipeline, and then selectSettingsto check. If your pipeline is paused or disabled, then triggers do not work.
Is your pipeline paused or disabled? Open the editor for the pipeline, and then selectSettingsto check. If your pipeline is paused or disabled, then triggers do not work.
Have you updated the YAML file in the correct branch? If you push an update to a branch, then the YAML file in that same branch governs the CI behavior. If you push an update to a source branch, then the YAML file resulting from merging the source branch with the target branch governs the PR behavior. Make sure that the YAML file in the correct branch has the necessary CI or PR configuration.
Have you updated the YAML file in the correct branch? If you push an update to a branch, then the YAML file in that same branch governs the CI behavior. If you push an update to a source branch, then the YAML file resulting from merging the source branch with the target branch governs the PR behavior. Make sure that the YAML file in the correct branch has the necessary CI or PR configuration.
Have you configured the trigger correctly? When you define a YAML trigger, you can specify both include and exclude clauses for branches, tags, and paths. Ensure that the include clause matches the details of your commit and that the exclude clause doesn't exclude them. Check the syntax for the triggers and make sure that it is accurate.
Have you configured the trigger correctly? When you define a YAML trigger, you can specify both include and exclude clauses for branches, tags, and paths. Ensure that the include clause matches the details of your commit and that the exclude clause doesn't exclude them. Check the syntax for the triggers and make sure that it is accurate.
Have you used variables in defining the trigger or the paths? That is not supported.
Have you used variables in defining the trigger or the paths? That is not supported.
Did you use templates for your YAML file? If so, make sure that your triggers are defined in the main YAML file. Triggers defined inside template files are not supported.
Did you use templates for your YAML file? If so, make sure that your triggers are defined in the main YAML file. Triggers defined inside template files are not supported.
Have you excluded the branches or paths to which you pushed your changes? Test by pushing a change to an included path in an included branch. Note that paths in triggers are case-sensitive. Make sure that you use the same case as those of real folders when specifying the paths in triggers.
Have you excluded the branches or paths to which you pushed your changes? Test by pushing a change to an included path in an included branch. Note that paths in triggers are case-sensitive. Make sure that you use the same case as those of real folders when specifying the paths in triggers.
Did you just push a new branch? If so, the new branch may not start a new run. See the section "Behavior of triggers when new branches are created".
Did you just push a new branch? If so, the new branch may not start a new run. See the section "Behavior of triggers when new branches are created".
First, go through the troubleshooting steps in the previous question, then follow these additional steps:
Do you have merge conflicts in your PR? For a PR that didn't trigger a pipeline, open it and check whether it has a merge conflict. Resolve the merge conflict.
Do you have merge conflicts in your PR? For a PR that didn't trigger a pipeline, open it and check whether it has a merge conflict. Resolve the merge conflict.
Are you experiencing a delay in the processing of push or PR events? You can usually verify a delay by seeing if the issue is specific to a single pipeline or is common to all pipelines or repos in your project. If a push or a PR update to any of the repos exhibits this symptom, we might be experiencing delays in processing the update events. Here are some reasons why a delay may be happening:We are experiencing a service outage on ourstatus page. If the status page shows an issue, then our team must have already started working on it. Check the page frequently for updates on the issue.Your repository contains too many YAML pipelines. For best performance, we recommend a maximum of 50 pipelines in a single repository. For acceptable performance, we recommend a maximum of 100 pipelines in a single repository. The more pipelines there are, the slower the processing of a push to that repository. Whenever there is push to a repository, Azure Pipelines needs to load all YAML pipelines in that repository, to figure out if any of them need to run, and each new pipeline incurs a performance penalty.
Are you experiencing a delay in the processing of push or PR events? You can usually verify a delay by seeing if the issue is specific to a single pipeline or is common to all pipelines or repos in your project. If a push or a PR update to any of the repos exhibits this symptom, we might be experiencing delays in processing the update events. Here are some reasons why a delay may be happening:
We are experiencing a service outage on ourstatus page. If the status page shows an issue, then our team must have already started working on it. Check the page frequently for updates on the issue.
Your repository contains too many YAML pipelines. For best performance, we recommend a maximum of 50 pipelines in a single repository. For acceptable performance, we recommend a maximum of 100 pipelines in a single repository. The more pipelines there are, the slower the processing of a push to that repository. Whenever there is push to a repository, Azure Pipelines needs to load all YAML pipelines in that repository, to figure out if any of them need to run, and each new pipeline incurs a performance penalty.
Users with permissions to contribute code can update the YAML file and include/exclude additional branches. As a result, users can include their own feature or user branch in their YAML file and push that update to a feature or user branch. This may cause the pipeline to be triggered for all updates to that branch. If you want to prevent this behavior, then you can:
Edit the pipeline in the Azure Pipelines UI.
Navigate to theTriggersmenu.
SelectOverride the YAML continuous Integration trigger from here.
Specify the branches to include or exclude for the trigger.
When you follow these steps, any CI triggers specified in the YAML file are ignored.
Failing checkout
remote: Repository not found.
fatal: repository <repo> not found
remote: Repository not found.
fatal: repository <repo> not found
This could be caused by an outage of GitHub. Try to access the repository in GitHub and make sure that youâre able to.
Wrong version
A wrong version of the YAML file is being used in the pipeline. Why is that?
For CI triggers, the YAML file that is in the branch you are pushing is evaluated to see if a CI build should be run.
For PR triggers, the YAML file resulting from merging the source and target branches of the PR is evaluated to see if a PR build should be run.
Missing status updates
This could be a transient error that resulted in Azure DevOps not being able to communicate with GitHub. Retry the check-in GitHub if you use the GitHub app. Or, make a trivial update to the PR to see if the problem can be resolved.
Related articles
Scheduled triggers
Pipeline completion triggers
Feedback
Was this page helpful?
Additional resources