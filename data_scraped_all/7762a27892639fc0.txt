Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Migrate from .NET Application Insights SDKs to Azure Monitor OpenTelemetry
Article
2024-09-18
4 contributors
In this article
This guide provides step-by-step instructions to migrate various .NET applications from using Application Insights software development kits (SDKs) to Azure Monitor OpenTelemetry.
Expect a similar experience with Azure Monitor OpenTelemetry instrumentation as with the Application Insights SDKs. For more information and a feature-by-feature comparison, seerelease state of features.
ASP.NET Core migration to theAzure Monitor OpenTelemetry Distro. (Azure.Monitor.OpenTelemetry.AspNetCoreNuGet package)
Azure.Monitor.OpenTelemetry.AspNetCore
ASP.NET, console, and WorkerService migration to theAzure Monitor OpenTelemetry Exporter. (Azure.Monitor.OpenTelemetry.ExporterNuGet package)
Azure.Monitor.OpenTelemetry.Exporter
If you're getting started with Application Insights and don't need to migrate from the Classic API, seeEnable Azure Monitor OpenTelemetry.
Prerequisites
ASP.NET Core
ASP.NET
Console
WorkerService
An ASP.NET Core web application already instrumented with Application Insights without any customizations
An actively supported version of.NET
An ASP.NET web application already instrumented with Application Insights
An actively supported version of.NET Framework
A Console application already instrumented with Application Insights
An actively supported version of.NET Frameworkor.NET
A WorkerService application already instrumented with Application Insights without any customizations
An actively supported version of.NET
Tip
Our product group is actively seeking feedback on this documentation. Provide feedback to otel@microsoft.com or see theSupportsection.
Remove the Application Insights SDK
Note
Before continuing with these steps, you should confirm that you have a current backup of your application.
ASP.NET Core
ASP.NET
Console
WorkerService
Remove NuGet packagesRemove theMicrosoft.ApplicationInsights.AspNetCorepackage from yourcsproj.dotnet remove package Microsoft.ApplicationInsights.AspNetCore
Remove NuGet packages
Remove theMicrosoft.ApplicationInsights.AspNetCorepackage from yourcsproj.
Microsoft.ApplicationInsights.AspNetCore
csproj
dotnet remove package Microsoft.ApplicationInsights.AspNetCore
dotnet remove package Microsoft.ApplicationInsights.AspNetCore
Remove Initialization Code and customizationsRemove any references to Application Insights types in your codebase.TipAfter removing the Application Insights package, you can re-build your application to get a list of references that need to be removed.Remove Application Insights from yourServiceCollectionby deleting the following line:builder.Services.AddApplicationInsightsTelemetry();Remove theApplicationInsightssection from yourappsettings.json.{
    "ApplicationInsights": {
        "ConnectionString": "<Your Connection String>"
    }
}
Remove Initialization Code and customizations
Remove any references to Application Insights types in your codebase.
Tip
After removing the Application Insights package, you can re-build your application to get a list of references that need to be removed.
Remove Application Insights from yourServiceCollectionby deleting the following line:builder.Services.AddApplicationInsightsTelemetry();
Remove Application Insights from yourServiceCollectionby deleting the following line:
ServiceCollection
builder.Services.AddApplicationInsightsTelemetry();
builder.Services.AddApplicationInsightsTelemetry();
Remove theApplicationInsightssection from yourappsettings.json.{
    "ApplicationInsights": {
        "ConnectionString": "<Your Connection String>"
    }
}
Remove theApplicationInsightssection from yourappsettings.json.
ApplicationInsights
appsettings.json
{
    "ApplicationInsights": {
        "ConnectionString": "<Your Connection String>"
    }
}
{
    "ApplicationInsights": {
        "ConnectionString": "<Your Connection String>"
    }
}
Clean and BuildInspect your bin directory to validate that all references toMicrosoft.ApplicationInsights.*were removed.
Clean and Build
Inspect your bin directory to validate that all references toMicrosoft.ApplicationInsights.*were removed.
Microsoft.ApplicationInsights.*
Test your applicationVerify that your application has no unexpected consequences.
Test your application
Verify that your application has no unexpected consequences.
Remove NuGet packagesRemove theMicrosoft.AspNet.TelemetryCorrelationpackage and anyMicrosoft.ApplicationInsights.*packages from yourcsprojandpackages.config.
Remove NuGet packages
Remove theMicrosoft.AspNet.TelemetryCorrelationpackage and anyMicrosoft.ApplicationInsights.*packages from yourcsprojandpackages.config.
Microsoft.AspNet.TelemetryCorrelation
Microsoft.ApplicationInsights.*
csproj
packages.config
Delete theApplicationInsights.configfile
Delete theApplicationInsights.configfile
ApplicationInsights.config
Delete section from your application'sWeb.configfileTwoHttpModuleswere automatically added to your web.config when you first added ApplicationInsights to your project.
Any references to theTelemetryCorrelationHttpModuleand theApplicationInsightsWebTrackingshould be removed.
If you added Application Insights to yourInternet Information Server (IIS) Modules, it should also be removed.<configuration>
  <system.web>
    <httpModules>
      <add name="TelemetryCorrelationHttpModule" type="Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation" />
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" />
    </httpModules>
  </system.web>
  <system.webServer>
    <modules>
      <remove name="TelemetryCorrelationHttpModule" />
      <add name="TelemetryCorrelationHttpModule" type="Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation" preCondition="managedHandler" />
      <remove name="ApplicationInsightsWebTracking" />
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" preCondition="managedHandler" />
    </modules>
  </system.webServer>
</configuration>Also review anyassembly version redirectionsadded to your web.config.
Delete section from your application'sWeb.configfile
Web.config
TwoHttpModuleswere automatically added to your web.config when you first added ApplicationInsights to your project.
Any references to theTelemetryCorrelationHttpModuleand theApplicationInsightsWebTrackingshould be removed.
If you added Application Insights to yourInternet Information Server (IIS) Modules, it should also be removed.<configuration>
  <system.web>
    <httpModules>
      <add name="TelemetryCorrelationHttpModule" type="Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation" />
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" />
    </httpModules>
  </system.web>
  <system.webServer>
    <modules>
      <remove name="TelemetryCorrelationHttpModule" />
      <add name="TelemetryCorrelationHttpModule" type="Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation" preCondition="managedHandler" />
      <remove name="ApplicationInsightsWebTracking" />
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" preCondition="managedHandler" />
    </modules>
  </system.webServer>
</configuration>
TwoHttpModuleswere automatically added to your web.config when you first added ApplicationInsights to your project.
Any references to theTelemetryCorrelationHttpModuleand theApplicationInsightsWebTrackingshould be removed.
If you added Application Insights to yourInternet Information Server (IIS) Modules, it should also be removed.
TelemetryCorrelationHttpModule
ApplicationInsightsWebTracking
<configuration>
  <system.web>
    <httpModules>
      <add name="TelemetryCorrelationHttpModule" type="Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation" />
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" />
    </httpModules>
  </system.web>
  <system.webServer>
    <modules>
      <remove name="TelemetryCorrelationHttpModule" />
      <add name="TelemetryCorrelationHttpModule" type="Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation" preCondition="managedHandler" />
      <remove name="ApplicationInsightsWebTracking" />
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" preCondition="managedHandler" />
    </modules>
  </system.webServer>
</configuration>
<configuration>
  <system.web>
    <httpModules>
      <add name="TelemetryCorrelationHttpModule" type="Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation" />
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" />
    </httpModules>
  </system.web>
  <system.webServer>
    <modules>
      <remove name="TelemetryCorrelationHttpModule" />
      <add name="TelemetryCorrelationHttpModule" type="Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation" preCondition="managedHandler" />
      <remove name="ApplicationInsightsWebTracking" />
      <add name="ApplicationInsightsWebTracking" type="Microsoft.ApplicationInsights.Web.ApplicationInsightsHttpModule, Microsoft.AI.Web" preCondition="managedHandler" />
    </modules>
  </system.webServer>
</configuration>
Also review anyassembly version redirectionsadded to your web.config.
Also review anyassembly version redirectionsadded to your web.config.
Remove Initialization Code and customizationsRemove any references to Application Insights types in your codebase.TipAfter removing the Application Insights package, you can re-build your application to get a list of references that need to be removed.Remove references toTelemetryConfigurationorTelemetryClient. It's a part of your application startup to initialize the Application Insights SDK.The following scenarios are optional and apply to advanced users.If you have any more references to theTelemetryClient, which are used tomanually record telemetry, they should be removed.If you added anycustom filtering or enrichmentin the form of a customTelemetryProcessororTelemetryInitializer, they should be removed. You can find them referenced in your configuration.If your project has aFilterConfig.csin theApp_Startdirectory, check for any custom exception handlers that reference Application Insights and remove.
Remove Initialization Code and customizations
Remove any references to Application Insights types in your codebase.
Tip
After removing the Application Insights package, you can re-build your application to get a list of references that need to be removed.
Remove references toTelemetryConfigurationorTelemetryClient. It's a part of your application startup to initialize the Application Insights SDK.
TelemetryConfiguration
TelemetryClient
The following scenarios are optional and apply to advanced users.
If you have any more references to theTelemetryClient, which are used tomanually record telemetry, they should be removed.
TelemetryClient
If you added anycustom filtering or enrichmentin the form of a customTelemetryProcessororTelemetryInitializer, they should be removed. You can find them referenced in your configuration.
TelemetryProcessor
TelemetryInitializer
If your project has aFilterConfig.csin theApp_Startdirectory, check for any custom exception handlers that reference Application Insights and remove.
FilterConfig.cs
App_Start
Remove JavaScript SnippetIf you added the JavaScript SDK to collect client-side telemetry, it can also be removed although it continues to work without the .NET SDK.
For full code samples of what to remove, review theonboarding guide for the JavaScript SDK.
Remove JavaScript Snippet
If you added the JavaScript SDK to collect client-side telemetry, it can also be removed although it continues to work without the .NET SDK.
For full code samples of what to remove, review theonboarding guide for the JavaScript SDK.
Remove any Visual Studio ArtifactsIf you used Visual Studio to onboard to Application Insights, you could have more files left over in your project.ConnectedService.jsonmight have a reference to your Application Insights resource.[Your project's name].csprojmight have a reference to your Application Insights resource:<ApplicationInsightsResourceId>/subscriptions/aaaa0a0a-bb1b-cc2c-dd3d-eeeeee4e4e4e/resourcegroups/Default-ApplicationInsights-EastUS/providers/microsoft.insights/components/WebApplication4</ApplicationInsightsResourceId>
Remove any Visual Studio Artifacts
If you used Visual Studio to onboard to Application Insights, you could have more files left over in your project.
ConnectedService.jsonmight have a reference to your Application Insights resource.
ConnectedService.jsonmight have a reference to your Application Insights resource.
ConnectedService.json
[Your project's name].csprojmight have a reference to your Application Insights resource:<ApplicationInsightsResourceId>/subscriptions/aaaa0a0a-bb1b-cc2c-dd3d-eeeeee4e4e4e/resourcegroups/Default-ApplicationInsights-EastUS/providers/microsoft.insights/components/WebApplication4</ApplicationInsightsResourceId>
[Your project's name].csprojmight have a reference to your Application Insights resource:
[Your project's name].csproj
<ApplicationInsightsResourceId>/subscriptions/aaaa0a0a-bb1b-cc2c-dd3d-eeeeee4e4e4e/resourcegroups/Default-ApplicationInsights-EastUS/providers/microsoft.insights/components/WebApplication4</ApplicationInsightsResourceId>
<ApplicationInsightsResourceId>/subscriptions/aaaa0a0a-bb1b-cc2c-dd3d-eeeeee4e4e4e/resourcegroups/Default-ApplicationInsights-EastUS/providers/microsoft.insights/components/WebApplication4</ApplicationInsightsResourceId>
Clean and BuildInspect your bin directory to validate that all references toMicrosoft.ApplicationInsights.were removed.
Clean and Build
Inspect your bin directory to validate that all references toMicrosoft.ApplicationInsights.were removed.
Microsoft.ApplicationInsights.
Test your applicationVerify that your application has no unexpected consequences.
Test your application
Verify that your application has no unexpected consequences.
Remove NuGet packagesRemove anyMicrosoft.ApplicationInsights.*packages from yourcsprojandpackages.config.dotnet remove package Microsoft.ApplicationInsightsTipIf you've usedMicrosoft.ApplicationInsights.WorkerService, refer to the WorkerService tabs.
Remove NuGet packages
Remove anyMicrosoft.ApplicationInsights.*packages from yourcsprojandpackages.config.
Microsoft.ApplicationInsights.*
csproj
packages.config
dotnet remove package Microsoft.ApplicationInsights
dotnet remove package Microsoft.ApplicationInsights
Tip
If you've usedMicrosoft.ApplicationInsights.WorkerService, refer to the WorkerService tabs.
Remove Initialization Code and customizationsRemove any references to Application Insights types in your codebase.TipAfter removing the Application Insights package, you can re-build your application to get a list of references that need to be removed.Remove references toTelemetryConfigurationorTelemetryClient. It should be part of your application startup to initialize the Application Insights SDK.var config = TelemetryConfiguration.CreateDefault();
var client = new TelemetryClient(config);TipIf you've usedAddApplicationInsightsTelemetryWorkerService()to add Application Insights to yourServiceCollection, refer to the WorkerService tabs.
Remove Initialization Code and customizations
Remove any references to Application Insights types in your codebase.
Tip
After removing the Application Insights package, you can re-build your application to get a list of references that need to be removed.
Remove references toTelemetryConfigurationorTelemetryClient. It should be part of your application startup to initialize the Application Insights SDK.var config = TelemetryConfiguration.CreateDefault();
var client = new TelemetryClient(config);
Remove references toTelemetryConfigurationorTelemetryClient. It should be part of your application startup to initialize the Application Insights SDK.
TelemetryConfiguration
TelemetryClient
var config = TelemetryConfiguration.CreateDefault();
var client = new TelemetryClient(config);
var config = TelemetryConfiguration.CreateDefault();
var client = new TelemetryClient(config);
Tip
If you've usedAddApplicationInsightsTelemetryWorkerService()to add Application Insights to yourServiceCollection, refer to the WorkerService tabs.
AddApplicationInsightsTelemetryWorkerService()
ServiceCollection
Clean and BuildInspect your bin directory to validate that all references toMicrosoft.ApplicationInsights.were removed.
Clean and Build
Inspect your bin directory to validate that all references toMicrosoft.ApplicationInsights.were removed.
Microsoft.ApplicationInsights.
Test your applicationVerify that your application has no unexpected consequences.
Test your application
Verify that your application has no unexpected consequences.
Remove NuGet packagesRemove theMicrosoft.ApplicationInsights.WorkerServicepackage from yourcsproj.dotnet remove package Microsoft.ApplicationInsights.AspNetCore
Remove NuGet packages
Remove theMicrosoft.ApplicationInsights.WorkerServicepackage from yourcsproj.
Microsoft.ApplicationInsights.WorkerService
csproj
dotnet remove package Microsoft.ApplicationInsights.AspNetCore
dotnet remove package Microsoft.ApplicationInsights.AspNetCore
Remove Initialization Code and customizationsRemove any references to Application Insights types in your codebase.TipAfter removing the Application Insights package, you can re-build your application to get a list of references that need to be removed.Remove Application Insights from yourServiceCollectionby deleting the following line:builder.Services.AddApplicationInsightsTelemetryWorkerService();Remove theApplicationInsightssection from yourappsettings.json.{
    "ApplicationInsights": {
        "ConnectionString": "<Your Connection String>"
    }
}
Remove Initialization Code and customizations
Remove any references to Application Insights types in your codebase.
Tip
After removing the Application Insights package, you can re-build your application to get a list of references that need to be removed.
Remove Application Insights from yourServiceCollectionby deleting the following line:builder.Services.AddApplicationInsightsTelemetryWorkerService();
Remove Application Insights from yourServiceCollectionby deleting the following line:
ServiceCollection
builder.Services.AddApplicationInsightsTelemetryWorkerService();
builder.Services.AddApplicationInsightsTelemetryWorkerService();
Remove theApplicationInsightssection from yourappsettings.json.{
    "ApplicationInsights": {
        "ConnectionString": "<Your Connection String>"
    }
}
Remove theApplicationInsightssection from yourappsettings.json.
ApplicationInsights
appsettings.json
{
    "ApplicationInsights": {
        "ConnectionString": "<Your Connection String>"
    }
}
{
    "ApplicationInsights": {
        "ConnectionString": "<Your Connection String>"
    }
}
Clean and BuildInspect your bin directory to validate that all references toMicrosoft.ApplicationInsights.*were removed.
Clean and Build
Inspect your bin directory to validate that all references toMicrosoft.ApplicationInsights.*were removed.
Microsoft.ApplicationInsights.*
Test your applicationVerify that your application has no unexpected consequences.
Test your application
Verify that your application has no unexpected consequences.
Tip
Our product group is actively seeking feedback on this documentation. Provide feedback to otel@microsoft.com or see theSupportsection.
Enable OpenTelemetry
We recommended creating a developmentresourceand using itsconnection stringwhen following these instructions.

Plan to update the connection string to send telemetry to the original resource after confirming migration is successful.
ASP.NET Core
ASP.NET
Console
WorkerService
Install the Azure Monitor DistroOur Azure Monitor Distro enables automatic telemetry by including OpenTelemetry instrumentation libraries for collecting traces, metrics, logs, and exceptions, and allows collecting custom telemetry.Installing the Azure Monitor Distro brings theOpenTelemetry SDKas a dependency.dotnet add package Azure.Monitor.OpenTelemetry.AspNetCore
Install the Azure Monitor Distro
Our Azure Monitor Distro enables automatic telemetry by including OpenTelemetry instrumentation libraries for collecting traces, metrics, logs, and exceptions, and allows collecting custom telemetry.
Installing the Azure Monitor Distro brings theOpenTelemetry SDKas a dependency.
dotnet add package Azure.Monitor.OpenTelemetry.AspNetCore
dotnet add package Azure.Monitor.OpenTelemetry.AspNetCore
Add and configure both OpenTelemetry and Azure MonitorThe OpenTelemery SDK must be configured at application startup as part of yourServiceCollection, typically in theProgram.cs.OpenTelemetry has a concept of three signals; Traces, Metrics, and Logs.
The Azure Monitor Distro configures each of these signals.
Add and configure both OpenTelemetry and Azure Monitor
The OpenTelemery SDK must be configured at application startup as part of yourServiceCollection, typically in theProgram.cs.
ServiceCollection
Program.cs
OpenTelemetry has a concept of three signals; Traces, Metrics, and Logs.
The Azure Monitor Distro configures each of these signals.
The following code sample demonstrates the basics.
using Azure.Monitor.OpenTelemetry.AspNetCore;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);

        // Call AddOpenTelemetry() to add OpenTelemetry to your ServiceCollection.
        // Call UseAzureMonitor() to fully configure OpenTelemetry.
        builder.Services.AddOpenTelemetry().UseAzureMonitor();

        var app = builder.Build();
        app.MapGet("/", () => "Hello World!");
        app.Run();
    }
}
using Azure.Monitor.OpenTelemetry.AspNetCore;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);

        // Call AddOpenTelemetry() to add OpenTelemetry to your ServiceCollection.
        // Call UseAzureMonitor() to fully configure OpenTelemetry.
        builder.Services.AddOpenTelemetry().UseAzureMonitor();

        var app = builder.Build();
        app.MapGet("/", () => "Hello World!");
        app.Run();
    }
}
We recommend setting your Connection String in an environment variable:
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
More options to configure the Connection String are detailed here:Configure the Application Insights Connection String.
Install the OpenTelemetry SDK via Azure MonitorInstalling the Azure Monitor Exporter brings theOpenTelemetry SDKas a dependency.dotnet add package Azure.Monitor.OpenTelemetry.Exporter
Install the OpenTelemetry SDK via Azure Monitor
Installing the Azure Monitor Exporter brings theOpenTelemetry SDKas a dependency.
dotnet add package Azure.Monitor.OpenTelemetry.Exporter
dotnet add package Azure.Monitor.OpenTelemetry.Exporter
Configure OpenTelemetry as part of your application startupThe OpenTelemery SDK must be configured at application startup, typically in theGlobal.asax.cs.
OpenTelemetry has a concept of three signals; Traces, Metrics, and Logs.
Each of these signals needs to be configured as part of your application startup.TracerProvider,MeterProvider, andILoggerFactoryshould be created once for your application and disposed when your application shuts down.
Configure OpenTelemetry as part of your application startup
The OpenTelemery SDK must be configured at application startup, typically in theGlobal.asax.cs.
OpenTelemetry has a concept of three signals; Traces, Metrics, and Logs.
Each of these signals needs to be configured as part of your application startup.TracerProvider,MeterProvider, andILoggerFactoryshould be created once for your application and disposed when your application shuts down.
Global.asax.cs
TracerProvider
MeterProvider
ILoggerFactory
The following code sample shows a simple example meant only to show the basics.
No telemetry is collected at this point.
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

public class Global : System.Web.HttpApplication
{
    private TracerProvider? tracerProvider;
    private MeterProvider? meterProvider;
    // The LoggerFactory needs to be accessible from the rest of your application.
    internal static ILoggerFactory loggerFactory;

    protected void Application_Start()
    {
        this.tracerProvider = Sdk.CreateTracerProviderBuilder()
            .Build();

        this.meterProvider = Sdk.CreateMeterProviderBuilder()
            .Build();

        loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry();
        });
    }

    protected void Application_End()
    {
        this.tracerProvider?.Dispose();
        this.meterProvider?.Dispose();
        loggerFactory?.Dispose();
    }
}
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

public class Global : System.Web.HttpApplication
{
    private TracerProvider? tracerProvider;
    private MeterProvider? meterProvider;
    // The LoggerFactory needs to be accessible from the rest of your application.
    internal static ILoggerFactory loggerFactory;

    protected void Application_Start()
    {
        this.tracerProvider = Sdk.CreateTracerProviderBuilder()
            .Build();

        this.meterProvider = Sdk.CreateMeterProviderBuilder()
            .Build();

        loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry();
        });
    }

    protected void Application_End()
    {
        this.tracerProvider?.Dispose();
        this.meterProvider?.Dispose();
        loggerFactory?.Dispose();
    }
}
Install the OpenTelemetry SDK via Azure MonitorInstalling theAzure Monitor Exporterbrings theOpenTelemetry SDKas a dependency.dotnet add package Azure.Monitor.OpenTelemetry.Exporter
Install the OpenTelemetry SDK via Azure Monitor
Installing theAzure Monitor Exporterbrings theOpenTelemetry SDKas a dependency.
dotnet add package Azure.Monitor.OpenTelemetry.Exporter
dotnet add package Azure.Monitor.OpenTelemetry.Exporter
Configure OpenTelemetry as part of your application startupThe OpenTelemery SDK must be configured at application startup, typically in theProgram.cs.
OpenTelemetry has a concept of three signals; Traces, Metrics, and Logs.
Each of these signals needs to be configured as part of your application startup.TracerProvider,MeterProvider, andILoggerFactoryshould be created once for your application and disposed when your application shuts down.
Configure OpenTelemetry as part of your application startup
The OpenTelemery SDK must be configured at application startup, typically in theProgram.cs.
OpenTelemetry has a concept of three signals; Traces, Metrics, and Logs.
Each of these signals needs to be configured as part of your application startup.TracerProvider,MeterProvider, andILoggerFactoryshould be created once for your application and disposed when your application shuts down.
Program.cs
TracerProvider
MeterProvider
ILoggerFactory
The following code sample shows a simple example meant only to show the basics.
No telemetry is collected at this point.
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

internal class Program
{
    static void Main(string[] args)
    {
        TracerProvider tracerProvider = Sdk.CreateTracerProviderBuilder()
            .Build();

        MeterProvider meterProvider = Sdk.CreateMeterProviderBuilder()
            .Build();

        ILoggerFactory loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry();
        });

        Console.WriteLine("Hello, World!");

        // Dispose tracer provider before the application ends.
        // It will flush the remaining spans and shutdown the tracing pipeline.
        tracerProvider.Dispose();

        // Dispose meter provider before the application ends.
        // It will flush the remaining metrics and shutdown the metrics pipeline.
        meterProvider.Dispose();

        // Dispose logger factory before the application ends.
        // It will flush the remaining logs and shutdown the logging pipeline.
        loggerFactory.Dispose();
    }
}
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

internal class Program
{
    static void Main(string[] args)
    {
        TracerProvider tracerProvider = Sdk.CreateTracerProviderBuilder()
            .Build();

        MeterProvider meterProvider = Sdk.CreateMeterProviderBuilder()
            .Build();

        ILoggerFactory loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry();
        });

        Console.WriteLine("Hello, World!");

        // Dispose tracer provider before the application ends.
        // It will flush the remaining spans and shutdown the tracing pipeline.
        tracerProvider.Dispose();

        // Dispose meter provider before the application ends.
        // It will flush the remaining metrics and shutdown the metrics pipeline.
        meterProvider.Dispose();

        // Dispose logger factory before the application ends.
        // It will flush the remaining logs and shutdown the logging pipeline.
        loggerFactory.Dispose();
    }
}
Install the OpenTelemetry SDK via Azure MonitorInstalling theAzure Monitor Exporterbrings theOpenTelemetry SDKas a dependency.dotnet add package Azure.Monitor.OpenTelemetry.ExporterYou must also install theOpenTelemetry Extensions Hostingpackage.dotnet add package OpenTelemetry.Extensions.Hosting
Install the OpenTelemetry SDK via Azure Monitor
Installing theAzure Monitor Exporterbrings theOpenTelemetry SDKas a dependency.
dotnet add package Azure.Monitor.OpenTelemetry.Exporter
dotnet add package Azure.Monitor.OpenTelemetry.Exporter
You must also install theOpenTelemetry Extensions Hostingpackage.
dotnet add package OpenTelemetry.Extensions.Hosting
dotnet add package OpenTelemetry.Extensions.Hosting
Configure OpenTelemetry as part of your application startupThe OpenTelemery SDK must be configured at application startup, typically in theProgram.cs.
OpenTelemetry has a concept of three signals; Traces, Metrics, and Logs.
Each of these signals needs to be configured as part of your application startup.TracerProvider,MeterProvider, andILoggerFactoryshould be created once for your application and disposed when your application shuts down.
Configure OpenTelemetry as part of your application startup
The OpenTelemery SDK must be configured at application startup, typically in theProgram.cs.
OpenTelemetry has a concept of three signals; Traces, Metrics, and Logs.
Each of these signals needs to be configured as part of your application startup.TracerProvider,MeterProvider, andILoggerFactoryshould be created once for your application and disposed when your application shuts down.
Program.cs
TracerProvider
MeterProvider
ILoggerFactory
The following code sample shows a simple example meant only to show the basics.
No telemetry is collected at this point.
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = Host.CreateApplicationBuilder(args);
        builder.Services.AddHostedService<Worker>();

        builder.Services.AddOpenTelemetry()
            .WithTracing()
            .WithMetrics();

        builder.Logging.AddOpenTelemetry();

        var host = builder.Build();
        host.Run();
    }
}
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = Host.CreateApplicationBuilder(args);
        builder.Services.AddHostedService<Worker>();

        builder.Services.AddOpenTelemetry()
            .WithTracing()
            .WithMetrics();

        builder.Logging.AddOpenTelemetry();

        var host = builder.Build();
        host.Run();
    }
}
Tip
Our product group is actively seeking feedback on this documentation. Provide feedback to otel@microsoft.com or see theSupportsection.
Install and configure instrumentation libraries
ASP.NET Core
ASP.NET
Console
WorkerService
Instrumentation librariescan be added to your project to auto collect telemetry about specific components or dependencies.
The following libraries are included in the Distro.
HTTP
ASP.NET Core
SQL
The Azure Monitor Distro includes .NET OpenTelemetry instrumentation forASP.NET Core,HttpClient, andSQLClient.
You can customize these included instrumentations or manually add extra instrumentation on your own using the OpenTelemetry API.
Here are some examples of how to customize the instrumentation:
builder.Services.AddOpenTelemetry().UseAzureMonitor();
builder.Services.Configure<AspNetCoreTraceInstrumentationOptions>(options =>
{
    options.RecordException = true;
    options.Filter = (httpContext) =>
    {
        // only collect telemetry about HTTP GET requests
        return HttpMethods.IsGet(httpContext.Request.Method);
    };
});
builder.Services.AddOpenTelemetry().UseAzureMonitor();
builder.Services.Configure<AspNetCoreTraceInstrumentationOptions>(options =>
{
    options.RecordException = true;
    options.Filter = (httpContext) =>
    {
        // only collect telemetry about HTTP GET requests
        return HttpMethods.IsGet(httpContext.Request.Method);
    };
});
builder.Services.AddOpenTelemetry().UseAzureMonitor();
builder.Services.Configure<HttpClientTraceInstrumentationOptions>(options =>
{
    options.RecordException = true;
    options.FilterHttpRequestMessage = (httpRequestMessage) =>
    {
        // only collect telemetry about HTTP GET requests
        return HttpMethods.IsGet(httpRequestMessage.Method.Method);
    };
});
builder.Services.AddOpenTelemetry().UseAzureMonitor();
builder.Services.Configure<HttpClientTraceInstrumentationOptions>(options =>
{
    options.RecordException = true;
    options.FilterHttpRequestMessage = (httpRequestMessage) =>
    {
        // only collect telemetry about HTTP GET requests
        return HttpMethods.IsGet(httpRequestMessage.Method.Method);
    };
});
We provide theSQLClientinstrumentation within our package while it's still in beta. When it reaches a stable release, we'll include it as a standard package reference. Until then, to customize the SQLClient instrumentation, add theOpenTelemetry.Instrumentation.SqlClientpackage reference to your project and use its public API.
OpenTelemetry.Instrumentation.SqlClient
dotnet add package --prerelease OpenTelemetry.Instrumentation.SqlClient
dotnet add package --prerelease OpenTelemetry.Instrumentation.SqlClient
builder.Services.AddOpenTelemetry().UseAzureMonitor().WithTracing(builder =>
{
    builder.AddSqlClientInstrumentation(options =>
    {
        options.SetDbStatementForStoredProcedure = false;
    });
});
builder.Services.AddOpenTelemetry().UseAzureMonitor().WithTracing(builder =>
{
    builder.AddSqlClientInstrumentation(options =>
    {
        options.SetDbStatementForStoredProcedure = false;
    });
});
Instrumentation librariescan be added to your project to auto collect telemetry about specific components or dependencies. We recommend the following libraries:
OpenTelemetry.Instrumentation.AspNetcan be used to collect telemetry for incoming requests. Azure Monitor maps it toRequest Telemetry.dotnet add package OpenTelemetry.Instrumentation.AspNetIt requires adding an extra HttpModule to yourWeb.config:<system.webServer>
  <modules>
      <add
          name="TelemetryHttpModule"
          type="OpenTelemetry.Instrumentation.AspNet.TelemetryHttpModule,
              OpenTelemetry.Instrumentation.AspNet.TelemetryHttpModule"
          preCondition="integratedMode,managedHandler" />
  </modules>
</system.webServer>A complete getting started guide is available here:OpenTelemetry.Instrumentation.AspNet Readme
OpenTelemetry.Instrumentation.AspNetcan be used to collect telemetry for incoming requests. Azure Monitor maps it toRequest Telemetry.
dotnet add package OpenTelemetry.Instrumentation.AspNet
dotnet add package OpenTelemetry.Instrumentation.AspNet
It requires adding an extra HttpModule to yourWeb.config:
Web.config
<system.webServer>
  <modules>
      <add
          name="TelemetryHttpModule"
          type="OpenTelemetry.Instrumentation.AspNet.TelemetryHttpModule,
              OpenTelemetry.Instrumentation.AspNet.TelemetryHttpModule"
          preCondition="integratedMode,managedHandler" />
  </modules>
</system.webServer>
<system.webServer>
  <modules>
      <add
          name="TelemetryHttpModule"
          type="OpenTelemetry.Instrumentation.AspNet.TelemetryHttpModule,
              OpenTelemetry.Instrumentation.AspNet.TelemetryHttpModule"
          preCondition="integratedMode,managedHandler" />
  </modules>
</system.webServer>
A complete getting started guide is available here:OpenTelemetry.Instrumentation.AspNet Readme
OpenTelemetry.Instrumentation.Httpcan be used to collect telemetry for outbound http dependencies. Azure Monitor maps it toDependency Telemetry.dotnet add package OpenTelemetry.Instrumentation.HttpA complete getting started guide is available here:OpenTelemetry.Instrumentation.Http Readme
OpenTelemetry.Instrumentation.Httpcan be used to collect telemetry for outbound http dependencies. Azure Monitor maps it toDependency Telemetry.
dotnet add package OpenTelemetry.Instrumentation.Http
dotnet add package OpenTelemetry.Instrumentation.Http
A complete getting started guide is available here:OpenTelemetry.Instrumentation.Http Readme
OpenTelemetry.Instrumentation.SqlClientcan be used to collect telemetry for MS SQL dependencies. Azure Monitor maps it toDependency Telemetry.dotnet add package --prerelease OpenTelemetry.Instrumentation.SqlClientA complete getting started guide is available here:OpenTelemetry.Instrumentation.SqlClient Readme
OpenTelemetry.Instrumentation.SqlClientcan be used to collect telemetry for MS SQL dependencies. Azure Monitor maps it toDependency Telemetry.
dotnet add package --prerelease OpenTelemetry.Instrumentation.SqlClient
dotnet add package --prerelease OpenTelemetry.Instrumentation.SqlClient
A complete getting started guide is available here:OpenTelemetry.Instrumentation.SqlClient Readme
The following code sample expands on the previous example.
It now collects telemetry, but doesn't yet send to Application Insights.
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

public class Global : System.Web.HttpApplication
{
    private TracerProvider? tracerProvider;
    private MeterProvider? meterProvider;
    internal static ILoggerFactory loggerFactory;

    protected void Application_Start()
    {
        this.tracerProvider = Sdk.CreateTracerProviderBuilder()
            .AddAspNetInstrumentation()
            .AddHttpClientInstrumentation()
            .AddSqlClientInstrumentation()
            .Build();

        this.meterProvider = Sdk.CreateMeterProviderBuilder()
            .AddAspNetInstrumentation()
            .AddHttpClientInstrumentation()
            .Build();

        loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry();
        });
    }

    protected void Application_End()
    {
        this.tracerProvider?.Dispose();
        this.meterProvider?.Dispose();
        loggerFactory?.Dispose();
    }
}
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

public class Global : System.Web.HttpApplication
{
    private TracerProvider? tracerProvider;
    private MeterProvider? meterProvider;
    internal static ILoggerFactory loggerFactory;

    protected void Application_Start()
    {
        this.tracerProvider = Sdk.CreateTracerProviderBuilder()
            .AddAspNetInstrumentation()
            .AddHttpClientInstrumentation()
            .AddSqlClientInstrumentation()
            .Build();

        this.meterProvider = Sdk.CreateMeterProviderBuilder()
            .AddAspNetInstrumentation()
            .AddHttpClientInstrumentation()
            .Build();

        loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry();
        });
    }

    protected void Application_End()
    {
        this.tracerProvider?.Dispose();
        this.meterProvider?.Dispose();
        loggerFactory?.Dispose();
    }
}
Instrumentation librariescan be added to your project to auto collect telemetry about specific components or dependencies. We recommend the following libraries:
OpenTelemetry.Instrumentation.Httpcan be used to collect telemetry for outbound http dependencies. Azure Monitor maps it toDependency Telemetry.dotnet add package OpenTelemetry.Instrumentation.HttpA complete getting started guide is available here:OpenTelemetry.Instrumentation.Http Readme
OpenTelemetry.Instrumentation.Httpcan be used to collect telemetry for outbound http dependencies. Azure Monitor maps it toDependency Telemetry.
dotnet add package OpenTelemetry.Instrumentation.Http
dotnet add package OpenTelemetry.Instrumentation.Http
A complete getting started guide is available here:OpenTelemetry.Instrumentation.Http Readme
OpenTelemetry.Instrumentation.SqlClientcan be used to collect telemetry for MS SQL dependencies. Azure Monitor maps it toDependency Telemetry.dotnet add package --prerelease OpenTelemetry.Instrumentation.SqlClientA complete getting started guide is available here:OpenTelemetry.Instrumentation.SqlClient Readme
OpenTelemetry.Instrumentation.SqlClientcan be used to collect telemetry for MS SQL dependencies. Azure Monitor maps it toDependency Telemetry.
dotnet add package --prerelease OpenTelemetry.Instrumentation.SqlClient
dotnet add package --prerelease OpenTelemetry.Instrumentation.SqlClient
A complete getting started guide is available here:OpenTelemetry.Instrumentation.SqlClient Readme
The following code sample expands on the previous example.
It now collects telemetry, but doesn't yet send to Application Insights.
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

internal class Program
{
    static void Main(string[] args)
    {
        TracerProvider tracerProvider = Sdk.CreateTracerProviderBuilder()
            .AddHttpClientInstrumentation()
            .AddSqlClientInstrumentation()
            .Build();

        MeterProvider meterProvider = Sdk.CreateMeterProviderBuilder()
            .AddHttpClientInstrumentation()
            .Build();

        ILoggerFactory loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry();
        });

        Console.WriteLine("Hello, World!");

        tracerProvider.Dispose();
        meterProvider.Dispose();
        loggerFactory.Dispose();
    }
}
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

internal class Program
{
    static void Main(string[] args)
    {
        TracerProvider tracerProvider = Sdk.CreateTracerProviderBuilder()
            .AddHttpClientInstrumentation()
            .AddSqlClientInstrumentation()
            .Build();

        MeterProvider meterProvider = Sdk.CreateMeterProviderBuilder()
            .AddHttpClientInstrumentation()
            .Build();

        ILoggerFactory loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry();
        });

        Console.WriteLine("Hello, World!");

        tracerProvider.Dispose();
        meterProvider.Dispose();
        loggerFactory.Dispose();
    }
}
Instrumentation librariescan be added to your project to auto collect telemetry about specific components or dependencies. We recommend the following libraries:
OpenTelemetry.Instrumentation.Httpcan be used to collect telemetry for outbound http dependencies. Azure Monitor maps it toDependency Telemetry.dotnet add package OpenTelemetry.Instrumentation.HttpA complete getting started guide is available here:OpenTelemetry.Instrumentation.Http Readme
OpenTelemetry.Instrumentation.Httpcan be used to collect telemetry for outbound http dependencies. Azure Monitor maps it toDependency Telemetry.
dotnet add package OpenTelemetry.Instrumentation.Http
dotnet add package OpenTelemetry.Instrumentation.Http
A complete getting started guide is available here:OpenTelemetry.Instrumentation.Http Readme
OpenTelemetry.Instrumentation.SqlClientcan be used to collect telemetry for MS SQL dependencies. Azure Monitor maps it toDependency Telemetry.dotnet add package --prerelease OpenTelemetry.Instrumentation.SqlClientA complete getting started guide is available here:OpenTelemetry.Instrumentation.SqlClient Readme
OpenTelemetry.Instrumentation.SqlClientcan be used to collect telemetry for MS SQL dependencies. Azure Monitor maps it toDependency Telemetry.
dotnet add package --prerelease OpenTelemetry.Instrumentation.SqlClient
dotnet add package --prerelease OpenTelemetry.Instrumentation.SqlClient
A complete getting started guide is available here:OpenTelemetry.Instrumentation.SqlClient Readme
The following code sample expands on the previous example.
It now collects telemetry, but doesn't yet send to Application Insights.
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = Host.CreateApplicationBuilder(args);
        builder.Services.AddHostedService<Worker>();

        builder.Services.AddOpenTelemetry()
            .WithTracing(builder =>
            {
                builder.AddHttpClientInstrumentation();
                builder.AddSqlClientInstrumentation();
            })
            .WithMetrics(builder =>
            {
                builder.AddHttpClientInstrumentation();
            });

        builder.Logging.AddOpenTelemetry();

        var host = builder.Build();
        host.Run();
    }
}
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = Host.CreateApplicationBuilder(args);
        builder.Services.AddHostedService<Worker>();

        builder.Services.AddOpenTelemetry()
            .WithTracing(builder =>
            {
                builder.AddHttpClientInstrumentation();
                builder.AddSqlClientInstrumentation();
            })
            .WithMetrics(builder =>
            {
                builder.AddHttpClientInstrumentation();
            });

        builder.Logging.AddOpenTelemetry();

        var host = builder.Build();
        host.Run();
    }
}
Configure Azure Monitor
ASP.NET Core
ASP.NET
Console
WorkerService
Application Insights offered many more configuration options viaApplicationInsightsServiceOptions.
ApplicationInsightsServiceOptions
Remove custom configurations
The following scenarios are optional and only apply to advanced users.
If you have any more references to theTelemetryClient, which could be used tomanually record telemetry, they should be removed.
If you have any more references to theTelemetryClient, which could be used tomanually record telemetry, they should be removed.
TelemetryClient
If you added anycustom filtering or enrichmentin the form of a customTelemetryProcessororTelemetryInitializer, they should be removed. They can be found in yourServiceCollection.builder.Services.AddSingleton<ITelemetryInitializer, MyCustomTelemetryInitializer>();builder.Services.AddApplicationInsightsTelemetryProcessor<MyCustomTelemetryProcessor>();
If you added anycustom filtering or enrichmentin the form of a customTelemetryProcessororTelemetryInitializer, they should be removed. They can be found in yourServiceCollection.
TelemetryProcessor
TelemetryInitializer
ServiceCollection
builder.Services.AddSingleton<ITelemetryInitializer, MyCustomTelemetryInitializer>();
builder.Services.AddSingleton<ITelemetryInitializer, MyCustomTelemetryInitializer>();
builder.Services.AddApplicationInsightsTelemetryProcessor<MyCustomTelemetryProcessor>();
builder.Services.AddApplicationInsightsTelemetryProcessor<MyCustomTelemetryProcessor>();
Remove JavaScript SnippetIf you used the Snippet provided by the Application Insights .NET SDK, it must also be removed.
For full code samples of what to remove, review the guideenable client-side telemetry for web applications.If you added the JavaScript SDK to collect client-side telemetry, it can also be removed although it continues to work without the .NET SDK.
For full code samples of what to remove, review theonboarding guide for the JavaScript SDK.
Remove JavaScript Snippet
If you used the Snippet provided by the Application Insights .NET SDK, it must also be removed.
For full code samples of what to remove, review the guideenable client-side telemetry for web applications.
If you added the JavaScript SDK to collect client-side telemetry, it can also be removed although it continues to work without the .NET SDK.
For full code samples of what to remove, review theonboarding guide for the JavaScript SDK.
Remove any Visual Studio ArtifactsIf you used Visual Studio to onboard to Application Insights, you could have more files left over in your project.Properties/ServiceDependenciesdirectory might have a reference to your Application Insights resource.
Remove any Visual Studio Artifacts
If you used Visual Studio to onboard to Application Insights, you could have more files left over in your project.
Properties/ServiceDependenciesdirectory might have a reference to your Application Insights resource.
Properties/ServiceDependencies
To send your telemetry to Application Insights, the Azure Monitor Exporter must be added to the configuration of all three signals.
The following code sample expands on the previous example.
It now collects telemetry and sends to Application Insights.
public class Global : System.Web.HttpApplication
{
    private TracerProvider? tracerProvider;
    private MeterProvider? meterProvider;
    internal static ILoggerFactory loggerFactory;

    protected void Application_Start()
    {
        this.tracerProvider = Sdk.CreateTracerProviderBuilder()
            .AddAspNetInstrumentation()
            .AddHttpClientInstrumentation()
            .AddSqlClientInstrumentation()
            .AddAzureMonitorTraceExporter()
            .Build();

        this.meterProvider = Sdk.CreateMeterProviderBuilder()
            .AddAspNetInstrumentation()
            .AddHttpClientInstrumentation()
            .AddAzureMonitorMetricExporter()
            .Build();

        loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry(logging => logging.AddAzureMonitorLogExporter());
        });
    }

    protected void Application_End()
    {
        this.tracerProvider?.Dispose();
        this.meterProvider?.Dispose();
        loggerFactory?.Dispose();
    }
}
public class Global : System.Web.HttpApplication
{
    private TracerProvider? tracerProvider;
    private MeterProvider? meterProvider;
    internal static ILoggerFactory loggerFactory;

    protected void Application_Start()
    {
        this.tracerProvider = Sdk.CreateTracerProviderBuilder()
            .AddAspNetInstrumentation()
            .AddHttpClientInstrumentation()
            .AddSqlClientInstrumentation()
            .AddAzureMonitorTraceExporter()
            .Build();

        this.meterProvider = Sdk.CreateMeterProviderBuilder()
            .AddAspNetInstrumentation()
            .AddHttpClientInstrumentation()
            .AddAzureMonitorMetricExporter()
            .Build();

        loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry(logging => logging.AddAzureMonitorLogExporter());
        });
    }

    protected void Application_End()
    {
        this.tracerProvider?.Dispose();
        this.meterProvider?.Dispose();
        loggerFactory?.Dispose();
    }
}
We recommend setting your Connection String in an environment variable:
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
More options to configure the Connection String are detailed here:Configure the Application Insights Connection String.
To send your telemetry to Application Insights, the Azure Monitor Exporter must be added to the configuration of all three signals.
The following code sample expands on the previous example.
It now collects telemetry and sends to Application Insights.
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

internal class Program
{
    static void Main(string[] args)
    {
        TracerProvider tracerProvider = Sdk.CreateTracerProviderBuilder()
            .AddHttpClientInstrumentation()
            .AddSqlClientInstrumentation()
            .AddAzureMonitorTraceExporter()
            .Build();

        MeterProvider meterProvider = Sdk.CreateMeterProviderBuilder()
            .AddHttpClientInstrumentation()
            .AddAzureMonitorMetricExporter()
            .Build();

        ILoggerFactory loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry(logging => logging.AddAzureMonitorLogExporter());
        });

        Console.WriteLine("Hello, World!");

        tracerProvider.Dispose();
        meterProvider.Dispose();
        loggerFactory.Dispose();
    }
}
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

internal class Program
{
    static void Main(string[] args)
    {
        TracerProvider tracerProvider = Sdk.CreateTracerProviderBuilder()
            .AddHttpClientInstrumentation()
            .AddSqlClientInstrumentation()
            .AddAzureMonitorTraceExporter()
            .Build();

        MeterProvider meterProvider = Sdk.CreateMeterProviderBuilder()
            .AddHttpClientInstrumentation()
            .AddAzureMonitorMetricExporter()
            .Build();

        ILoggerFactory loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddOpenTelemetry(logging => logging.AddAzureMonitorLogExporter());
        });

        Console.WriteLine("Hello, World!");

        tracerProvider.Dispose();
        meterProvider.Dispose();
        loggerFactory.Dispose();
    }
}
We recommend setting your Connection String in an environment variable:
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
More options to configure the Connection String are detailed here:Configure the Application Insights Connection String.
Remove custom configurations
The following scenarios are optional and apply to advanced users.
If you have any more references to theTelemetryClient, which is used tomanually record telemetry, they should be removed.
If you have any more references to theTelemetryClient, which is used tomanually record telemetry, they should be removed.
TelemetryClient
Remove anycustom filtering or enrichmentadded as a customTelemetryProcessororTelemetryInitializer. The configuration references them.
Remove anycustom filtering or enrichmentadded as a customTelemetryProcessororTelemetryInitializer. The configuration references them.
TelemetryProcessor
TelemetryInitializer
Remove any Visual Studio ArtifactsIf you used Visual Studio to onboard to Application Insights, you could have more files left over in your project.ConnectedService.jsonmight have a reference to your Application Insights resource.[Your project's name].csprojmight have a reference to your Application Insights resource:<ApplicationInsightsResourceId>/subscriptions/aaaa0a0a-bb1b-cc2c-dd3d-eeeeee4e4e4e/resourcegroups/Default-ApplicationInsights-EastUS/providers/microsoft.insights/components/WebApplication4</ApplicationInsightsResourceId>
Remove any Visual Studio Artifacts
If you used Visual Studio to onboard to Application Insights, you could have more files left over in your project.
ConnectedService.jsonmight have a reference to your Application Insights resource.
ConnectedService.jsonmight have a reference to your Application Insights resource.
ConnectedService.json
[Your project's name].csprojmight have a reference to your Application Insights resource:<ApplicationInsightsResourceId>/subscriptions/aaaa0a0a-bb1b-cc2c-dd3d-eeeeee4e4e4e/resourcegroups/Default-ApplicationInsights-EastUS/providers/microsoft.insights/components/WebApplication4</ApplicationInsightsResourceId>
[Your project's name].csprojmight have a reference to your Application Insights resource:
[Your project's name].csproj
<ApplicationInsightsResourceId>/subscriptions/aaaa0a0a-bb1b-cc2c-dd3d-eeeeee4e4e4e/resourcegroups/Default-ApplicationInsights-EastUS/providers/microsoft.insights/components/WebApplication4</ApplicationInsightsResourceId>
<ApplicationInsightsResourceId>/subscriptions/aaaa0a0a-bb1b-cc2c-dd3d-eeeeee4e4e4e/resourcegroups/Default-ApplicationInsights-EastUS/providers/microsoft.insights/components/WebApplication4</ApplicationInsightsResourceId>
To send your telemetry to Application Insights, the Azure Monitor Exporter must be added to the configuration of all three signals.
The following code sample expands on the previous example.
It now collects telemetry and sends to Application Insights.
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = Host.CreateApplicationBuilder(args);
        builder.Services.AddHostedService<Worker>();

        builder.Services.AddOpenTelemetry()
            .WithTracing(builder =>
            {
                builder.AddHttpClientInstrumentation();
                builder.AddSqlClientInstrumentation();
                builder.AddAzureMonitorTraceExporter();
            })
            .WithMetrics(builder =>
            {
                builder.AddHttpClientInstrumentation();
                builder.AddAzureMonitorMetricExporter();
            });

        builder.Logging.AddOpenTelemetry(logging => logging.AddAzureMonitorLogExporter());

        var host = builder.Build();
        host.Run();
    }
}
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = Host.CreateApplicationBuilder(args);
        builder.Services.AddHostedService<Worker>();

        builder.Services.AddOpenTelemetry()
            .WithTracing(builder =>
            {
                builder.AddHttpClientInstrumentation();
                builder.AddSqlClientInstrumentation();
                builder.AddAzureMonitorTraceExporter();
            })
            .WithMetrics(builder =>
            {
                builder.AddHttpClientInstrumentation();
                builder.AddAzureMonitorMetricExporter();
            });

        builder.Logging.AddOpenTelemetry(logging => logging.AddAzureMonitorLogExporter());

        var host = builder.Build();
        host.Run();
    }
}
We recommend setting your Connection String in an environment variable:
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
More options to configure the Connection String are detailed here:Configure the Application Insights Connection String.
Application Insights offered many more configuration options viaApplicationInsightsServiceOptions.
ApplicationInsightsServiceOptions
Remove Custom Configurations
The following scenarios are optional and apply to advanced users.
If you have any more references to theTelemetryClient, which are used tomanually record telemetry, they should be removed.
If you have any more references to theTelemetryClient, which are used tomanually record telemetry, they should be removed.
TelemetryClient
If you added anycustom filtering or enrichmentin the form of a customTelemetryProcessororTelemetryInitializer, it should be removed. You can find references in yourServiceCollection.builder.Services.AddSingleton<ITelemetryInitializer, MyCustomTelemetryInitializer>();builder.Services.AddApplicationInsightsTelemetryProcessor<MyCustomTelemetryProcessor>();
If you added anycustom filtering or enrichmentin the form of a customTelemetryProcessororTelemetryInitializer, it should be removed. You can find references in yourServiceCollection.
TelemetryProcessor
TelemetryInitializer
ServiceCollection
builder.Services.AddSingleton<ITelemetryInitializer, MyCustomTelemetryInitializer>();
builder.Services.AddSingleton<ITelemetryInitializer, MyCustomTelemetryInitializer>();
builder.Services.AddApplicationInsightsTelemetryProcessor<MyCustomTelemetryProcessor>();
builder.Services.AddApplicationInsightsTelemetryProcessor<MyCustomTelemetryProcessor>();
Remove any Visual Studio ArtifactsIf you used Visual Studio to onboard to Application Insights, you could have more files left over in your project.Properties/ServiceDependenciesdirectory might have a reference to your Application Insights resource.
Remove any Visual Studio Artifacts
If you used Visual Studio to onboard to Application Insights, you could have more files left over in your project.
Properties/ServiceDependenciesdirectory might have a reference to your Application Insights resource.
Properties/ServiceDependencies
Tip
Our product group is actively seeking feedback on this documentation. Provide feedback to otel@microsoft.com or see theSupportsection.
Frequently asked questions
This section is for customers who use telemetry initializers or processors, or write custom code against the classic Application Insights API to create custom telemetry.
How do the SDK API's map to OpenTelemetry concepts?
OpenTelemetryis a vendor neutral observability framework. There are no Application Insights APIs in the OpenTelemetry SDK or libraries. Before migrating, it's important to understand some of OpenTelemetry's concepts.
In Application Insights, all telemetry was managed through a singleTelemetryClientandTelemetryConfiguration. In OpenTelemetry, each of the three telemetry signals (Traces, Metrics, and Logs) has its own configuration. You can manually create telemetry via the .NET runtime without external libraries. For more information, see the .NET guides ondistributed tracing,metrics, andlogging.
In Application Insights, all telemetry was managed through a singleTelemetryClientandTelemetryConfiguration. In OpenTelemetry, each of the three telemetry signals (Traces, Metrics, and Logs) has its own configuration. You can manually create telemetry via the .NET runtime without external libraries. For more information, see the .NET guides ondistributed tracing,metrics, andlogging.
TelemetryClient
TelemetryConfiguration
Application Insights usedTelemetryModulesto automatically collect telemetry for your application.
Instead, OpenTelemetry usesInstrumentation librariesto collect telemetry from specific components (such asAspNetCorefor Requests andHttpClientfor Dependencies).
Application Insights usedTelemetryModulesto automatically collect telemetry for your application.
Instead, OpenTelemetry usesInstrumentation librariesto collect telemetry from specific components (such asAspNetCorefor Requests andHttpClientfor Dependencies).
TelemetryModules
Application Insights usedTelemetryInitializersto enrich telemetry with additional information or to override properties.
With OpenTelemetry, you can write aProcessorto customize a specific signal. Additionally, many OpenTelemetry Instrumentation libraries offer anEnrichmethod to customize the telemetry generated by that specific component.
Application Insights usedTelemetryInitializersto enrich telemetry with additional information or to override properties.
With OpenTelemetry, you can write aProcessorto customize a specific signal. Additionally, many OpenTelemetry Instrumentation libraries offer anEnrichmethod to customize the telemetry generated by that specific component.
TelemetryInitializers
Enrich
Application Insights usedTelemetryProcessorsto filter telemetry. An OpenTelemetryProcessorcan also be used to apply filtering rules on a specific signal.
Application Insights usedTelemetryProcessorsto filter telemetry. An OpenTelemetryProcessorcan also be used to apply filtering rules on a specific signal.
TelemetryProcessors
How do Application Insights telemetry types map to OpenTelemetry?
This table maps Application Insights data types to OpenTelemetry concepts and their .NET implementations.
The following documents provide more information.
Data Collection Basics of Azure Monitor Application Insights
Application Insights telemetry data model
OpenTelemetry Concepts
How do Application Insights sampling concepts map to OpenTelemetry?
While Application Insights offered multiple options to configure sampling, Azure Monitor Exporter or Azure Monitor Distro only offers fixed rate sampling. OnlyRequestsandDependencies(OpenTelemetry Traces) can be sampled.
For code samples detailing how to configure sampling, see our guideEnable Sampling
How do Telemetry Processors and Initializers map to OpenTelemetry?
In the Application Insights .NET SDK, use telemetry processors to filter and modify or discard telemetry. Use telemetry initializers to add or modify custom properties. For more information, see theAzure Monitor documentation. OpenTelemetry replaces these concepts with activity or log processors, which enrich and filter telemetry.
To filter telemetry data in OpenTelemetry, you can implement an activity processor. This example is equivalent to the Application Insights example for filtering telemetry data as described inAzure Monitor documentation. The example illustrates where unsuccessful dependency calls are filtered.
using System.Diagnostics;
using OpenTelemetry;

internal sealed class SuccessfulDependencyFilterProcessor : BaseProcessor<Activity>
{
    public override void OnEnd(Activity activity)
    {
        if (!OKtoSend(activity))
        {
            activity.ActivityTraceFlags &= ~ActivityTraceFlags.Recorded;
        }
    }

    private bool OKtoSend(Activity activity)
    {
        return activity.Kind == ActivityKind.Client && activity.Status == ActivityStatusCode.Ok;
    }
}
using System.Diagnostics;
using OpenTelemetry;

internal sealed class SuccessfulDependencyFilterProcessor : BaseProcessor<Activity>
{
    public override void OnEnd(Activity activity)
    {
        if (!OKtoSend(activity))
        {
            activity.ActivityTraceFlags &= ~ActivityTraceFlags.Recorded;
        }
    }

    private bool OKtoSend(Activity activity)
    {
        return activity.Kind == ActivityKind.Client && activity.Status == ActivityStatusCode.Ok;
    }
}
To use this processor, you need to create aTracerProviderand add the processor beforeAddAzureMonitorTraceExporter.
TracerProvider
AddAzureMonitorTraceExporter
using OpenTelemetry.Trace;

public static void Main()
{
    var tracerProvider = Sdk.CreateTracerProviderBuilder()
        .AddProcessor(new SuccessfulDependencyFilterProcessor())
        .AddAzureMonitorTraceExporter()
        .Build();
}
using OpenTelemetry.Trace;

public static void Main()
{
    var tracerProvider = Sdk.CreateTracerProviderBuilder()
        .AddProcessor(new SuccessfulDependencyFilterProcessor())
        .AddAzureMonitorTraceExporter()
        .Build();
}
ILoggerimplementations have a built-in mechanism to applylog
filtering.
This filtering lets you control the logs that are sent to each registered
provider, including theOpenTelemetryLoggerProvider. "OpenTelemetry" is thealiasforOpenTelemetryLoggerProvider, used in configuring filtering rules.
ILogger
OpenTelemetryLoggerProvider
OpenTelemetryLoggerProvider
The following example defines "Error" as the defaultLogLeveland also defines "Warning" as the minimumLogLevelfor a user defined category.
These rules as defined only apply to theOpenTelemetryLoggerProvider.
LogLevel
LogLevel
OpenTelemetryLoggerProvider
builder.AddFilter<OpenTelemetryLoggerProvider>("*", LogLevel.Error);
builder.AddFilter<OpenTelemetryLoggerProvider>("MyProduct.MyLibrary.MyClass", LogLevel.Warning);
builder.AddFilter<OpenTelemetryLoggerProvider>("*", LogLevel.Error);
builder.AddFilter<OpenTelemetryLoggerProvider>("MyProduct.MyLibrary.MyClass", LogLevel.Warning);
For more information, please read theOpenTelemetry .NET documentation on logs.
In OpenTelemetry, you can use activity processors to enrich telemetry data with more properties. It's similar to using telemetry initializers in Application Insights, where you can modify telemetry properties.
By default, Azure Monitor Exporter flags any HTTP request with a response code of 400 or greater as failed. However, if you want to treat 400 as a success, you can add an enriching activity processor that sets the success on the activity and adds a tag to include more telemetry properties. It's similar to adding or modifying properties using an initializer in Application Insights as described inAzure Monitor documentation.
Here's an example of how to add custom properties and override the default behavior for certain response codes:
using System.Diagnostics;
using OpenTelemetry;

/// <summary>
/// Custom Processor that overrides the default behavior of treating response codes >= 400 as failed requests.
/// </summary>
internal class MyEnrichingProcessor : BaseProcessor<Activity>
{
    public override void OnEnd(Activity activity)
    {
        if (activity.Kind == ActivityKind.Server)
        {
            int responseCode = GetResponseCode(activity);

            if (responseCode >= 400 && responseCode < 500)
            {
                // If we set the Success property, the SDK won't change it
                activity.SetStatus(ActivityStatusCode.Ok);

                // Allow to filter these requests in the portal
                activity.SetTag("Overridden400s", "true");
            }

            // else leave the SDK to set the Success property
        }
    }

    private int GetResponseCode(Activity activity)
    {
        foreach (ref readonly var tag in activity.EnumerateTagObjects())
        {
            if (tag.Key == "http.response.status_code" && tag.Value is int value)
            {
                return value;
            }
        }

        return 0;
    }
}
using System.Diagnostics;
using OpenTelemetry;

/// <summary>
/// Custom Processor that overrides the default behavior of treating response codes >= 400 as failed requests.
/// </summary>
internal class MyEnrichingProcessor : BaseProcessor<Activity>
{
    public override void OnEnd(Activity activity)
    {
        if (activity.Kind == ActivityKind.Server)
        {
            int responseCode = GetResponseCode(activity);

            if (responseCode >= 400 && responseCode < 500)
            {
                // If we set the Success property, the SDK won't change it
                activity.SetStatus(ActivityStatusCode.Ok);

                // Allow to filter these requests in the portal
                activity.SetTag("Overridden400s", "true");
            }

            // else leave the SDK to set the Success property
        }
    }

    private int GetResponseCode(Activity activity)
    {
        foreach (ref readonly var tag in activity.EnumerateTagObjects())
        {
            if (tag.Key == "http.response.status_code" && tag.Value is int value)
            {
                return value;
            }
        }

        return 0;
    }
}
To use this processor, you need to create aTracerProviderand add the processor beforeAddAzureMonitorTraceExporter.
TracerProvider
AddAzureMonitorTraceExporter
using OpenTelemetry.Trace;

public static void Main()
{
    var tracerProvider = Sdk.CreateTracerProviderBuilder()
        .AddSource("Company.Product.Name")
        .AddProcessor(new MyEnrichingProcessor())
        .AddAzureMonitorTraceExporter()
        .Build();
}
using OpenTelemetry.Trace;

public static void Main()
{
    var tracerProvider = Sdk.CreateTracerProviderBuilder()
        .AddSource("Company.Product.Name")
        .AddProcessor(new MyEnrichingProcessor())
        .AddAzureMonitorTraceExporter()
        .Build();
}
How do I manually track telemetry using OpenTelemetry?
Traces in Application Insights are stored asRequestTelemetryandDependencyTelemetry. In OpenTelemetry, traces are modeled asSpanusing theActivityclass.
RequestTelemetry
DependencyTelemetry
Span
Activity
OpenTelemetry .NET utilizes theActivitySourceandActivityclasses for tracing, which are part of the .NET runtime. This approach is distinctive because the .NET implementation integrates the tracing API directly into the runtime itself. TheSystem.Diagnostics.DiagnosticSourcepackage allows developers to useActivitySourceto create and manageActivityinstances. This method provides a seamless way to add tracing to .NET applications without relying on external libraries, applying the built-in capabilities of the .NET ecosystem. For more detailed information, refer to thedistributed tracing instrumentation walkthroughs.
ActivitySource
Activity
System.Diagnostics.DiagnosticSource
ActivitySource
Activity
Here's how to migrate manual tracing:
Note
In Application Insights, the role name and role instance could be set at a per-telemetry level. However, with the Azure Monitor Exporter, we cannot customize at a per-telemetry level. The role name and role instance are extracted from the OpenTelemetry resource and applied across all telemetry. Please read this document for more information:Set the cloud role name and the cloud role instance.
Application InsightsDependencyTelemetryis used to model outgoing requests. Here's how to convert it to OpenTelemetry:
DependencyTelemetry
Application Insights Example:
DependencyTelemetry dep = new DependencyTelemetry
{
   Name = "DependencyName",
   Data = "https://www.example.com/",
   Type = "Http",
   Target = "www.example.com",
   Duration = TimeSpan.FromSeconds(10),
   ResultCode = "500",
   Success = false
};

dep.Context.Cloud.RoleName = "MyRole";
dep.Context.Cloud.RoleInstance = "MyRoleInstance";
dep.Properties["customprop1"] = "custom value1";
client.TrackDependency(dep);
DependencyTelemetry dep = new DependencyTelemetry
{
   Name = "DependencyName",
   Data = "https://www.example.com/",
   Type = "Http",
   Target = "www.example.com",
   Duration = TimeSpan.FromSeconds(10),
   ResultCode = "500",
   Success = false
};

dep.Context.Cloud.RoleName = "MyRole";
dep.Context.Cloud.RoleInstance = "MyRoleInstance";
dep.Properties["customprop1"] = "custom value1";
client.TrackDependency(dep);
OpenTelemetry Example:
var activitySource = new ActivitySource("Company.Product.Name");
var resourceAttributes = new Dictionary<string, object>
{
   { "service.name", "MyRole" },
   { "service.instance.id", "MyRoleInstance" }
};

var resourceBuilder = ResourceBuilder.CreateDefault().AddAttributes(resourceAttributes);

using var tracerProvider = Sdk.CreateTracerProviderBuilder()
  .SetResourceBuilder(resourceBuilder)
  .AddSource(activitySource.Name)
  .AddAzureMonitorTraceExporter()
  .Build();

// Emit traces
using (var activity = activitySource.StartActivity("DependencyName", ActivityKind.Client))
{
  activity?.SetTag("url.full", "https://www.example.com/");
  activity?.SetTag("server.address", "www.example.com");
  activity?.SetTag("http.request.method", "GET");
  activity?.SetTag("http.response.status_code", "500");
  activity?.SetTag("customprop1", "custom value1");
  activity?.SetStatus(ActivityStatusCode.Error);
  activity?.SetEndTime(activity.StartTimeUtc.AddSeconds(10));
}
var activitySource = new ActivitySource("Company.Product.Name");
var resourceAttributes = new Dictionary<string, object>
{
   { "service.name", "MyRole" },
   { "service.instance.id", "MyRoleInstance" }
};

var resourceBuilder = ResourceBuilder.CreateDefault().AddAttributes(resourceAttributes);

using var tracerProvider = Sdk.CreateTracerProviderBuilder()
  .SetResourceBuilder(resourceBuilder)
  .AddSource(activitySource.Name)
  .AddAzureMonitorTraceExporter()
  .Build();

// Emit traces
using (var activity = activitySource.StartActivity("DependencyName", ActivityKind.Client))
{
  activity?.SetTag("url.full", "https://www.example.com/");
  activity?.SetTag("server.address", "www.example.com");
  activity?.SetTag("http.request.method", "GET");
  activity?.SetTag("http.response.status_code", "500");
  activity?.SetTag("customprop1", "custom value1");
  activity?.SetStatus(ActivityStatusCode.Error);
  activity?.SetEndTime(activity.StartTimeUtc.AddSeconds(10));
}
Application InsightsRequestTelemetrymodels incoming requests. Here's how to migrate it to OpenTelemetry:
RequestTelemetry
Application Insights Example:
RequestTelemetry req = new RequestTelemetry
{
   Name = "RequestName",
   Url = new Uri("http://example.com"),
   Duration = TimeSpan.FromSeconds(10),
   ResponseCode = "200",
   Success = true,
   Properties = { ["customprop1"] = "custom value1" }
};

req.Context.Cloud.RoleName = "MyRole";
req.Context.Cloud.RoleInstance = "MyRoleInstance";
client.TrackRequest(req);
RequestTelemetry req = new RequestTelemetry
{
   Name = "RequestName",
   Url = new Uri("http://example.com"),
   Duration = TimeSpan.FromSeconds(10),
   ResponseCode = "200",
   Success = true,
   Properties = { ["customprop1"] = "custom value1" }
};

req.Context.Cloud.RoleName = "MyRole";
req.Context.Cloud.RoleInstance = "MyRoleInstance";
client.TrackRequest(req);
OpenTelemetry Example:
var activitySource = new ActivitySource("Company.Product.Name");
var resourceAttributes = new Dictionary<string, object>
{
   { "service.name", "MyRole" },
   { "service.instance.id", "MyRoleInstance" }
};

var resourceBuilder = ResourceBuilder.CreateDefault().AddAttributes(resourceAttributes);

using var tracerProvider = Sdk.CreateTracerProviderBuilder()
  .SetResourceBuilder(resourceBuilder)
  .AddSource(activitySource.Name)
  .AddAzureMonitorTraceExporter()
  .Build();

// Emit traces
using (var activity = activitySource.StartActivity("RequestName", ActivityKind.Server))
{
  activity?.SetTag("url.scheme", "https");
  activity?.SetTag("server.address", "www.example.com");
  activity?.SetTag("url.path", "/");
  activity?.SetTag("http.response.status_code", "200");
  activity?.SetTag("customprop1", "custom value1");
  activity?.SetStatus(ActivityStatusCode.Ok);
}
var activitySource = new ActivitySource("Company.Product.Name");
var resourceAttributes = new Dictionary<string, object>
{
   { "service.name", "MyRole" },
   { "service.instance.id", "MyRoleInstance" }
};

var resourceBuilder = ResourceBuilder.CreateDefault().AddAttributes(resourceAttributes);

using var tracerProvider = Sdk.CreateTracerProviderBuilder()
  .SetResourceBuilder(resourceBuilder)
  .AddSource(activitySource.Name)
  .AddAzureMonitorTraceExporter()
  .Build();

// Emit traces
using (var activity = activitySource.StartActivity("RequestName", ActivityKind.Server))
{
  activity?.SetTag("url.scheme", "https");
  activity?.SetTag("server.address", "www.example.com");
  activity?.SetTag("url.path", "/");
  activity?.SetTag("http.response.status_code", "200");
  activity?.SetTag("customprop1", "custom value1");
  activity?.SetStatus(ActivityStatusCode.Ok);
}
In Application Insights, track custom operations usingStartOperationandStopOperationmethods. Achieve it usingActivitySourceandActivityin OpenTelemetry .NET. For operations withActivityKind.ServerandActivityKind.Consumer, Azure Monitor Exporter generatesRequestTelemetry. ForActivityKind.Client,ActivityKind.Producer, andActivityKind.Internal, it generatesDependencyTelemetry. For more information on custom operations tracking, see theAzure Monitor documentation. For more on usingActivitySourceandActivityin .NET, see the.NET distributed tracing instrumentation walkthroughs.
StartOperation
StopOperation
ActivitySource
Activity
ActivityKind.Server
ActivityKind.Consumer
RequestTelemetry
ActivityKind.Client
ActivityKind.Producer
ActivityKind.Internal
DependencyTelemetry
ActivitySource
Activity
Here's an example of how to start and stop an activity for custom operations:
using System.Diagnostics;
using OpenTelemetry;

var activitySource = new ActivitySource("Company.Product.Name");

using var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddSource(activitySource.Name)
    .AddAzureMonitorTraceExporter()
    .Build();

// Start a new activity
using (var activity = activitySource.StartActivity("CustomOperation", ActivityKind.Server))
{
    activity?.SetTag("customTag", "customValue");

    // Perform your custom operation logic here

    // No need to explicitly call Activity.Stop() because the using block automatically disposes the Activity object, which stops it.
}
using System.Diagnostics;
using OpenTelemetry;

var activitySource = new ActivitySource("Company.Product.Name");

using var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddSource(activitySource.Name)
    .AddAzureMonitorTraceExporter()
    .Build();

// Start a new activity
using (var activity = activitySource.StartActivity("CustomOperation", ActivityKind.Server))
{
    activity?.SetTag("customTag", "customValue");

    // Perform your custom operation logic here

    // No need to explicitly call Activity.Stop() because the using block automatically disposes the Activity object, which stops it.
}
Logs in Application Insights are stored asTraceTelemetryandExceptionTelemetry.
TraceTelemetry
ExceptionTelemetry
In OpenTelemetry, logging is integrated via theILoggerinterface. Here's how to migrateTraceTelemetry:
ILogger
TraceTelemetry
Application Insights Example:
TraceTelemetry traceTelemetry = new TraceTelemetry
{
   Message = "hello from tomato 2.99",
   SeverityLevel = SeverityLevel.Warning,
};

traceTelemetry.Context.Cloud.RoleName = "MyRole";
traceTelemetry.Context.Cloud.RoleInstance = "MyRoleInstance";
client.TrackTrace(traceTelemetry);
TraceTelemetry traceTelemetry = new TraceTelemetry
{
   Message = "hello from tomato 2.99",
   SeverityLevel = SeverityLevel.Warning,
};

traceTelemetry.Context.Cloud.RoleName = "MyRole";
traceTelemetry.Context.Cloud.RoleInstance = "MyRoleInstance";
client.TrackTrace(traceTelemetry);
OpenTelemetry Example:
var resourceAttributes = new Dictionary<string, object>
{
   { "service.name", "MyRole" },
   { "service.instance.id", "MyRoleInstance" }
};

var resourceBuilder = ResourceBuilder.CreateDefault().AddAttributes(resourceAttributes);

using var loggerFactory = LoggerFactory.Create(builder => builder
   .AddOpenTelemetry(logging =>
   {
       logging.SetResourceBuilder(resourceBuilder);
       logging.AddAzureMonitorLogExporter();
   }));

// Create a new instance `ILogger` from the above LoggerFactory
var logger = loggerFactory.CreateLogger<Program>();

// Emit log: This uses the logger instance to write a new log
logger.FoodPrice("tomato", 2.99);

internal static partial class LoggerExtensions
{
    [LoggerMessage(LogLevel.Warning, "Hello from `{name}` `{price}`.")]
    public static partial void FoodPrice(this ILogger logger, string name, double price);
}
var resourceAttributes = new Dictionary<string, object>
{
   { "service.name", "MyRole" },
   { "service.instance.id", "MyRoleInstance" }
};

var resourceBuilder = ResourceBuilder.CreateDefault().AddAttributes(resourceAttributes);

using var loggerFactory = LoggerFactory.Create(builder => builder
   .AddOpenTelemetry(logging =>
   {
       logging.SetResourceBuilder(resourceBuilder);
       logging.AddAzureMonitorLogExporter();
   }));

// Create a new instance `ILogger` from the above LoggerFactory
var logger = loggerFactory.CreateLogger<Program>();

// Emit log: This uses the logger instance to write a new log
logger.FoodPrice("tomato", 2.99);

internal static partial class LoggerExtensions
{
    [LoggerMessage(LogLevel.Warning, "Hello from `{name}` `{price}`.")]
    public static partial void FoodPrice(this ILogger logger, string name, double price);
}
Application Insights usesExceptionTelemetryto log exceptions. Here's how to migrate to OpenTelemetry:
ExceptionTelemetry
Application Insights Example:
ExceptionTelemetry exceptionTelemetry = new ExceptionTelemetry(new Exception("Test exception"))
{
    SeverityLevel = SeverityLevel.Error
};

exceptionTelemetry.Context.Cloud.RoleName = "MyRole";
exceptionTelemetry.Context.Cloud.RoleInstance = "MyRoleInstance";
exceptionTelemetry.Properties["customprop1"] = "custom value1";
client.TrackException(exceptionTelemetry);
ExceptionTelemetry exceptionTelemetry = new ExceptionTelemetry(new Exception("Test exception"))
{
    SeverityLevel = SeverityLevel.Error
};

exceptionTelemetry.Context.Cloud.RoleName = "MyRole";
exceptionTelemetry.Context.Cloud.RoleInstance = "MyRoleInstance";
exceptionTelemetry.Properties["customprop1"] = "custom value1";
client.TrackException(exceptionTelemetry);
OpenTelemetry Example:
var resourceAttributes = new Dictionary<string, object>
{
   { "service.name", "MyRole" },
   { "service.instance.id", "MyRoleInstance" }
};

var resourceBuilder = ResourceBuilder.CreateDefault().AddAttributes(resourceAttributes);

using var loggerFactory = LoggerFactory.Create(builder => builder
   .AddOpenTelemetry(logging =>
   {
       logging.SetResourceBuilder(resourceBuilder);
       logging.AddAzureMonitorLogExporter();
   }));

// Create a new instance `ILogger` from the above LoggerFactory.
var logger = loggerFactory.CreateLogger<Program>();

try
{
    // Simulate exception
    throw new Exception("Test exception");
}
catch (Exception ex)
{
    // Emit exception: This uses the logger instance to write a new exception
    logger?.LogError(ex, "An error occurred");
}
var resourceAttributes = new Dictionary<string, object>
{
   { "service.name", "MyRole" },
   { "service.instance.id", "MyRoleInstance" }
};

var resourceBuilder = ResourceBuilder.CreateDefault().AddAttributes(resourceAttributes);

using var loggerFactory = LoggerFactory.Create(builder => builder
   .AddOpenTelemetry(logging =>
   {
       logging.SetResourceBuilder(resourceBuilder);
       logging.AddAzureMonitorLogExporter();
   }));

// Create a new instance `ILogger` from the above LoggerFactory.
var logger = loggerFactory.CreateLogger<Program>();

try
{
    // Simulate exception
    throw new Exception("Test exception");
}
catch (Exception ex)
{
    // Emit exception: This uses the logger instance to write a new exception
    logger?.LogError(ex, "An error occurred");
}
Metrics in Application Insights are stored asMetricTelemetry. In OpenTelemetry, metrics are modeled asMeterfrom theSystem.Diagnostics.DiagnosticSourcepackage.
MetricTelemetry
Meter
System.Diagnostics.DiagnosticSource
Application Insights has both non-pre-aggregating (TrackMetric()) and preaggregating (GetMetric().TrackValue()) Metric APIs. Unlike OpenTelemetry, Application Insights has no notion ofInstruments. Application Insights has the same API for all the metric scenarios.
TrackMetric()
GetMetric().TrackValue()
OpenTelemetry, on the other hand, requires users to firstpick the right metric instrumentbased on the actual semantics of the metric. For example, if the intention is to count something (like the number of total server requests received, etc.),OpenTelemetry Countershould be used. If the intention is to calculate various percentiles (like the P99 value of server latency), thenOpenTelemetry Histograminstrument should be used. Due to this fundamental difference between Application Insights and OpenTelemetry, no direct comparison is made between them.
Unlike Application Insights, OpenTelemetry doesn't provide built-in mechanisms to enrich or filter metrics. In Application Insights, telemetry processors and initializers could be used to modify or discard metrics, but this capability isn't available in OpenTelemetry.
Additionally, OpenTelemetry doesn't support sending raw metrics directly, as there's no equivalent to theTrackMetric()functionality found in Application Insights.
TrackMetric()
Migrating from Application Insights to OpenTelemetry involves replacing all Application Insights Metric API usages with the OpenTelemetry API. It requires understanding the various OpenTelemetry Instruments and their semantics.
Tip
The histogram is the most versatile and the closest equivalent to the Application InsightsGetMetric().TrackValue()API. You can replace Application Insights Metric APIs with Histogram to achieve the same purpose.
GetMetric().TrackValue()
Not supported in OpenTelemetry.
Application Insights Example:
TelemetryClient.TrackEvent()
TelemetryClient.TrackEvent()
Not supported in OpenTelemetry.
Application Insights Example:
TelemetryClient.TrackAvailability()
TelemetryClient.TrackAvailability()
Not supported in OpenTelemetry.
Application Insights Example:
TelemetryClient.TrackPageView()
TelemetryClient.TrackPageView()
We recommend theAzure Monitor OpenTelemetry Exporterfor console and worker service applications, which does not include live metrics.
Next steps
ASP.NET Core
ASP.NET
Console
WorkerService
Azure Monitor Distro Demo project
OpenTelemetry SDK's getting started guide
OpenTelemetry's example ASP.NET Core project
C# and .NET Logging
Azure Monitor OpenTelemetry getting started with ASP.NET Core
OpenTelemetry SDK's getting started guide
OpenTelemetry's example ASP.NET project
C# and .NET Logging
Azure Monitor OpenTelemetry getting started with .NET
OpenTelemetry SDK's getting started guide
OpenTelemetry's example projects:Getting Started with TracesGetting Started with MetricsGetting Started with Logs
Getting Started with Traces
Getting Started with Metrics
Getting Started with Logs
C# and .NET Logging
Azure Monitor OpenTelemetry getting started with .NET
OpenTelemetry SDK's getting started guide
Logging in C# and .NET
Azure Monitor OpenTelemetry getting started with .NET
Tip
Our product group is actively seeking feedback on this documentation. Provide feedback to otel@microsoft.com or see theSupportsection.
Support
ASP.NET Core
.NET
Console
WorkerService
For Azure support issues, open anAzure support ticket.
For OpenTelemetry issues, contact theOpenTelemetry .NET communitydirectly.
For a list of open issues related to Azure Monitor Exporter, see theGitHub Issues Page.
For Azure support issues, open anAzure support ticket.
For OpenTelemetry issues, contact theOpenTelemetry .NET communitydirectly.
For a list of open issues related to Azure Monitor Exporter, see theGitHub Issues Page.
For Azure support issues, open anAzure support ticket.
For OpenTelemetry issues, contact theOpenTelemetry .NET communitydirectly.
For a list of open issues related to Azure Monitor Exporter, see theGitHub Issues Page.
For Azure support issues, open anAzure support ticket.
For OpenTelemetry issues, contact theOpenTelemetry .NET communitydirectly.
For a list of open issues related to Azure Monitor Exporter, see theGitHub Issues Page.
Feedback
Was this page helpful?
Additional resources