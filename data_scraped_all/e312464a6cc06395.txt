Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Secure access and data for workflows in Azure Logic Apps
Article
2024-11-15
44 contributors
In this article
Azure Logic Apps relies onAzure Storageto store and automaticallyencrypt data at rest. This encryption protects your data and helps you meet your organizational security and compliance commitments. By default, Azure Storage uses Microsoft-managed keys to encrypt your data. For more information, reviewAzure Storage encryption for data at rest.
To further control access and protect sensitive data in Azure Logic Apps, you can set up more security in these areas:
Access to logic app operations
Access to run history inputs and outputs
Access to parameter inputs
Authentication types for triggers and actions that support authentication
Access for inbound calls to request-based triggers
Access for outbound calls to other services and systems
Block creating connections for specific connectors
Isolation guidance for logic apps
Azure Security Baseline for Azure Logic Apps
For more information about security in Azure, review these topics:
Azure encryption overview
Azure Data Encryption-at-Rest
Microsoft cloud security benchmark

Access to logic app operations
For Consumption logic apps only, before you can create or manage logic apps and their connections, you need specific permissions, which are provided through roles usingAzure role-based access control (Azure RBAC). You can also set up permissions so that only specific users or groups can run specific tasks, such as managing, editing, and viewing logic apps. To control their permissions, you can assign built-in or customized roles to members who have access to your Azure subscription. Azure Logic Apps has the following specific roles, based on whether you have a Consumption or Standard logic app workflow:
For example, suppose you have to work with a logic app workflow that you didn't create and authenticate connections used by that logic app workflow. Your Azure subscription requiresContributorpermissions for the resource group that contains that logic app resource. If you create a logic app resource, you automatically have Contributor access.
To prevent others from changing or deleting your logic app workflow, you can useAzure Resource Lock. This capability prevents others from changing or deleting production resources. For more information about connection security, reviewConnection configuration in Azure Logic AppsandConnection security and encryption.
Note
This capability is in preview and is subject to theSupplemental Terms of Use for Microsoft Azure Previews.

Access to run history data
During a logic app run, all the data isencrypted during transitby using Transport Layer Security (TLS) andat rest. When your logic app finishes running, you can view the history for that run, including the steps that ran along with the status, duration, inputs, and outputs for each action. This rich detail provides insight into how your logic app ran and where you might start troubleshooting any problems that arise.
When you view your logic app's run history, Azure Logic Apps authenticates your access and then provides links to the inputs and outputs for the requests and responses for each run. However, for actions that handle any passwords, secrets, keys, or other sensitive information, you want to prevent others from viewing and accessing that data. For example, if your logic app gets a secret fromAzure Key Vaultto use when authenticating an HTTP action, you want to hide that secret from view.
To control access to the inputs and outputs in your logic app's run history, you have these options:
Restrict access by IP address range.This option helps you secure access to run history based on the requests from a specific IP address range.
Restrict access by IP address range.
This option helps you secure access to run history based on the requests from a specific IP address range.
Secure data in run history by using obfuscation.In many triggers and actions, you can secure the inputs, outputs, or both in a logic app's run history.
Secure data in run history by using obfuscation.
In many triggers and actions, you can secure the inputs, outputs, or both in a logic app's run history.

Restrict access by IP address range
You can limit access to the inputs and outputs in the run history for your logic app workflows so that only requests from specific IP address ranges can view that data.
For example, to block anyone from accessing inputs and outputs, specify an IP address range such as0.0.0.0-0.0.0.0. Only a person with administrator permissions can remove this restriction, which provides the possibility for "just-in-time" access to data in your logic app workflows. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.x
0.0.0.0-0.0.0.0
To specify the allowed IP ranges, follow these steps for your Consumption or Standard logic app in the Azure portal or your Azure Resource Manager template:
Portal
Resource Manager Template
In theAzure portal, open your Consumption logic app workflow in the designer.
In theAzure portal, open your Consumption logic app workflow in the designer.
On the logic app menu, underSettings, selectWorkflow settings.
On the logic app menu, underSettings, selectWorkflow settings.
In theAccess control configurationsection, underAllowed inbound IP addresses, from theTrigger access optionlist, selectSpecific IP ranges.
In theAccess control configurationsection, underAllowed inbound IP addresses, from theTrigger access optionlist, selectSpecific IP ranges.
In theIP ranges for contentsbox, specify the IP address ranges that can access content from inputs and outputs.
In theIP ranges for contentsbox, specify the IP address ranges that can access content from inputs and outputs.
In theAzure portal, open your Standard logic app resource.
In theAzure portal, open your Standard logic app resource.
On the logic app menu, underSettings, selectNetworking.
On the logic app menu, underSettings, selectNetworking.
In theInbound traffic configurationsection, next toPublic network access, selectEnabled with no access restriction.
In theInbound traffic configurationsection, next toPublic network access, selectEnabled with no access restriction.
On theAccess restrictionspage, underApp access, selectEnabled from select virtual networks and IP addresses.
On theAccess restrictionspage, underApp access, selectEnabled from select virtual networks and IP addresses.
UnderSite access and rules, on theMain sitetab, add one or more rules to eitherAlloworDenyrequests from specific IP ranges. You can also use the HTTP header filter settings and forwarding settings. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.xFor more information, seeBlocking inbound IP addresses in Azure Logic Apps (Standard).
UnderSite access and rules, on theMain sitetab, add one or more rules to eitherAlloworDenyrequests from specific IP ranges. You can also use the HTTP header filter settings and forwarding settings. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.x
For more information, seeBlocking inbound IP addresses in Azure Logic Apps (Standard).
In your ARM template, specify the IP ranges by using theaccessControlsection with thecontentssection in your logic app's resource definition, for example:
accessControl
contents
{
   "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
   "contentVersion": "1.0.0.0",
   "parameters": {},
   "variables": {},
   "resources": [
      {
         "name": "[parameters('LogicAppName')]",
         "type": "Microsoft.Logic/workflows",
         "location": "[parameters('LogicAppLocation')]",
         "tags": {
            "displayName": "LogicApp"
         },
         "apiVersion": "2016-06-01",
         "properties": {
            "definition": {<workflow-definition>},
            "parameters": {},
            "accessControl": {
               "contents": {
                  "allowedCallerIpAddresses": [
                     {
                        "addressRange": "192.168.12.0/23"
                     },
                     {
                        "addressRange": "2001:0db8::/64"
                     }
                  ]
               }
            }
         }
      }
   ],
   "outputs": {}
}
{
   "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
   "contentVersion": "1.0.0.0",
   "parameters": {},
   "variables": {},
   "resources": [
      {
         "name": "[parameters('LogicAppName')]",
         "type": "Microsoft.Logic/workflows",
         "location": "[parameters('LogicAppLocation')]",
         "tags": {
            "displayName": "LogicApp"
         },
         "apiVersion": "2016-06-01",
         "properties": {
            "definition": {<workflow-definition>},
            "parameters": {},
            "accessControl": {
               "contents": {
                  "allowedCallerIpAddresses": [
                     {
                        "addressRange": "192.168.12.0/23"
                     },
                     {
                        "addressRange": "2001:0db8::/64"
                     }
                  ]
               }
            }
         }
      }
   ],
   "outputs": {}
}
In your ARM template, specify the allowed inbound IP address ranges in your logic app's resource definition by using theMicrosoft.Web/sites/configsection. In this section, underproperties, add theipSecurityRestrictionssection, and use theipAddress,action="Deny" | "Allow",tag=Default,priority, andname="Ports"sections to define a rule and set theipAddressto the allowed IP range inx.x.x.x/xorx.x.x.x-x.x.x.xformat, for example:
Microsoft.Web/sites/config
properties
ipSecurityRestrictions
ipAddress
action="Deny" | "Allow"
tag=Default
priority
name="Ports"
ipAddress
{
   "type": "Microsoft.Web/sites/config",
   "apiVersion": "2022-09-01",
   "name": "[concat(parameters('sites_My_Standard_Logic_App_name'), '/web')]",
   "location": "West US",
   "dependsOn": [
      "[resourceId('Microsoft.Web/sites', parameters('sites_My_Standard_Logic_App_name'))]"
   ],
   "tags": {
      "hidden-link: /app-insights-resource-id": "/subscriptions/{subscriptionID}/resourceGroups/Standard-RG/providers/Microsoft.Insights/components/My-Standard-Logic-App"
   },
   "properties": {
      "numberOfWorkers": 1,
      "defaultDocuments": [
         "Default.htm",
         "Default.html",
         "Default.asp",
         "index.htm",
         "index.html",
         "iisstart.htm",
         "default.aspx",
         "index.php"
      ],
      "netFrameworkVersion": "v6.0",
      "requestTracingEnabled": false,
      "remoteDebuggingEnabled": false,
      "httpLoggingEnabled": false,
      "acrUseManagedIdentityCreds": false,
      "logsDirectorySizeLimit": 35,
      "detailedErrorLoggingEnabled": false,
      "publishingUsername": "$My-Standard-Logic-App",
      "scmType": "None",
      "use32BitWorkerProcess": false,
      "webSocketsEnabled": false,
      "alwaysOn": false,
      "managedPipelineMode": "Integrated",
      "virtualApplications": [
         {
            "virtualPath": "/",
            "physicalPath": "site\\wwwroot",
            "preloadEnabled": false
         }
      ],
      "loadBalancing": "LeastRequests",
      "experiments": {
         "rampUpRules": []
      },
      "autoHealEnabled": false,
      "vnetRouteAllEnabled": false,
      "vnetPrivatePortsCount": 0,
      "publicNetworkAccess": "Enabled",
      "cors": {
         "supportCredentials": false
      },
      "localMySqlEnabled": false,
      "managedServiceIdentityId": 3065,
      "ipSecurityRestrictions": [
         {
            "ipAddress": "208.130.0.0/16",
            "action": "Deny",
            "tag": "Default",
            "priority": 100,
            "name": "Ports"
         },
         {
            "ipAddress": "Any",
            "action": "Deny",
            "priority": 2147483647,
            "name": "Deny all",
            "description": "Deny all access"
         }
      ],
      "ipSecurityRestrictionsDefaultAction": "Deny",
      "scmIpSecurityRestrictions": [
         {
            "ipAddress": "Any",
            "action": "Allow",
            "priority": 2147483647,
            "name": "Allow all",
            "description": "Allow all access"
         }
      ],
      "scmIpSecurityRestrictionsDefaultAction": "Allow",
      "scmIpSecurityRestrictionsUseMain": false,
      "http20Enabled": false,
      "minTlsVersion": "1.2",
      "scmMinTlsVersion": "1.2",
      "ftpsState": "FtpsOnly",
      "preWarmedInstanceCount": 1,
      "functionAppScaleLimit": 0,
      "functionsRuntimeScaleMonitoringEnabled": true,
      "minimumElasticInstanceCount": 1,
      "azureStorageAccounts": {}
   }
},
{
   "type": "Microsoft.Web/sites/config",
   "apiVersion": "2022-09-01",
   "name": "[concat(parameters('sites_My_Standard_Logic_App_name'), '/web')]",
   "location": "West US",
   "dependsOn": [
      "[resourceId('Microsoft.Web/sites', parameters('sites_My_Standard_Logic_App_name'))]"
   ],
   "tags": {
      "hidden-link: /app-insights-resource-id": "/subscriptions/{subscriptionID}/resourceGroups/Standard-RG/providers/Microsoft.Insights/components/My-Standard-Logic-App"
   },
   "properties": {
      "numberOfWorkers": 1,
      "defaultDocuments": [
         "Default.htm",
         "Default.html",
         "Default.asp",
         "index.htm",
         "index.html",
         "iisstart.htm",
         "default.aspx",
         "index.php"
      ],
      "netFrameworkVersion": "v6.0",
      "requestTracingEnabled": false,
      "remoteDebuggingEnabled": false,
      "httpLoggingEnabled": false,
      "acrUseManagedIdentityCreds": false,
      "logsDirectorySizeLimit": 35,
      "detailedErrorLoggingEnabled": false,
      "publishingUsername": "$My-Standard-Logic-App",
      "scmType": "None",
      "use32BitWorkerProcess": false,
      "webSocketsEnabled": false,
      "alwaysOn": false,
      "managedPipelineMode": "Integrated",
      "virtualApplications": [
         {
            "virtualPath": "/",
            "physicalPath": "site\\wwwroot",
            "preloadEnabled": false
         }
      ],
      "loadBalancing": "LeastRequests",
      "experiments": {
         "rampUpRules": []
      },
      "autoHealEnabled": false,
      "vnetRouteAllEnabled": false,
      "vnetPrivatePortsCount": 0,
      "publicNetworkAccess": "Enabled",
      "cors": {
         "supportCredentials": false
      },
      "localMySqlEnabled": false,
      "managedServiceIdentityId": 3065,
      "ipSecurityRestrictions": [
         {
            "ipAddress": "208.130.0.0/16",
            "action": "Deny",
            "tag": "Default",
            "priority": 100,
            "name": "Ports"
         },
         {
            "ipAddress": "Any",
            "action": "Deny",
            "priority": 2147483647,
            "name": "Deny all",
            "description": "Deny all access"
         }
      ],
      "ipSecurityRestrictionsDefaultAction": "Deny",
      "scmIpSecurityRestrictions": [
         {
            "ipAddress": "Any",
            "action": "Allow",
            "priority": 2147483647,
            "name": "Allow all",
            "description": "Allow all access"
         }
      ],
      "scmIpSecurityRestrictionsDefaultAction": "Allow",
      "scmIpSecurityRestrictionsUseMain": false,
      "http20Enabled": false,
      "minTlsVersion": "1.2",
      "scmMinTlsVersion": "1.2",
      "ftpsState": "FtpsOnly",
      "preWarmedInstanceCount": 1,
      "functionAppScaleLimit": 0,
      "functionsRuntimeScaleMonitoringEnabled": true,
      "minimumElasticInstanceCount": 1,
      "azureStorageAccounts": {}
   }
},

Secure data in run history by using obfuscation
Many triggers and actions have settings to secure inputs, outputs, or both from a logic app's run history. Allmanaged connectorsandcustom connectorssupport these options. However, the followingbuilt-in operationsdon't support these options:
Before using these settings to help you secure this data, review these considerations:
When you obscure the inputs or outputs on a trigger or action, Azure Logic Apps doesn't send the secured data to Azure Log Analytics. Also, you can't addtracked propertiesto that trigger or action for monitoring.
When you obscure the inputs or outputs on a trigger or action, Azure Logic Apps doesn't send the secured data to Azure Log Analytics. Also, you can't addtracked propertiesto that trigger or action for monitoring.
TheAzure Logic Apps API for handling workflow historydoesn't return secured outputs.
TheAzure Logic Apps API for handling workflow historydoesn't return secured outputs.
To secure outputs from an action that obscures inputs or explicitly obscures outputs, manually turn onSecure Outputsin that action.
To secure outputs from an action that obscures inputs or explicitly obscures outputs, manually turn onSecure Outputsin that action.
Make sure that you turn onSecure InputsorSecure Outputsin downstream actions where you expect the run history to obscure that data.Secure Outputs settingWhen you manually turn onSecure Outputsin a trigger or action, Azure Logic Apps hides these outputs in the run history. If a downstream action explicitly uses these secured outputs as inputs, Azure Logic Apps hides this action's inputs in the run history, butdoesn't enablethe action'sSecure Inputssetting.The Compose, Parse JSON, and Response actions has only theSecure Inputssetting. When turned on, the setting also hides these actions' outputs. If these actions explicitly use the upstream secured outputs as inputs, Azure Logic Apps hides these actions' inputs and outputs, butdoesn't enablethese actions'Secure Inputssetting. If a downstream action explicitly uses the hidden outputs from the Compose, Parse JSON, or Response actions as inputs, Azure Logic Appsdoesn't hide this downstream action's inputs or outputs.Secure Inputs settingWhen you manually turn onSecure Inputsin a trigger or action, Azure Logic Apps hides these inputs in the run history. If a downstream action explicitly uses the visible outputs from that trigger or action as inputs, Azure Logic Apps hides this downstream action's inputs in the run history, butdoesn't enableSecure Inputsin this action and doesn't hide this action's outputs.If the Compose, Parse JSON, and Response actions explicitly use the visible outputs from the trigger or action that has the secured inputs, Azure Logic Apps hides these actions' inputs and outputs, butdoesn't enablethese action'sSecure Inputssetting. If a downstream action explicitly uses the hidden outputs from the Compose, Parse JSON, or Response actions as inputs, Azure Logic Appsdoesn't hide this downstream action's inputs or outputs.
Make sure that you turn onSecure InputsorSecure Outputsin downstream actions where you expect the run history to obscure that data.
Secure Outputs setting
When you manually turn onSecure Outputsin a trigger or action, Azure Logic Apps hides these outputs in the run history. If a downstream action explicitly uses these secured outputs as inputs, Azure Logic Apps hides this action's inputs in the run history, butdoesn't enablethe action'sSecure Inputssetting.

The Compose, Parse JSON, and Response actions has only theSecure Inputssetting. When turned on, the setting also hides these actions' outputs. If these actions explicitly use the upstream secured outputs as inputs, Azure Logic Apps hides these actions' inputs and outputs, butdoesn't enablethese actions'Secure Inputssetting. If a downstream action explicitly uses the hidden outputs from the Compose, Parse JSON, or Response actions as inputs, Azure Logic Appsdoesn't hide this downstream action's inputs or outputs.

Secure Inputs setting
When you manually turn onSecure Inputsin a trigger or action, Azure Logic Apps hides these inputs in the run history. If a downstream action explicitly uses the visible outputs from that trigger or action as inputs, Azure Logic Apps hides this downstream action's inputs in the run history, butdoesn't enableSecure Inputsin this action and doesn't hide this action's outputs.

If the Compose, Parse JSON, and Response actions explicitly use the visible outputs from the trigger or action that has the secured inputs, Azure Logic Apps hides these actions' inputs and outputs, butdoesn't enablethese action'sSecure Inputssetting. If a downstream action explicitly uses the hidden outputs from the Compose, Parse JSON, or Response actions as inputs, Azure Logic Appsdoesn't hide this downstream action's inputs or outputs.

In theAzure portal, open your logic app workflow in the designer.
In theAzure portal, open your logic app workflow in the designer.
On the designer, select the trigger or action where you want to secure sensitive data.
On the designer, select the trigger or action where you want to secure sensitive data.
On the information pane that opens, selectSettings, and expandSecurity.
On the information pane that opens, selectSettings, and expandSecurity.

Turn on eitherSecure Inputs,Secure Outputs, or both.The trigger or action now shows a lock icon in the title bar. Any tokens that represent secured outputs from previous actions also show lock icons. For example, in a subsequent action, after you select a token for a secured output from the dynamic content list, that token shows a lock icon.
Turn on eitherSecure Inputs,Secure Outputs, or both.

The trigger or action now shows a lock icon in the title bar. Any tokens that represent secured outputs from previous actions also show lock icons. For example, in a subsequent action, after you select a token for a secured output from the dynamic content list, that token shows a lock icon.

After the workflow runs, you can view the history for that run.SelectOvervieweither on the Consumption logic app menu or on the Standard workflow menu.UnderRuns history, select the run that you want to view.On the workflow run history pane, select the actions that you want to review.If you chose to hide both inputs and outputs, those values now appear hidden.
After the workflow runs, you can view the history for that run.
SelectOvervieweither on the Consumption logic app menu or on the Standard workflow menu.
SelectOvervieweither on the Consumption logic app menu or on the Standard workflow menu.
UnderRuns history, select the run that you want to view.
UnderRuns history, select the run that you want to view.
On the workflow run history pane, select the actions that you want to review.If you chose to hide both inputs and outputs, those values now appear hidden.
On the workflow run history pane, select the actions that you want to review.
If you chose to hide both inputs and outputs, those values now appear hidden.


In the underlying trigger or action definition, add or update theruntimeConfiguration.secureData.propertiesarray with either or both of these values:
runtimeConfiguration.secureData.properties
"inputs": Secures inputs in run history.
"inputs"
"outputs": Secures outputs in run history.
"outputs"
"<trigger-or-action-name>": {
   "type": "<trigger-or-action-type>",
   "inputs": {
      <trigger-or-action-inputs>
   },
   "runtimeConfiguration": {
      "secureData": {
         "properties": [
            "inputs",
            "outputs"
         ]
      }
   },
   <other-attributes>
}
"<trigger-or-action-name>": {
   "type": "<trigger-or-action-type>",
   "inputs": {
      <trigger-or-action-inputs>
   },
   "runtimeConfiguration": {
      "secureData": {
         "properties": [
            "inputs",
            "outputs"
         ]
      }
   },
   <other-attributes>
}

Access to parameter inputs
If you deploy across different environments, consider parameterizing the values in your workflow definition that vary based on those environments. That way, you can avoid hard-coded data by using anAzure Resource Manager templateto deploy your logic app, protect sensitive data by defining secured parameters, and pass that data as separate inputs through thetemplate's parametersby using aparameter file.
For example, if you authenticate HTTP actions withOAuth with Microsoft Entra ID, you can define and obscure the parameters that accept the client ID and client secret that are used for authentication. To define these parameters in your logic app workflow, use theparameterssection in your logic app's workflow definition and Resource Manager template for deployment. To help secure parameter values that you don't want shown when editing your logic app or viewing run history, define the parameters by using thesecurestringorsecureobjecttype and use encoding as necessary. Parameters that have this type aren't returned with the resource definition and aren't accessible when viewing the resource after deployment. To access these parameter values during runtime, use the@parameters('<parameter-name>')expression inside your workflow definition. This expression is evaluated only at runtime and is described by theWorkflow Definition Language.
parameters
securestring
secureobject
@parameters('<parameter-name>')
Note
If you use a parameter in a request header or body, that parameter might be visible
when you view your workflow's run history and outgoing HTTP request. Make sure that
you also set your content access policies accordingly. You can also useobfuscationto hide inputs and outputs in your run history.
By default,Authorizationheaders aren't visible through inputs or outputs.
So if a secret is used there, that secret isn't retrievable.
Authorization
For more information, review these sections in this topic:
Secure parameters in workflow definitions
Secure data in run history by using obfuscation
If youautomate deployment for logic apps by using Resource Manager templates, you can define securedtemplate parameters, which are evaluated at deployment, by using thesecurestringandsecureobjecttypes. To define template parameters, use your template's top levelparameterssection, which is separate and different from your workflow definition'sparameterssection. To provide the values for template parameters, use a separateparameter file.
securestring
secureobject
parameters
parameters
For example, if you use secrets, you can define and use secured template parameters that retrieve those secrets fromAzure Key Vaultat deployment. You can then reference the key vault and secret in your parameter file. For more information, review these topics:
Pass sensitive values at deployment by using Azure Key Vault
Secure parameters in Azure Resource Manager templateslater in this topic

Secure parameters in workflow definitions (Consumption workflow)
To protect sensitive information in your logic app's workflow definition, use secured parameters so this information isn't visible after you save your logic app workflow. For example, suppose you have an HTTP action requires basic authentication, which uses a username and password. In the workflow definition, theparameterssection defines thebasicAuthPasswordParamandbasicAuthUsernameParamparameters by using thesecurestringtype. The action definition then references these parameters in theauthenticationsection.
parameters
basicAuthPasswordParam
basicAuthUsernameParam
securestring
authentication
Important
For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication when possible.
This option provides superior security without having to provide credentials. Azure manages this identity and helps keep
authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity
for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.
"definition": {
   "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",
   "actions": {
      "HTTP": {
         "type": "Http",
         "inputs": {
            "method": "GET",
            "uri": "https://www.microsoft.com",
            "authentication": {
               "type": "Basic",
               "username": "@parameters('basicAuthUsernameParam')",
               "password": "@parameters('basicAuthPasswordParam')"
            }
         },
         "runAfter": {}
      }
   },
   "parameters": {
      "basicAuthPasswordParam": {
         "type": "securestring"
      },
      "basicAuthUsernameParam": {
         "type": "securestring"
      }
   },
   "triggers": {
      "manual": {
         "type": "Request",
         "kind": "Http",
         "inputs": {
            "schema": {}
         }
      }
   },
   "contentVersion": "1.0.0.0",
   "outputs": {}
}
"definition": {
   "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",
   "actions": {
      "HTTP": {
         "type": "Http",
         "inputs": {
            "method": "GET",
            "uri": "https://www.microsoft.com",
            "authentication": {
               "type": "Basic",
               "username": "@parameters('basicAuthUsernameParam')",
               "password": "@parameters('basicAuthPasswordParam')"
            }
         },
         "runAfter": {}
      }
   },
   "parameters": {
      "basicAuthPasswordParam": {
         "type": "securestring"
      },
      "basicAuthUsernameParam": {
         "type": "securestring"
      }
   },
   "triggers": {
      "manual": {
         "type": "Request",
         "kind": "Http",
         "inputs": {
            "schema": {}
         }
      }
   },
   "contentVersion": "1.0.0.0",
   "outputs": {}
}

Secure parameters in Azure Resource Manager templates (Consumption workflow)
AResource Manager templatefor a logic app resource and workflow has multipleparameterssections. To protect passwords, keys, secrets, and other sensitive information, define secured parameters at the template level and workflow definition level by using thesecurestringorsecureobjecttype. You can then store these values inAzure Key Vaultand use theparameter fileto reference the key vault and secret. Your template then retrieves that information at deployment. For more information, reviewPass sensitive values at deployment by using Azure Key Vault.
parameters
securestring
secureobject
Important
For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication when possible.
This option provides superior security without having to provide credentials. Azure manages this identity and helps keep
authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity
for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.
This list includes more information about theseparameterssections:
parameters
At the template's top level, aparameterssection defines the parameters for the values that the template uses atdeployment. For example, these values can include connection strings for a specific deployment environment. You can then store these values in a separateparameter file, which makes changing these values easier.
At the template's top level, aparameterssection defines the parameters for the values that the template uses atdeployment. For example, these values can include connection strings for a specific deployment environment. You can then store these values in a separateparameter file, which makes changing these values easier.
parameters
Inside your logic app's resource definition, but outside your workflow definition, aparameterssection specifies the values for your workflow definition's parameters. In this section, you can assign these values by using template expressions that reference your template's parameters. These expressions are evaluated at deployment.
Inside your logic app's resource definition, but outside your workflow definition, aparameterssection specifies the values for your workflow definition's parameters. In this section, you can assign these values by using template expressions that reference your template's parameters. These expressions are evaluated at deployment.
parameters
Inside your workflow definition, aparameterssection defines the parameters that your logic app workflow uses at runtime. You can then reference these parameters inside your logic app's workflow by using workflow definition expressions, which are evaluated at runtime.
Inside your workflow definition, aparameterssection defines the parameters that your logic app workflow uses at runtime. You can then reference these parameters inside your logic app's workflow by using workflow definition expressions, which are evaluated at runtime.
parameters
This example template that has multiple secured parameter definitions that use thesecurestringtype:
securestring
TemplatePasswordParam
basicAuthPasswordParam
TemplateUsernameParam
basicAuthUserNameParam
basicAuthPasswordParam
basicAuthUserNameParam
{
   "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
   "contentVersion": "1.0.0.0",
   "parameters": {
      "LogicAppName": {
         "type": "string",
         "minLength": 1,
         "maxLength": 80,
         "metadata": {
            "description": "Name of the Logic App."
         }
      },
      "TemplatePasswordParam": {
         "type": "securestring"
      },
      "TemplateUsernameParam": {
         "type": "securestring"
      },
      "LogicAppLocation": {
         "type": "string",
         "defaultValue": "[resourceGroup().location]",
         "allowedValues": [
            "[resourceGroup().location]",
            "eastasia",
            "southeastasia",
            "centralus",
            "eastus",
            "eastus2",
            "westus",
            "northcentralus",
            "southcentralus",
            "northeurope",
            "westeurope",
            "japanwest",
            "japaneast",
            "brazilsouth",
            "australiaeast",
            "australiasoutheast",
            "southindia",
            "centralindia",
            "westindia",
            "canadacentral",
            "canadaeast",
            "uksouth",
            "ukwest",
            "westcentralus",
            "westus2"
         ],
         "metadata": {
            "description": "Location of the Logic App."
         }
      }
   },
   "variables": {},
   "resources": [
      {
         "name": "[parameters('LogicAppName')]",
         "type": "Microsoft.Logic/workflows",
         "location": "[parameters('LogicAppLocation')]",
         "tags": {
            "displayName": "LogicApp"
         },
         "apiVersion": "2016-06-01",
         "properties": {
            "definition": {
               "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",
               "actions": {
                  "HTTP": {
                     "type": "Http",
                     "inputs": {
                        "method": "GET",
                        "uri": "https://www.microsoft.com",
                        "authentication": {
                           "type": "Basic",
                           "username": "@parameters('basicAuthUsernameParam')",
                           "password": "@parameters('basicAuthPasswordParam')"
                        }
                     },
                  "runAfter": {}
                  }
               },
               "parameters": {
                  "basicAuthPasswordParam": {
                     "type": "securestring"
                  },
                  "basicAuthUsernameParam": {
                     "type": "securestring"
                  }
               },
               "triggers": {
                  "manual": {
                     "type": "Request",
                     "kind": "Http",
                     "inputs": {
                        "schema": {}
                     }
                  }
               },
               "contentVersion": "1.0.0.0",
               "outputs": {}
            },
            "parameters": {
               "basicAuthPasswordParam": {
                  "value": "[parameters('TemplatePasswordParam')]"
               },
               "basicAuthUsernameParam": {
                  "value": "[parameters('TemplateUsernameParam')]"
               }
            }
         }
      }
   ],
   "outputs": {}
}
{
   "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
   "contentVersion": "1.0.0.0",
   "parameters": {
      "LogicAppName": {
         "type": "string",
         "minLength": 1,
         "maxLength": 80,
         "metadata": {
            "description": "Name of the Logic App."
         }
      },
      "TemplatePasswordParam": {
         "type": "securestring"
      },
      "TemplateUsernameParam": {
         "type": "securestring"
      },
      "LogicAppLocation": {
         "type": "string",
         "defaultValue": "[resourceGroup().location]",
         "allowedValues": [
            "[resourceGroup().location]",
            "eastasia",
            "southeastasia",
            "centralus",
            "eastus",
            "eastus2",
            "westus",
            "northcentralus",
            "southcentralus",
            "northeurope",
            "westeurope",
            "japanwest",
            "japaneast",
            "brazilsouth",
            "australiaeast",
            "australiasoutheast",
            "southindia",
            "centralindia",
            "westindia",
            "canadacentral",
            "canadaeast",
            "uksouth",
            "ukwest",
            "westcentralus",
            "westus2"
         ],
         "metadata": {
            "description": "Location of the Logic App."
         }
      }
   },
   "variables": {},
   "resources": [
      {
         "name": "[parameters('LogicAppName')]",
         "type": "Microsoft.Logic/workflows",
         "location": "[parameters('LogicAppLocation')]",
         "tags": {
            "displayName": "LogicApp"
         },
         "apiVersion": "2016-06-01",
         "properties": {
            "definition": {
               "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",
               "actions": {
                  "HTTP": {
                     "type": "Http",
                     "inputs": {
                        "method": "GET",
                        "uri": "https://www.microsoft.com",
                        "authentication": {
                           "type": "Basic",
                           "username": "@parameters('basicAuthUsernameParam')",
                           "password": "@parameters('basicAuthPasswordParam')"
                        }
                     },
                  "runAfter": {}
                  }
               },
               "parameters": {
                  "basicAuthPasswordParam": {
                     "type": "securestring"
                  },
                  "basicAuthUsernameParam": {
                     "type": "securestring"
                  }
               },
               "triggers": {
                  "manual": {
                     "type": "Request",
                     "kind": "Http",
                     "inputs": {
                        "schema": {}
                     }
                  }
               },
               "contentVersion": "1.0.0.0",
               "outputs": {}
            },
            "parameters": {
               "basicAuthPasswordParam": {
                  "value": "[parameters('TemplatePasswordParam')]"
               },
               "basicAuthUsernameParam": {
                  "value": "[parameters('TemplateUsernameParam')]"
               }
            }
         }
      }
   ],
   "outputs": {}
}

Authentication types for connectors that support authentication
The following table identifies the authentication types that are available on the connector operations where you can select an authentication type:
Important
For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication when possible.
This option provides superior security without having to provide credentials. Azure manages this identity and helps keep
authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity
for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.

Access for inbound calls to request-based triggers
Inbound calls that a logic app receives through a request-based trigger, such as theRequesttriggerorHTTP Webhooktrigger, support encryption and are secured withTransport Layer Security (TLS) 1.2 at minimum, previously known as Secure Sockets Layer (SSL). Azure Logic Apps enforces this version when receiving an inbound call to aRequesttrigger or a callback to the HTTP Webhook trigger or action.
Note
If you get TLS handshake errors, make sure that you use TLS 1.2. For more information, seeSolving the TLS 1.0 problem.
For inbound calls, use the following cipher suites:
TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
Important
For backward compatibility, Azure Logic Apps currently supports some older cipher suites. However,don't useolder cipher suites when you develop new apps because such suitesmight notbe supported in the future.
For example, you might find the following cipher suites if you inspect the TLS handshake messages in Azure
Logic Apps or by using a security tool on your logic app's URL. Again,don't usethese older suites:
TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
TLS_RSA_WITH_AES_256_GCM_SHA384
TLS_RSA_WITH_AES_128_GCM_SHA256
TLS_RSA_WITH_AES_256_CBC_SHA256
TLS_RSA_WITH_AES_128_CBC_SHA256
TLS_RSA_WITH_AES_256_CBC_SHA
TLS_RSA_WITH_AES_128_CBC_SHA
TLS_RSA_WITH_3DES_EDE_CBC_SHA
The following list includes ways that you can limit access to triggers that receive inbound calls to your logic app workflow so that only authorized clients can call your workflow:
Enable OAuth with Microsoft Entra ID
Generate shared access signature (SAS) keys or tokens
Disable shared access signature (SAS) authentication
Restrict inbound IP addresses
Expose your logic app with Azure API Management

Enable OAuth 2.0 with Microsoft Entra ID
In a Consumption workflow that starts with a request-based trigger, you can authenticate and authorize inbound calls sent to the endpoint created by that trigger by enablingOAuth 2.0 with Microsoft Entra ID. To set up this authentication,define or add an authorization policy at the logic app resource level. This way, inbound calls useOAuth access tokensfor authorization.
When your logic app workflow receives an inbound request that includes an OAuth access token, Azure Logic Apps compares the token's claims against the claims specified by each authorization policy. If a match exists between the token's claims and all the claims in at least one policy, authorization succeeds for the inbound request. The token can have more claims than the number specified by the authorization policy.
In a Standard workflow that starts with theRequesttrigger (but not a webhook trigger), you can use the Azure Functions provision for authenticating inbound calls sent to the endpoint created by theRequesttrigger by using a managed identity. This provision is also known as "Easy Auth". For more information, seeTrigger workflows in Standard logic apps with Easy Auth.

For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication when possible. This option provides superior security without having to provide credentials. Azure manages this identity and helps keep authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.
For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication when possible. This option provides superior security without having to provide credentials. Azure manages this identity and helps keep authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.
In Consumption workflows, inbound calls to the endpoint URL for a request-based trigger can use only one authorization scheme, eitherOAuth 2.0 with Microsoft Entra IDorShared Access Signature (SAS). Although using one scheme doesn't disable the other scheme, if you use both schemes at the same time, Azure Logic Apps generates an error because the service doesn't know which scheme to choose. If your Consumption workflow starts with theRequesttrigger, you candisable SAS authenticationas well asrestrict authorization to use only OAuth 2.0 with Microsoft Entra ID. For Standard workflows, you can use other authentication types without disabling SAS.
In Consumption workflows, inbound calls to the endpoint URL for a request-based trigger can use only one authorization scheme, eitherOAuth 2.0 with Microsoft Entra IDorShared Access Signature (SAS). Although using one scheme doesn't disable the other scheme, if you use both schemes at the same time, Azure Logic Apps generates an error because the service doesn't know which scheme to choose. If your Consumption workflow starts with theRequesttrigger, you candisable SAS authenticationas well asrestrict authorization to use only OAuth 2.0 with Microsoft Entra ID. For Standard workflows, you can use other authentication types without disabling SAS.
Azure Logic Apps supports either thebearer typeorproof-of-possession type (Consumption logic app only)authorization schemes for Microsoft Entra ID OAuth access tokens. However, theAuthorizationheader for the access token must specify either theBearertype orPoPtype. For more information about how to get and use a PoP token, seeGet a Proof of Possession (PoP) token.
Azure Logic Apps supports either thebearer typeorproof-of-possession type (Consumption logic app only)authorization schemes for Microsoft Entra ID OAuth access tokens. However, theAuthorizationheader for the access token must specify either theBearertype orPoPtype. For more information about how to get and use a PoP token, seeGet a Proof of Possession (PoP) token.
Authorization
Bearer
PoP
Your Consumption logic app resource is limited to a maximum number of authorization policies. Each authorization policy also has a maximum number ofclaims. For more information, seeLimits and configuration for Azure Logic Apps.
Your Consumption logic app resource is limited to a maximum number of authorization policies. Each authorization policy also has a maximum number ofclaims. For more information, seeLimits and configuration for Azure Logic Apps.
An authorization policy must include at least theIssuerclaim, which has a value that starts with eitherhttps://sts.windows.net/orhttps://login.microsoftonline.com/(OAuth V2) as the issuer for Microsoft Entra ID.For example, suppose that your logic app resource has an authorization policy that requires two claim types,AudienceandIssuer. This samplepayload sectionfor a decoded access token includes both claim types whereaudis theAudiencevalue andissis theIssuervalue:{
    "aud": "https://management.core.windows.net/",
    "iss": "https://sts.windows.net/<Azure-AD-issuer-ID>/",
    "iat": 1582056988,
    "nbf": 1582056988,
    "exp": 1582060888,
    "_claim_names": {
       "groups": "src1"
    },
    "_claim_sources": {
       "src1": {
          "endpoint": "https://graph.windows.net/7200000-86f1-41af-91ab-2d7cd011db47/users/00000-f433-403e-b3aa-7d8406464625d7/getMemberObjects"
       }
    },
    "acr": "1",
    "aio": "AVQAq/8OAAAA7k1O1C2fRfeG604U9e6EzYcy52wb65Cx2OkaHIqDOkuyyr0IBa/YuaImaydaf/twVaeW/etbzzlKFNI4Q=",
    "amr": [
       "rsa",
       "mfa"
    ],
    "appid": "c44b4083-3bb0-00001-b47d-97400853cbdf3c",
    "appidacr": "2",
    "deviceid": "bfk817a1-3d981-4dddf82-8ade-2bddd2f5f8172ab",
    "family_name": "Sophia Owen",
    "given_name": "Sophia Owen (Fabrikam)",
    "ipaddr": "167.220.2.46",
    "name": "sophiaowen",
    "oid": "3d5053d9-f433-00000e-b3aa-7d84041625d7",
    "onprem_sid": "S-1-5-21-2497521184-1604012920-1887927527-21913475",
    "puid": "1003000000098FE48CE",
    "scp": "user_impersonation",
    "sub": "KGlhIodTx3XCVIWjJarRfJbsLX9JcdYYWDPkufGVij7_7k",
    "tid": "aaaabbbb-0000-cccc-1111-dddd2222eeee",
    "unique_name": "SophiaOwen@fabrikam.com",
    "upn": "SophiaOwen@fabrikam.com",
    "uti": "TPJ7nNNMMZkOSx6_uVczUAA",
    "ver": "1.0"
}
An authorization policy must include at least theIssuerclaim, which has a value that starts with eitherhttps://sts.windows.net/orhttps://login.microsoftonline.com/(OAuth V2) as the issuer for Microsoft Entra ID.
https://sts.windows.net/
https://login.microsoftonline.com/
For example, suppose that your logic app resource has an authorization policy that requires two claim types,AudienceandIssuer. This samplepayload sectionfor a decoded access token includes both claim types whereaudis theAudiencevalue andissis theIssuervalue:
aud
iss
{
    "aud": "https://management.core.windows.net/",
    "iss": "https://sts.windows.net/<Azure-AD-issuer-ID>/",
    "iat": 1582056988,
    "nbf": 1582056988,
    "exp": 1582060888,
    "_claim_names": {
       "groups": "src1"
    },
    "_claim_sources": {
       "src1": {
          "endpoint": "https://graph.windows.net/7200000-86f1-41af-91ab-2d7cd011db47/users/00000-f433-403e-b3aa-7d8406464625d7/getMemberObjects"
       }
    },
    "acr": "1",
    "aio": "AVQAq/8OAAAA7k1O1C2fRfeG604U9e6EzYcy52wb65Cx2OkaHIqDOkuyyr0IBa/YuaImaydaf/twVaeW/etbzzlKFNI4Q=",
    "amr": [
       "rsa",
       "mfa"
    ],
    "appid": "c44b4083-3bb0-00001-b47d-97400853cbdf3c",
    "appidacr": "2",
    "deviceid": "bfk817a1-3d981-4dddf82-8ade-2bddd2f5f8172ab",
    "family_name": "Sophia Owen",
    "given_name": "Sophia Owen (Fabrikam)",
    "ipaddr": "167.220.2.46",
    "name": "sophiaowen",
    "oid": "3d5053d9-f433-00000e-b3aa-7d84041625d7",
    "onprem_sid": "S-1-5-21-2497521184-1604012920-1887927527-21913475",
    "puid": "1003000000098FE48CE",
    "scp": "user_impersonation",
    "sub": "KGlhIodTx3XCVIWjJarRfJbsLX9JcdYYWDPkufGVij7_7k",
    "tid": "aaaabbbb-0000-cccc-1111-dddd2222eeee",
    "unique_name": "SophiaOwen@fabrikam.com",
    "upn": "SophiaOwen@fabrikam.com",
    "uti": "TPJ7nNNMMZkOSx6_uVczUAA",
    "ver": "1.0"
}
{
    "aud": "https://management.core.windows.net/",
    "iss": "https://sts.windows.net/<Azure-AD-issuer-ID>/",
    "iat": 1582056988,
    "nbf": 1582056988,
    "exp": 1582060888,
    "_claim_names": {
       "groups": "src1"
    },
    "_claim_sources": {
       "src1": {
          "endpoint": "https://graph.windows.net/7200000-86f1-41af-91ab-2d7cd011db47/users/00000-f433-403e-b3aa-7d8406464625d7/getMemberObjects"
       }
    },
    "acr": "1",
    "aio": "AVQAq/8OAAAA7k1O1C2fRfeG604U9e6EzYcy52wb65Cx2OkaHIqDOkuyyr0IBa/YuaImaydaf/twVaeW/etbzzlKFNI4Q=",
    "amr": [
       "rsa",
       "mfa"
    ],
    "appid": "c44b4083-3bb0-00001-b47d-97400853cbdf3c",
    "appidacr": "2",
    "deviceid": "bfk817a1-3d981-4dddf82-8ade-2bddd2f5f8172ab",
    "family_name": "Sophia Owen",
    "given_name": "Sophia Owen (Fabrikam)",
    "ipaddr": "167.220.2.46",
    "name": "sophiaowen",
    "oid": "3d5053d9-f433-00000e-b3aa-7d84041625d7",
    "onprem_sid": "S-1-5-21-2497521184-1604012920-1887927527-21913475",
    "puid": "1003000000098FE48CE",
    "scp": "user_impersonation",
    "sub": "KGlhIodTx3XCVIWjJarRfJbsLX9JcdYYWDPkufGVij7_7k",
    "tid": "aaaabbbb-0000-cccc-1111-dddd2222eeee",
    "unique_name": "SophiaOwen@fabrikam.com",
    "upn": "SophiaOwen@fabrikam.com",
    "uti": "TPJ7nNNMMZkOSx6_uVczUAA",
    "ver": "1.0"
}

For request-based endpoints, you can restrict authorization to use onlyOAuth 2.0 with Microsoft Entra ID. This option works even if you alsodisable shared access signature (SAS) authentication.
For your Consumption workflow, set up yourRequesttrigger orHTTP Webhooktrigger with the capability to check the OAuth access token byfollowing the steps to include the 'Authorization' header in the Request or HTTP webhook trigger outputs.NoteThis step makes theAuthorizationheader visible in the workflow's run history and in the trigger's outputs.
For your Consumption workflow, set up yourRequesttrigger orHTTP Webhooktrigger with the capability to check the OAuth access token byfollowing the steps to include the 'Authorization' header in the Request or HTTP webhook trigger outputs.
Note
This step makes theAuthorizationheader visible in the workflow's run history and in the trigger's outputs.
Authorization
In theAzure portal, open your Consumption workflow in the designer.
In theAzure portal, open your Consumption workflow in the designer.
On the designer, select the trigger. On the information pane that opens, selectSettings.
On the designer, select the trigger. On the information pane that opens, selectSettings.
UnderGeneral>Trigger conditions, selectAdd. In the trigger condition box, enter either of the following expressions, based on the token type that you want to use:@startsWith(triggerOutputs()?['headers']?['Authorization'], 'Bearer')-or-@startsWith(triggerOutputs()?['headers']?['Authorization'], 'PoP')
UnderGeneral>Trigger conditions, selectAdd. In the trigger condition box, enter either of the following expressions, based on the token type that you want to use:
@startsWith(triggerOutputs()?['headers']?['Authorization'], 'Bearer')
@startsWith(triggerOutputs()?['headers']?['Authorization'], 'Bearer')
-or-
@startsWith(triggerOutputs()?['headers']?['Authorization'], 'PoP')
@startsWith(triggerOutputs()?['headers']?['Authorization'], 'PoP')
If you call the trigger endpoint without the correct authorization, the run history just shows the trigger asSkippedwithout any message that the trigger condition has failed.
Skipped

The Microsoft Authentication Library (MSAL) libraries provide PoP tokens for you to use. If the Consumption logic app workflow that you want to call requires a PoP token, you can get this token using the MSAL libraries. The following samples show how to acquire PoP tokens:
A .NET Core daemon console application calling a protected Web API with its own identity
A .NET Core daemon console application calling a protected Web API with its own identity
SignedHttpRequest, also known as PoP (Proof of Possession)
SignedHttpRequest, also known as PoP (Proof of Possession)
To use the PoP token with your Consumption logic app workflow,follow the steps to set up OAuth with Microsoft Entra ID.

To add an authorization policy to your Consumption logic app, follow the steps for either the Azure portal or Azure Resource Manager template:

Portal
Resource Manager Template
In theAzure portal, open your Consumption logic app and workflow in the designer.
In theAzure portal, open your Consumption logic app and workflow in the designer.
On the logic app menu, underSettings, selectAuthorization.
On the logic app menu, underSettings, selectAuthorization.
On theAuthorizationpage, selectAdd policy.
On theAuthorizationpage, selectAdd policy.

Provide information about the authorization policy by specifying theclaim typesand values that your logic app expects in the access token presented by each inbound call to theRequesttrigger:PropertyRequiredTypeDescriptionPolicy nameYesStringThe name that you want to use for the authorization policyPolicy typeYesStringEitherAADfor bearer type tokens orAADPOPfor Proof-of-Possession type tokens.ClaimsYesStringA key-value pair that specifies the claim type and value that the workflow's Request trigger expects in the access token presented by each inbound call to the trigger. You can add any standard claim you want by selectingAdd standard claim. To add a claim that's specific to a PoP token, selectAdd custom claim.Available standard claim types:-Issuer-Audience-Subject-JWT ID(JSON Web Token identifier)Requirements:- At a minimum, theClaimslist must include theIssuerclaim, which has a value that starts withhttps://sts.windows.net/orhttps://login.microsoftonline.com/as the Microsoft Entra issuer ID.- Each claim must be a single string value, not an array of values. For example, you can have a claim withRoleas the type andDeveloperas the value. You can't have a claim that hasRoleas the type and the values set toDeveloperandProgram Manager.- The claim value is limited to amaximum number of characters.For more information about these claim types, reviewClaims in Microsoft Entra security tokens. You can also specify your own claim type and value.The following example shows the information for a PoP token:
Provide information about the authorization policy by specifying theclaim typesand values that your logic app expects in the access token presented by each inbound call to theRequesttrigger:

https://sts.windows.net/
https://login.microsoftonline.com/
The following example shows the information for a PoP token:

To add another claim, select from these options:To add another claim type, selectAdd standard claim, select the claim type, and specify the claim value.To add your own claim, selectAdd custom claim. For more information, reviewhow to provide optional claims to your app. Your custom claim is then stored as a part of your JWT ID; for example,"tid": "aaaabbbb-0000-cccc-1111-dddd2222eeee".
To add another claim, select from these options:
To add another claim type, selectAdd standard claim, select the claim type, and specify the claim value.
To add another claim type, selectAdd standard claim, select the claim type, and specify the claim value.
To add your own claim, selectAdd custom claim. For more information, reviewhow to provide optional claims to your app. Your custom claim is then stored as a part of your JWT ID; for example,"tid": "aaaabbbb-0000-cccc-1111-dddd2222eeee".
To add your own claim, selectAdd custom claim. For more information, reviewhow to provide optional claims to your app. Your custom claim is then stored as a part of your JWT ID; for example,"tid": "aaaabbbb-0000-cccc-1111-dddd2222eeee".
"tid": "aaaabbbb-0000-cccc-1111-dddd2222eeee"
To add another authorization policy, selectAdd policy. Repeat the previous steps to set up the policy.
To add another authorization policy, selectAdd policy. Repeat the previous steps to set up the policy.
When you're done, selectSave.
When you're done, selectSave.
To include theAuthorizationheader from the access token in the request-based trigger outputs, reviewInclude 'Authorization' header in request and HTTP webhook trigger outputs.
To include theAuthorizationheader from the access token in the request-based trigger outputs, reviewInclude 'Authorization' header in request and HTTP webhook trigger outputs.
Authorization
Workflow properties such as policies don't appear in your workflow's code view in the Azure portal. To access your policies programmatically, call the following API through Azure Resource Manager:https://management.azure.com/subscriptions/{Azure-subscription-ID}/resourceGroups/{Azure-resource-group-name}/providers/Microsoft.Logic/workflows/{your-workflow-name}?api-version=2016-10-01&_=1612212851820. Make sure that you replace the placeholder values for your Azure subscription ID, resource group name, and workflow name.
https://management.azure.com/subscriptions/{Azure-subscription-ID}/resourceGroups/{Azure-resource-group-name}/providers/Microsoft.Logic/workflows/{your-workflow-name}?api-version=2016-10-01&_=1612212851820

In your ARM template, define an authorization policy following these steps and syntax below:
In thepropertiessection for yourlogic app's resource definition, add anaccessControlobject, if none exists, that contains atriggersobject.For more information about theaccessControlobject, reviewRestrict inbound IP ranges in Azure Resource Manager templateandMicrosoft.Logic workflows template reference.
In thepropertiessection for yourlogic app's resource definition, add anaccessControlobject, if none exists, that contains atriggersobject.
properties
accessControl
triggers
For more information about theaccessControlobject, reviewRestrict inbound IP ranges in Azure Resource Manager templateandMicrosoft.Logic workflows template reference.
accessControl
In thetriggersobject, add anopenAuthenticationPoliciesobject that contains thepoliciesobject where you define one or more authorization policies.
In thetriggersobject, add anopenAuthenticationPoliciesobject that contains thepoliciesobject where you define one or more authorization policies.
triggers
openAuthenticationPolicies
policies
Provide a name for authorization policy, set the policy type toAAD, and include aclaimsarray where you specify one or more claim types.At a minimum, theclaimsarray must include the Issuer claim type where you set the claim'snameproperty toissand set thevalueto start withhttps://sts.windows.net/orhttps://login.microsoftonline.com/as the Microsoft Entra issuer ID. For more information about these claim types, seeClaims in Microsoft Entra security tokens. You can also specify your own claim type and value.
Provide a name for authorization policy, set the policy type toAAD, and include aclaimsarray where you specify one or more claim types.
AAD
claims
At a minimum, theclaimsarray must include the Issuer claim type where you set the claim'snameproperty toissand set thevalueto start withhttps://sts.windows.net/orhttps://login.microsoftonline.com/as the Microsoft Entra issuer ID. For more information about these claim types, seeClaims in Microsoft Entra security tokens. You can also specify your own claim type and value.
claims
name
iss
value
https://sts.windows.net/
https://login.microsoftonline.com/
To include theAuthorizationheader from the access token in the request-based trigger outputs, seeInclude 'Authorization' header in request trigger outputs.
To include theAuthorizationheader from the access token in the request-based trigger outputs, seeInclude 'Authorization' header in request trigger outputs.
Authorization
Here's the syntax to follow:
"resources": [
   {
      // Start logic app resource definition
      "properties": {
         "state": "<Enabled-or-Disabled>",
         "definition": {<workflow-definition>},
         "parameters": {<workflow-definition-parameter-values>},
         "accessControl": {
            "triggers": {
               "openAuthenticationPolicies": {
                  "policies": {
                     "<policy-name>": {
                        "type": "AAD",
                        "claims": [
                           {
                              "name": "<claim-name>",
                              "value": "<claim-value>"
                           }
                        ]
                     }
                  }
               }
            },
         },
      },
      "name": "[parameters('LogicAppName')]",
      "type": "Microsoft.Logic/workflows",
      "location": "[parameters('LogicAppLocation')]",
      "apiVersion": "2016-06-01",
      "dependsOn": [
      ]
   }
   // End logic app resource definition
],
"resources": [
   {
      // Start logic app resource definition
      "properties": {
         "state": "<Enabled-or-Disabled>",
         "definition": {<workflow-definition>},
         "parameters": {<workflow-definition-parameter-values>},
         "accessControl": {
            "triggers": {
               "openAuthenticationPolicies": {
                  "policies": {
                     "<policy-name>": {
                        "type": "AAD",
                        "claims": [
                           {
                              "name": "<claim-name>",
                              "value": "<claim-value>"
                           }
                        ]
                     }
                  }
               }
            },
         },
      },
      "name": "[parameters('LogicAppName')]",
      "type": "Microsoft.Logic/workflows",
      "location": "[parameters('LogicAppLocation')]",
      "apiVersion": "2016-06-01",
      "dependsOn": [
      ]
   }
   // End logic app resource definition
],

For logic apps thatenable OAuth with Microsoft Entra IDfor authorizing inbound calls to access request-based triggers, you can enable theRequesttrigger orHTTP Webhooktrigger outputs to include theAuthorizationheader from the OAuth access token. In the trigger's underlying JSON definition, add and set theoperationOptionsproperty toIncludeAuthorizationHeadersInOutputs. Here's an example for theRequesttrigger:
Authorization
operationOptions
IncludeAuthorizationHeadersInOutputs
"triggers": {
   "manual": {
      "inputs": {
         "schema": {}
      },
      "kind": "Http",
      "type": "Request",
      "operationOptions": "IncludeAuthorizationHeadersInOutputs"
   }
}
"triggers": {
   "manual": {
      "inputs": {
         "schema": {}
      },
      "kind": "Http",
      "type": "Request",
      "operationOptions": "IncludeAuthorizationHeadersInOutputs"
   }
}
For more information, review these topics:
Schema reference for trigger and action types - Request trigger
Schema reference for trigger and action types - HTTP Webhook trigger
Schema reference for trigger and action types - Operation options

Generate a shared access signature (SAS) key or token
When a workflow starts with a request-based trigger, and you save that workflow for the first time, Azure Logic Apps creates a callable endpoint on that trigger. This endpoint has a URL that can receive inbound calls or requests to start the workflow. The URL includes aShared Access Signature (SAS), which is a key or token that grants permissions, for example, to storage services. This endpoint URL uses the following format:
https://<request-endpoint-URI>sp=<permissions>sv=<SAS-version>sig=<signature>
https://<request-endpoint-URI>sp=<permissions>sv=<SAS-version>sig=<signature>
For example, to view this URL in aRequesttrigger, find the trigger'sHTTP URLproperty:

The complete URL looks like the following example:
https://{domain}:443/workflows/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/triggers/When_a_HTTP_request_is_received/paths/invoke?api-version=2016-10-01&sp=%2Ftriggers%2FWhen_a_HTTP_request_is_received%2Frun&sv=1.0&sig=ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
https://{domain}:443/workflows/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/triggers/When_a_HTTP_request_is_received/paths/invoke?api-version=2016-10-01&sp=%2Ftriggers%2FWhen_a_HTTP_request_is_received%2Frun&sv=1.0&sig=ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
The SAS in the URL has query parameters, which the following table describes:
sp
sv
sig
Important
Make sure to protect your SAS key just as you protect an account key from unauthorized use. Set up or have a plan
for revoking a compromised access key. Use discretion when you distribute URIs that use access keys, and only
distribute such URIs over a secure connection such as HTTPS. Make sure to only perform operations that use an access
key over an HTTPS connection. Anyone that has a URI with valid key can access the associated resource. To maintain
security and protect access to your logic app workflow,regenerate access keyson a regular
schedule as they might need to comply with security policies or become compromised. This way, you can make sure that
only authorized requests can trigger your workflow, which protects your data and processes from unauthorized access.
If you use an SAS key to access storage services, Microsoft recommends that youcreate a user delegation SAS,
which is secured withMicrosoft Entra ID,
rather than an account key.
For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication whenever possible.
This option provides superior security without having to provide credentials. Azure manages this identity and helps keep
authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity
for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.
Inbound calls to the endpoint on a request-based trigger can use only one authorization scheme, either SAS orOAuth 2.0 with Microsoft Entra ID. Although using one scheme doesn't disable the other, if you use both schemes at the same time, Azure Logic Apps generates an error because the service doesn't know which scheme to choose.
If you have a Consumption workflow that starts with theRequesttrigger, you candisable SAS authentication. This option works even if you alsorestrict authorization to use only OAuth 2.0 with Microsoft Entra ID. For Standard workflows, you can use other authentication types without disabling SAS.
For more information about security when you use an SAS key, see the following sections in this guide:
Regenerate access keys
Create expiring callback URLs
Create URLs with primary or secondary key

Disable shared access signature (SAS) authentication (Consumption only)
By default, a request-based trigger has SAS authentication enabled. The trigger's endpoint URL includes an SAS, starting with the query parameters,sp-<permissions>sv-<SAS-version>sig=<signature>, for example:
sp-<permissions>sv-<SAS-version>sig=<signature>
https://{domain}:443/workflows/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/triggers/When_a_HTTP_request_is_received/paths/invoke?api-version=2016-10-01&sp=%2Ftriggers%2FWhen_a_HTTP_request_is_received%2Frun&sv=1.0&sig=ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
https://{domain}:443/workflows/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/triggers/When_a_HTTP_request_is_received/paths/invoke?api-version=2016-10-01&sp=%2Ftriggers%2FWhen_a_HTTP_request_is_received%2Frun&sv=1.0&sig=ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
If your Consumption workflow starts with theRequesttrigger, and you want to useOAuth with Microsoft Entra ID, you can disable SAS authentication to avoid errors and problems running your workflow. You also add a security layer by removing the dependency on secrets, which reduces the risk in having secrets logged or leaked.
This option works even if you alsoenable OAuth 2.0 with Microsoft Entra ID as the only option to call a request-based endpoint. For Standard workflows, you can use other authentication types without disabling SAS.
Note
This action disables SAS authentication for incoming requests and blocks existing SAS keys or
signatures from working. However, your SAS keys or signatures remain valid and still work if you
enable SAS authentication again. To disable SAS keys and signatures by creating new versions, seeRegenerate access keys.
After you disable SAS authentication, the endpoint URL for theRequesttrigger no longer includes the SAS key, for example:
https://{domain}:443/workflows/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/triggers/When_a_HTTP_request_is_received/paths/invoke?api-version=2016-10-01
https://{domain}:443/workflows/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/triggers/When_a_HTTP_request_is_received/paths/invoke?api-version=2016-10-01
For this task, you need a tool to send REST API calls, for example:
Visual Studio Codewith anextension from Visual Studio Marketplace
PowerShell Invoke-RestMethod
Microsoft Edge - Network Console tool
Bruno
curl
Caution
For scenarios where you have sensitive data, such as credentials, secrets, access tokens, API keys, and other
similar information, make sure to use a tool that protects your data with the necessary security features.
The tool should work offline or locally, and not require sign in to an online account or sync data to the cloud.
When you use a tool with these characteristics, you reduce the risk of exposing sensitive data to the public.
When SAS authentication is disabled, the trigger's endpoint URL doesn't include the SAS key anymore. Also, the Consumption workflow definition includes thesasAuthenticationPolicyJSON object. This object has astateproperty that is set toDisabled, for example:
"properties": {
    "accessControl": {
        "triggers": {
            "sasAuthenticationPolicy": {
                "state": "Disabled"
            }
        }
    }
}
"properties": {
    "accessControl": {
        "triggers": {
            "sasAuthenticationPolicy": {
                "state": "Disabled"
            }
        }
    }
}
To find Consumption workflows where SAS is either enabled or disabled, check whether the workflow definition includes thesasAuthenticationPolicyobject where thestateproperty is set toDisabled.
With your tool that sends REST API calls, get information about your workflow by running theWorkflows - Getoperationusing the followingGETrequest, for example:GET https://management.azure.com/subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}?api-version=2016-06-01
With your tool that sends REST API calls, get information about your workflow by running theWorkflows - Getoperationusing the followingGETrequest, for example:
GET https://management.azure.com/subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}?api-version=2016-06-01
GET https://management.azure.com/subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}?api-version=2016-06-01
Take the output from theWorkflows - Getoperation, and check whether thesasAuthenticationPolicyobject exists where thestateproperty is set toDisabled.
Take the output from theWorkflows - Getoperation, and check whether thesasAuthenticationPolicyobject exists where thestateproperty is set toDisabled.
For Consumption workflows where you want to disable SAS authentication, follow these steps:
If you haven't done so already, get information about your workflow by running theWorkflows - Getoperationusing the followingGETrequest, for example:GET https://management.azure.com/subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}?api-version=2016-06-01
If you haven't done so already, get information about your workflow by running theWorkflows - Getoperationusing the followingGETrequest, for example:
GET https://management.azure.com/subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}?api-version=2016-06-01
GET https://management.azure.com/subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}?api-version=2016-06-01
Take the output from theWorkflows - Getoperation, and manually add the following elements:In thepropertiesobject, add anaccessControlobject that contains atriggersobject, if none exists.In thetriggersobject, add ansasAuthenticationPolicyobject that contains thestateproperty set toDisabled.When you finish, the edited part looks like the following example:"properties": {
    "accessControl": {
        "triggers": {
            "sasAuthenticationPolicy": {
                "state": "Disabled"
            }
        }
    }
}
Take the output from theWorkflows - Getoperation, and manually add the following elements:
In thepropertiesobject, add anaccessControlobject that contains atriggersobject, if none exists.
In thepropertiesobject, add anaccessControlobject that contains atriggersobject, if none exists.
properties
accessControl
triggers
In thetriggersobject, add ansasAuthenticationPolicyobject that contains thestateproperty set toDisabled.
In thetriggersobject, add ansasAuthenticationPolicyobject that contains thestateproperty set toDisabled.
triggers
sasAuthenticationPolicy
state
Disabled
When you finish, the edited part looks like the following example:
"properties": {
    "accessControl": {
        "triggers": {
            "sasAuthenticationPolicy": {
                "state": "Disabled"
            }
        }
    }
}
"properties": {
    "accessControl": {
        "triggers": {
            "sasAuthenticationPolicy": {
                "state": "Disabled"
            }
        }
    }
}
Send another request to update your workflow with the edited output, which you use as input in the request body, by running theWorkflows - Updateoperationusing the followingPUTrequest, for example:PUT https://management.azure.com/subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}?api-version=2016-06-01
Send another request to update your workflow with the edited output, which you use as input in the request body, by running theWorkflows - Updateoperationusing the followingPUTrequest, for example:
PUT https://management.azure.com/subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}?api-version=2016-06-01
PUT https://management.azure.com/subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}?api-version=2016-06-01
In theAzure portal, go to your Consumption workflow in the designer, and confirm that theRequesttrigger's URL no longer includes the SAS.
In theAzure portal, go to your Consumption workflow in the designer, and confirm that theRequesttrigger's URL no longer includes the SAS.
To enable OAuth 2.0 with Microsoft Entra ID, at the logic app resource level,add an authorization policy for OAuth with Microsoft Entra ID.For more information, seeEnable OAuth 2.0 with Microsoft Entra ID.
To enable OAuth 2.0 with Microsoft Entra ID, at the logic app resource level,add an authorization policy for OAuth with Microsoft Entra ID.
For more information, seeEnable OAuth 2.0 with Microsoft Entra ID.

Regenerate access keys
To maintain security and protect access to your logic app workflow, regenerate access keys on a regular schedule as they might need to comply with security policies or become compromised. This way, you can make sure that only authorized requests can trigger your workflow, which protects your data and processes from unauthorized access.
To generate a new access key at any time, use the Azure REST API or Azure portal. All previously generated URIs or URLs that use the old key are invalidated and no longer have authorization to trigger your logic app workflow. The URIs that you retrieve after regeneration are signed with the new access key.
In theAzure portal, open the logic app resource that uses the key you want to regenerate.
In theAzure portal, open the logic app resource that uses the key you want to regenerate.
On the logic app resource menu, underSettings, selectAccess Keys.
On the logic app resource menu, underSettings, selectAccess Keys.
Select the key that you want to regenerate and finish the process.
Select the key that you want to regenerate and finish the process.
Important
Make sure to protect your access key just as you protect an account key from unauthorized use. Set up or have a plan
for revoking a compromised access key. Use discretion when you distribute URIs that use access keys, and only
distribute such URIs over a secure connection such as HTTPS. Make sure to only perform operations that use an access
key over an HTTPS connection. Anyone that has a URI with valid key can access the associated resource.
If you use an SAS key to access storage services, Microsoft recommends that youcreate a user delegation SAS,
which is secured withMicrosoft Entra ID,
rather than an account key.
For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication when possible.
This option provides superior security without having to provide credentials. Azure manages this identity and helps keep
authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity
for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.

Create expiring callback URLs
If you share the endpoint URL for a request-based trigger with other parties, you can generate callback URLs that use specific keys and have expiration dates. That way, you can seamlessly roll keys or restrict access to triggering your logic app based on a specific timespan. To specify an expiration date for a URL, use theAzure Logic Apps REST API, for example:
POST /subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}/triggers/{trigger-name}/listCallbackUrl?api-version=2016-06-01
POST /subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}/triggers/{trigger-name}/listCallbackUrl?api-version=2016-06-01
In the body, include theNotAfterproperty by using a JSON date string. This property returns a callback URL that's valid only until theNotAfterdate and time.
NotAfter
NotAfter

Create URLs with primary or secondary secret key
When you generate or list callback URLs for a request-based trigger, you can specify the key to use for signing the URL. To generate a URL that's signed by a specific key, use theAzure Logic Apps REST API, for example:
POST /subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}/triggers/{trigger-name}/listCallbackUrl?api-version=2016-06-01
POST /subscriptions/{subscription-ID}/resourceGroups/{resource-group-name}/providers/Microsoft.Logic/workflows/{workflow-name}/triggers/{trigger-name}/listCallbackUrl?api-version=2016-06-01
In the body, include theKeyTypeproperty as eitherPrimaryorSecondary. This property returns a URL that's signed by the specified security key.
KeyType
Primary
Secondary

Expose your logic app workflow with Azure API Management
For more authentication protocols and options, consider exposing your logic app workflow as an API by using Azure API Management. This service provides rich monitoring, security, policy, and documentation capabilities for any endpoint. API Management can expose a public or private endpoint for your logic app. To authorize access to this endpoint, you can use OAuth with Microsoft Entra ID, client certificate, or other security standards. When API Management receives a request, the service sends the request to your logic app and makes any necessary transformations or restrictions along the way. To let only API Management call your logic app workflow, you canrestrict your logic app's inbound IP addresses.
For more information, see the following documentation:
About API Management
Protect a web API backend in Azure API Management by using OAuth 2.0 authorization with Microsoft Entra ID
Secure APIs using client certificate authentication in API Management
API Management authentication policies

Restrict inbound IP addresses
Along with Shared Access Signature (SAS), you might want to specifically limit the clients that can call your logic app workflow. For example, if you manage your request endpoint by usingAzure API Management, you can restrict your logic app workflow to accept requests only from the IP address for theAPI Management service instance that you create.
Regardless of any IP addresses that you specify, you can still run a logic app workflow that has a request-based trigger by using theWorkflow Triggers - Runoperationrequest or by using API Management. However, this scenario still requiresauthenticationagainst the Azure REST API. All events appear in the Azure Audit Log. Make sure that you set access control policies accordingly.
To restrict the inbound IP addresses for your logic app workflow, follow the corresponding steps for either the Azure portal or your Azure Resource Manager template. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.x

Portal
Resource Manager Template
In the Azure portal, IP address restriction affects both triggersandactions, contrary to the description in the portal underAllowed inbound IP addresses. To set up this filter separately for triggers and for actions, use theaccessControlobject in an Azure Resource Manager template for your logic app resource or theWorkflow - Create Or Updateoperationin the Azure Logic Apps REST API.
accessControl
In theAzure portal, open your Consumption logic app in the workflow designer.
In theAzure portal, open your Consumption logic app in the workflow designer.
On the logic app menu, underSettings, selectWorkflow settings.
On the logic app menu, underSettings, selectWorkflow settings.
In theAccess control configurationsection, underAllowed inbound IP addresses, choose the path for your scenario:To make your workflow callable using theAzure Logic Appsbuilt-in action, but only as a nested workflow, selectOnly other Logic Apps. This option worksonlywhen you use theAzure Logic Appsaction to call the nested workflow.This option writes an empty array to your logic app resource and requires that only calls from parent workflows that use the built-inAzure Logic Appsaction can trigger the nested workflow.To make your workflow callable using the HTTP action, but only as a nested workflow, selectSpecific IP ranges. When theIP ranges for triggersbox appears, enter the parent workflow'soutbound IP addresses. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.xNoteIf you use theOnly other Logic Appsoption and the HTTP action to call your nested workflow,
the call is blocked, and you get a "401 Unauthorized" error.For scenarios where you want to restrict inbound calls from other IPs, when theIP ranges for triggersbox appears, specify the IP address ranges that the trigger accepts. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.x
In theAccess control configurationsection, underAllowed inbound IP addresses, choose the path for your scenario:
To make your workflow callable using theAzure Logic Appsbuilt-in action, but only as a nested workflow, selectOnly other Logic Apps. This option worksonlywhen you use theAzure Logic Appsaction to call the nested workflow.This option writes an empty array to your logic app resource and requires that only calls from parent workflows that use the built-inAzure Logic Appsaction can trigger the nested workflow.
To make your workflow callable using theAzure Logic Appsbuilt-in action, but only as a nested workflow, selectOnly other Logic Apps. This option worksonlywhen you use theAzure Logic Appsaction to call the nested workflow.
This option writes an empty array to your logic app resource and requires that only calls from parent workflows that use the built-inAzure Logic Appsaction can trigger the nested workflow.
To make your workflow callable using the HTTP action, but only as a nested workflow, selectSpecific IP ranges. When theIP ranges for triggersbox appears, enter the parent workflow'soutbound IP addresses. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.xNoteIf you use theOnly other Logic Appsoption and the HTTP action to call your nested workflow,
the call is blocked, and you get a "401 Unauthorized" error.
To make your workflow callable using the HTTP action, but only as a nested workflow, selectSpecific IP ranges. When theIP ranges for triggersbox appears, enter the parent workflow'soutbound IP addresses. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.x
Note
If you use theOnly other Logic Appsoption and the HTTP action to call your nested workflow,
the call is blocked, and you get a "401 Unauthorized" error.
For scenarios where you want to restrict inbound calls from other IPs, when theIP ranges for triggersbox appears, specify the IP address ranges that the trigger accepts. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.x
For scenarios where you want to restrict inbound calls from other IPs, when theIP ranges for triggersbox appears, specify the IP address ranges that the trigger accepts. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.x
Optionally, underRestrict calls to get input and output messages from run history to the provided IP addresses, you can specify the IP address ranges for inbound calls that can access input and output messages in run history.
Optionally, underRestrict calls to get input and output messages from run history to the provided IP addresses, you can specify the IP address ranges for inbound calls that can access input and output messages in run history.
In theAzure portal, open your Standard logic app resource.
In theAzure portal, open your Standard logic app resource.
On the logic app menu, underSettings, selectNetworking.
On the logic app menu, underSettings, selectNetworking.
In theInbound traffic configurationsection, next toPublic network access, selectEnabled with no access restriction.
In theInbound traffic configurationsection, next toPublic network access, selectEnabled with no access restriction.
On theAccess restrictionspage, underApp access, selectEnabled from select virtual networks and IP addresses.
On theAccess restrictionspage, underApp access, selectEnabled from select virtual networks and IP addresses.
UnderSite access and rules, on theMain sitetab, add one or more rules to eitherAlloworDenyrequests from specific IP ranges. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.xFor more information, seeBlocking inbound IP addresses in Azure Logic Apps (Standard).
UnderSite access and rules, on theMain sitetab, add one or more rules to eitherAlloworDenyrequests from specific IP ranges. A valid IP range uses these formats:x.x.x.x/xorx.x.x.x-x.x.x.x
For more information, seeBlocking inbound IP addresses in Azure Logic Apps (Standard).

In your ARM template, specify the allowed inbound IP address ranges in your logic app's resource definition by using theaccessControlsection. In this section, use thetriggers,actions, and the optionalcontentssections as appropriate by including theallowedCallerIpAddressessection with theaddressRangeproperty and set the property value to the allowed IP range inx.x.x.x/xorx.x.x.x-x.x.x.xformat.
accessControl
triggers
actions
contents
allowedCallerIpAddresses
addressRange
If your nested logic app workflow uses theOnly other Logic Appsoption, which permits inbound calls only from other logic app workflows that use the built-in Azure Logic Apps action, set theallowedCallerIpAddressesproperty to an empty array ([]), andomittheaddressRangeproperty.
If your nested logic app workflow uses theOnly other Logic Appsoption, which permits inbound calls only from other logic app workflows that use the built-in Azure Logic Apps action, set theallowedCallerIpAddressesproperty to an empty array ([]), andomittheaddressRangeproperty.
allowedCallerIpAddresses
addressRange
If your nested logic app workflow uses theSpecific IP rangesoption for other inbound calls, such as other logic app workflows that use the HTTP action, include theallowedCallerIpAddressessection, and set theaddressRangeproperty to the allowed IP range.
If your nested logic app workflow uses theSpecific IP rangesoption for other inbound calls, such as other logic app workflows that use the HTTP action, include theallowedCallerIpAddressessection, and set theaddressRangeproperty to the allowed IP range.
allowedCallerIpAddresses
addressRange
This example shows a logic app resource definition for a nested workflow that permits inbound calls only from other logic app workflows that use the built-in Azure Logic Apps action:
{
   "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
   "contentVersion": "1.0.0.0",
   "parameters": {},
   "variables": {},
   "resources": [
      {
         "name": "[parameters('LogicAppName')]",
         "type": "Microsoft.Logic/workflows",
         "location": "[parameters('LogicAppLocation')]",
         "tags": {
            "displayName": "LogicApp"
         },
         "apiVersion": "2016-06-01",
         "properties": {
            "definition": {
               <workflow-definition>
            },
            "parameters": {
            },
            "accessControl": {
               "triggers": {
                  "allowedCallerIpAddresses": []
               },
               "actions": {
                  "allowedCallerIpAddresses": []
               },
               // Optional
               "contents": {
                  "allowedCallerIpAddresses": []
               }
            },
            "endpointsConfiguration": {}
         }
      }
   ],
   "outputs": {}
}
{
   "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
   "contentVersion": "1.0.0.0",
   "parameters": {},
   "variables": {},
   "resources": [
      {
         "name": "[parameters('LogicAppName')]",
         "type": "Microsoft.Logic/workflows",
         "location": "[parameters('LogicAppLocation')]",
         "tags": {
            "displayName": "LogicApp"
         },
         "apiVersion": "2016-06-01",
         "properties": {
            "definition": {
               <workflow-definition>
            },
            "parameters": {
            },
            "accessControl": {
               "triggers": {
                  "allowedCallerIpAddresses": []
               },
               "actions": {
                  "allowedCallerIpAddresses": []
               },
               // Optional
               "contents": {
                  "allowedCallerIpAddresses": []
               }
            },
            "endpointsConfiguration": {}
         }
      }
   ],
   "outputs": {}
}
This example shows a logic app resource definition for a nested workflow that permits inbound calls from logic app workflows that use the HTTP action:
{
   "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
   "contentVersion": "1.0.0.0",
   "parameters": {},
   "variables": {},
   "resources": [
      {
         "name": "[parameters('LogicAppName')]",
         "type": "Microsoft.Logic/workflows",
         "location": "[parameters('LogicAppLocation')]",
         "tags": {
            "displayName": "LogicApp"
         },
         "apiVersion": "2016-06-01",
         "properties": {
            "definition": {
               <workflow-definition>
            },
            "parameters": {
            },
            "accessControl": {
               "triggers": {
                  "allowedCallerIpAddresses": [
                     {
                        "addressRange": "192.168.12.0/23"
                     }
                  ]
               },
               "actions": {
                  "allowedCallerIpAddresses": [
                     {
                        "addressRange": "192.168.12.0/23"
                     }
                  ]
               }
            },
            "endpointsConfiguration": {}
         }
      }
   ],
   "outputs": {}
}
{
   "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
   "contentVersion": "1.0.0.0",
   "parameters": {},
   "variables": {},
   "resources": [
      {
         "name": "[parameters('LogicAppName')]",
         "type": "Microsoft.Logic/workflows",
         "location": "[parameters('LogicAppLocation')]",
         "tags": {
            "displayName": "LogicApp"
         },
         "apiVersion": "2016-06-01",
         "properties": {
            "definition": {
               <workflow-definition>
            },
            "parameters": {
            },
            "accessControl": {
               "triggers": {
                  "allowedCallerIpAddresses": [
                     {
                        "addressRange": "192.168.12.0/23"
                     }
                  ]
               },
               "actions": {
                  "allowedCallerIpAddresses": [
                     {
                        "addressRange": "192.168.12.0/23"
                     }
                  ]
               }
            },
            "endpointsConfiguration": {}
         }
      }
   ],
   "outputs": {}
}
In your ARM template, specify the allowed inbound IP address ranges in your logic app's resource definition by using theMicrosoft.Web/sites/configsection. In this section, underproperties, add theipSecurityRestrictionssection, and use theipAddress,action="Deny" | "Allow",tag=Default,priority, andname="Ports"sections to define a rule and set theipAddressto the allowed IP range inx.x.x.x/xorx.x.x.x-x.x.x.xformat, for example:
Microsoft.Web/sites/config
properties
ipSecurityRestrictions
ipAddress
action="Deny" | "Allow"
tag=Default
priority
name="Ports"
ipAddress
{
   "type": "Microsoft.Web/sites/config",
   "apiVersion": "2022-09-01",
   "name": "[concat(parameters('sites_My_Standard_Logic_App_name'), '/web')]",
   "location": "West US",
   "dependsOn": [
      "[resourceId('Microsoft.Web/sites', parameters('sites_My_Standard_Logic_App_name'))]"
   ],
   "tags": {
      "hidden-link: /app-insights-resource-id": "/subscriptions/{subscriptionID}/resourceGroups/Standard-RG/providers/Microsoft.Insights/components/My-Standard-Logic-App"
   },
   "properties": {
      "numberOfWorkers": 1,
      "defaultDocuments": [
         "Default.htm",
         "Default.html",
         "Default.asp",
         "index.htm",
         "index.html",
         "iisstart.htm",
         "default.aspx",
         "index.php"
      ],
      "netFrameworkVersion": "v6.0",
      "requestTracingEnabled": false,
      "remoteDebuggingEnabled": false,
      "httpLoggingEnabled": false,
      "acrUseManagedIdentityCreds": false,
      "logsDirectorySizeLimit": 35,
      "detailedErrorLoggingEnabled": false,
      "publishingUsername": "$My-Standard-Logic-App",
      "scmType": "None",
      "use32BitWorkerProcess": false,
      "webSocketsEnabled": false,
      "alwaysOn": false,
      "managedPipelineMode": "Integrated",
      "virtualApplications": [
         {
            "virtualPath": "/",
            "physicalPath": "site\\wwwroot",
            "preloadEnabled": false
         }
      ],
      "loadBalancing": "LeastRequests",
      "experiments": {
         "rampUpRules": []
      },
      "autoHealEnabled": false,
      "vnetRouteAllEnabled": false,
      "vnetPrivatePortsCount": 0,
      "publicNetworkAccess": "Enabled",
      "cors": {
         "supportCredentials": false
      },
      "localMySqlEnabled": false,
      "managedServiceIdentityId": 3065,
      "ipSecurityRestrictions": [
         {
            "ipAddress": "208.130.0.0/16",
            "action": "Deny",
            "tag": "Default",
            "priority": 100,
            "name": "Ports"
         },
         {
            "ipAddress": "Any",
            "action": "Deny",
            "priority": 2147483647,
            "name": "Deny all",
            "description": "Deny all access"
         }
      ],
      "ipSecurityRestrictionsDefaultAction": "Deny",
      "scmIpSecurityRestrictions": [
         {
            "ipAddress": "Any",
            "action": "Allow",
            "priority": 2147483647,
            "name": "Allow all",
            "description": "Allow all access"
         }
      ],
      "scmIpSecurityRestrictionsDefaultAction": "Allow",
      "scmIpSecurityRestrictionsUseMain": false,
      "http20Enabled": false,
      "minTlsVersion": "1.2",
      "scmMinTlsVersion": "1.2",
      "ftpsState": "FtpsOnly",
      "preWarmedInstanceCount": 1,
      "functionAppScaleLimit": 0,
      "functionsRuntimeScaleMonitoringEnabled": true,
      "minimumElasticInstanceCount": 1,
      "azureStorageAccounts": {}
   }
},
{
   "type": "Microsoft.Web/sites/config",
   "apiVersion": "2022-09-01",
   "name": "[concat(parameters('sites_My_Standard_Logic_App_name'), '/web')]",
   "location": "West US",
   "dependsOn": [
      "[resourceId('Microsoft.Web/sites', parameters('sites_My_Standard_Logic_App_name'))]"
   ],
   "tags": {
      "hidden-link: /app-insights-resource-id": "/subscriptions/{subscriptionID}/resourceGroups/Standard-RG/providers/Microsoft.Insights/components/My-Standard-Logic-App"
   },
   "properties": {
      "numberOfWorkers": 1,
      "defaultDocuments": [
         "Default.htm",
         "Default.html",
         "Default.asp",
         "index.htm",
         "index.html",
         "iisstart.htm",
         "default.aspx",
         "index.php"
      ],
      "netFrameworkVersion": "v6.0",
      "requestTracingEnabled": false,
      "remoteDebuggingEnabled": false,
      "httpLoggingEnabled": false,
      "acrUseManagedIdentityCreds": false,
      "logsDirectorySizeLimit": 35,
      "detailedErrorLoggingEnabled": false,
      "publishingUsername": "$My-Standard-Logic-App",
      "scmType": "None",
      "use32BitWorkerProcess": false,
      "webSocketsEnabled": false,
      "alwaysOn": false,
      "managedPipelineMode": "Integrated",
      "virtualApplications": [
         {
            "virtualPath": "/",
            "physicalPath": "site\\wwwroot",
            "preloadEnabled": false
         }
      ],
      "loadBalancing": "LeastRequests",
      "experiments": {
         "rampUpRules": []
      },
      "autoHealEnabled": false,
      "vnetRouteAllEnabled": false,
      "vnetPrivatePortsCount": 0,
      "publicNetworkAccess": "Enabled",
      "cors": {
         "supportCredentials": false
      },
      "localMySqlEnabled": false,
      "managedServiceIdentityId": 3065,
      "ipSecurityRestrictions": [
         {
            "ipAddress": "208.130.0.0/16",
            "action": "Deny",
            "tag": "Default",
            "priority": 100,
            "name": "Ports"
         },
         {
            "ipAddress": "Any",
            "action": "Deny",
            "priority": 2147483647,
            "name": "Deny all",
            "description": "Deny all access"
         }
      ],
      "ipSecurityRestrictionsDefaultAction": "Deny",
      "scmIpSecurityRestrictions": [
         {
            "ipAddress": "Any",
            "action": "Allow",
            "priority": 2147483647,
            "name": "Allow all",
            "description": "Allow all access"
         }
      ],
      "scmIpSecurityRestrictionsDefaultAction": "Allow",
      "scmIpSecurityRestrictionsUseMain": false,
      "http20Enabled": false,
      "minTlsVersion": "1.2",
      "scmMinTlsVersion": "1.2",
      "ftpsState": "FtpsOnly",
      "preWarmedInstanceCount": 1,
      "functionAppScaleLimit": 0,
      "functionsRuntimeScaleMonitoringEnabled": true,
      "minimumElasticInstanceCount": 1,
      "azureStorageAccounts": {}
   }
},

Access for outbound calls to other services and systems
Based on the target endpoint's capability, outbound calls sent by theHTTP trigger or HTTP action, support encryption and are secured withTransport Layer Security (TLS) 1.0, 1.1, or 1.2, previously known as Secure Sockets Layer (SSL). Azure Logic Apps negotiates with the target endpoint over using the highest possible version that's supported. For example, if the target endpoint supports 1.2, the HTTP trigger or action uses 1.2 first. Otherwise, the connector uses the next highest supported version.
This list includes information about TLS/SSL self-signed certificates:
For Consumption logic app workflows in the multitenant Azure Logic Apps environment, HTTP operations don't permit self-signed TLS/SSL certificates. If your logic app makes an HTTP call to a server and presents a TLS/SSL self-signed certificate, the HTTP call fails with aTrustFailureerror.
For Consumption logic app workflows in the multitenant Azure Logic Apps environment, HTTP operations don't permit self-signed TLS/SSL certificates. If your logic app makes an HTTP call to a server and presents a TLS/SSL self-signed certificate, the HTTP call fails with aTrustFailureerror.
TrustFailure
For Standard logic app workflows in the single-tenant Azure Logic Apps environment, HTTP operations support self-signed TLS/SSL certificates. However, you have to complete a few extra steps for this authentication type. Otherwise, the call fails. For more information, reviewTLS/SSL certificate authentication for single-tenant Azure Logic Apps.If you want to use client certificate or OAuth with Microsoft Entra ID with theCertificatecredential type instead, you still have to complete a few extra steps for this authentication type. Otherwise, the call fails. For more information, seeClient certificate or OAuth with Microsoft Entra ID with the "Certificate" credential type for single-tenant Azure Logic Apps.
For Standard logic app workflows in the single-tenant Azure Logic Apps environment, HTTP operations support self-signed TLS/SSL certificates. However, you have to complete a few extra steps for this authentication type. Otherwise, the call fails. For more information, reviewTLS/SSL certificate authentication for single-tenant Azure Logic Apps.
If you want to use client certificate or OAuth with Microsoft Entra ID with theCertificatecredential type instead, you still have to complete a few extra steps for this authentication type. Otherwise, the call fails. For more information, seeClient certificate or OAuth with Microsoft Entra ID with the "Certificate" credential type for single-tenant Azure Logic Apps.
Here are more ways that you can help secure endpoints that handle calls sent from your logic app workflows:
Add authentication to outbound requests.When you use the HTTP trigger or action to send outbound calls, you can add authentication to the request that's sent by your logic app. For example, you can select these authentication types:Basic authenticationClient certificate authenticationActive Directory OAuth (OAuth 2.0 with Microsoft Entra ID) authenticationManaged identity authentication
Add authentication to outbound requests.
When you use the HTTP trigger or action to send outbound calls, you can add authentication to the request that's sent by your logic app. For example, you can select these authentication types:
Basic authentication
Basic authentication
Client certificate authentication
Client certificate authentication
Active Directory OAuth (OAuth 2.0 with Microsoft Entra ID) authentication
Active Directory OAuth (OAuth 2.0 with Microsoft Entra ID) authentication
Managed identity authentication
Managed identity authentication
Restrict access from logic app workflow IP addresses.All calls to endpoints from logic app workflows originate from specific designated IP addresses that are based on your logic apps' regions. You can add filtering that accepts requests only from those IP addresses. To get these IP addresses, reviewLimits and configuration for Azure Logic Apps.
Restrict access from logic app workflow IP addresses.
All calls to endpoints from logic app workflows originate from specific designated IP addresses that are based on your logic apps' regions. You can add filtering that accepts requests only from those IP addresses. To get these IP addresses, reviewLimits and configuration for Azure Logic Apps.
Improve security for connections to on-premises systems.Azure Logic Apps provides integration with these services to help provide more secure and reliable on-premises communication.On-premises data gatewayMany managed connectors in Azure Logic Apps facilitate secured connections to on-premises systems, such as File System, SQL, SharePoint, and DB2. The gateway sends data from on-premises sources on encrypted channels through the Azure Service Bus. All traffic originates as secured outbound traffic from the gateway agent. Learnhow the on-premises data gateway works.Connect through Azure API ManagementAzure API Managementprovides on-premises connection options, such as site-to-site virtual private network andExpressRouteintegration for secured proxy and communication to on-premises systems. If you have an API that provides access to your on-premises system, and you exposed that API by creating anAPI Management service instance, you can call that API from your logic app's workflow by selecting the correspondingAPI Managementoperation in the workflow designer.NoteThe connector shows only those API Management services where you have permissions to view and connect,
but doesn't show consumption-based API Management services.Based on your logic app resource type, follow the corresponding steps:Consumption workflowsBased on whether you're adding an API Management trigger or action, follow these steps:Trigger:On the workflow designer, selectAdd a trigger.After theAdd a triggerpane opens, in the search box, enterAPI Management.From the trigger results list, selectChoose an Azure API Management Trigger.Action:On the workflow designer, select the plus sign (+) where you want to add the action.After theAdd an actionpane opens, in the search box, enterAPI Management.From the action results list, selectChoose an Azure API Management action.The following example shows finding an Azure API Management trigger:From the API Management service instance list, select your previously created API Management service instance.From the API operations list, select the API operation to call, and then selectAdd Action.Standard workflowsFor Standard workflows, you can only addAPI Managementactions, not triggers.On the workflow designer, select the plus sign (+) where you want to add the action.After theAdd an actionpane opens, in the search box, enterAPI Management.From the action results list, selectCall an Azure API Management API.From the API Management service instance list, select your previously created API Management service instance.From the API operations list, select the API operation to call, and then selectCreate New.
Improve security for connections to on-premises systems.
Azure Logic Apps provides integration with these services to help provide more secure and reliable on-premises communication.
On-premises data gatewayMany managed connectors in Azure Logic Apps facilitate secured connections to on-premises systems, such as File System, SQL, SharePoint, and DB2. The gateway sends data from on-premises sources on encrypted channels through the Azure Service Bus. All traffic originates as secured outbound traffic from the gateway agent. Learnhow the on-premises data gateway works.
On-premises data gateway
Many managed connectors in Azure Logic Apps facilitate secured connections to on-premises systems, such as File System, SQL, SharePoint, and DB2. The gateway sends data from on-premises sources on encrypted channels through the Azure Service Bus. All traffic originates as secured outbound traffic from the gateway agent. Learnhow the on-premises data gateway works.
Connect through Azure API ManagementAzure API Managementprovides on-premises connection options, such as site-to-site virtual private network andExpressRouteintegration for secured proxy and communication to on-premises systems. If you have an API that provides access to your on-premises system, and you exposed that API by creating anAPI Management service instance, you can call that API from your logic app's workflow by selecting the correspondingAPI Managementoperation in the workflow designer.NoteThe connector shows only those API Management services where you have permissions to view and connect,
but doesn't show consumption-based API Management services.Based on your logic app resource type, follow the corresponding steps:Consumption workflowsBased on whether you're adding an API Management trigger or action, follow these steps:Trigger:On the workflow designer, selectAdd a trigger.After theAdd a triggerpane opens, in the search box, enterAPI Management.From the trigger results list, selectChoose an Azure API Management Trigger.Action:On the workflow designer, select the plus sign (+) where you want to add the action.After theAdd an actionpane opens, in the search box, enterAPI Management.From the action results list, selectChoose an Azure API Management action.The following example shows finding an Azure API Management trigger:From the API Management service instance list, select your previously created API Management service instance.From the API operations list, select the API operation to call, and then selectAdd Action.Standard workflowsFor Standard workflows, you can only addAPI Managementactions, not triggers.On the workflow designer, select the plus sign (+) where you want to add the action.After theAdd an actionpane opens, in the search box, enterAPI Management.From the action results list, selectCall an Azure API Management API.From the API Management service instance list, select your previously created API Management service instance.From the API operations list, select the API operation to call, and then selectCreate New.
Connect through Azure API Management
Azure API Managementprovides on-premises connection options, such as site-to-site virtual private network andExpressRouteintegration for secured proxy and communication to on-premises systems. If you have an API that provides access to your on-premises system, and you exposed that API by creating anAPI Management service instance, you can call that API from your logic app's workflow by selecting the correspondingAPI Managementoperation in the workflow designer.
Note
The connector shows only those API Management services where you have permissions to view and connect,
but doesn't show consumption-based API Management services.
Based on your logic app resource type, follow the corresponding steps:
Consumption workflows
Based on whether you're adding an API Management trigger or action, follow these steps:Trigger:On the workflow designer, selectAdd a trigger.After theAdd a triggerpane opens, in the search box, enterAPI Management.From the trigger results list, selectChoose an Azure API Management Trigger.Action:On the workflow designer, select the plus sign (+) where you want to add the action.After theAdd an actionpane opens, in the search box, enterAPI Management.From the action results list, selectChoose an Azure API Management action.The following example shows finding an Azure API Management trigger:
Based on whether you're adding an API Management trigger or action, follow these steps:
Trigger:On the workflow designer, selectAdd a trigger.After theAdd a triggerpane opens, in the search box, enterAPI Management.From the trigger results list, selectChoose an Azure API Management Trigger.
Trigger:
On the workflow designer, selectAdd a trigger.
On the workflow designer, selectAdd a trigger.
After theAdd a triggerpane opens, in the search box, enterAPI Management.
After theAdd a triggerpane opens, in the search box, enterAPI Management.
From the trigger results list, selectChoose an Azure API Management Trigger.
From the trigger results list, selectChoose an Azure API Management Trigger.
Action:On the workflow designer, select the plus sign (+) where you want to add the action.After theAdd an actionpane opens, in the search box, enterAPI Management.From the action results list, selectChoose an Azure API Management action.
Action:
On the workflow designer, select the plus sign (+) where you want to add the action.
On the workflow designer, select the plus sign (+) where you want to add the action.
After theAdd an actionpane opens, in the search box, enterAPI Management.
After theAdd an actionpane opens, in the search box, enterAPI Management.
From the action results list, selectChoose an Azure API Management action.
From the action results list, selectChoose an Azure API Management action.
The following example shows finding an Azure API Management trigger:

From the API Management service instance list, select your previously created API Management service instance.
From the API Management service instance list, select your previously created API Management service instance.
From the API operations list, select the API operation to call, and then selectAdd Action.
From the API operations list, select the API operation to call, and then selectAdd Action.
Standard workflows
For Standard workflows, you can only addAPI Managementactions, not triggers.
On the workflow designer, select the plus sign (+) where you want to add the action.
On the workflow designer, select the plus sign (+) where you want to add the action.
After theAdd an actionpane opens, in the search box, enterAPI Management.
After theAdd an actionpane opens, in the search box, enterAPI Management.
From the action results list, selectCall an Azure API Management API.
From the action results list, selectCall an Azure API Management API.

From the API Management service instance list, select your previously created API Management service instance.
From the API Management service instance list, select your previously created API Management service instance.
From the API operations list, select the API operation to call, and then selectCreate New.
From the API operations list, select the API operation to call, and then selectCreate New.


Add authentication to outbound calls
HTTP and HTTPS endpoints support various kinds of authentication. On some triggers and actions that you use for sending outbound calls or requests to these endpoints, you can specify an authentication type. In the workflow designer, triggers and actions that support choosing an authentication type have anAuthenticationproperty. However, this property might not always appear by default. In these cases, on the trigger or action, open theAdvanced parameterslist, and selectAuthentication.
Important
To protect sensitive information that your logic app workflow handles, use secured parameters and encode data as necessary.
For more information about using and securing parameters, reviewAccess to parameter inputs.
For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication when possible.
This option provides superior security without having to provide credentials. Azure manages this identity and helps keep
authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity
for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.

For HTTP calls, basic authentication uses a base64-encoded string that contains a username and password to make a request. This method transmits credentials without encryption and poses increased security risks unless you use this option with the HTTPS/SSL protocol.
Important
For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication when possible.
This option provides superior security without having to provide credentials. Azure manages this identity and helps keep
authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity
for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.
If theBasicoption is available and selected, specify these property values:
type
username
password
When you usesecured parametersto handle and secure sensitive information, for example, in anAzure Resource Manager template for automating deployment, you can use expressions to access these parameter values at runtime. This example HTTP action definition specifies the authenticationtypeasBasicand uses theparameters() functionto get the parameter values:
type
Basic
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "@parameters('endpointUrlParam')",
      "authentication": {
         "type": "Basic",
         "username": "@parameters('userNameParam')",
         "password": "@parameters('passwordParam')"
      }
  },
  "runAfter": {}
}
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "@parameters('endpointUrlParam')",
      "authentication": {
         "type": "Basic",
         "username": "@parameters('userNameParam')",
         "password": "@parameters('passwordParam')"
      }
  },
  "runAfter": {}
}

Client certificate authenticationallows or requires users to authenticate directly with X.509 certificates against their Microsoft Entra ID for applications and browser sign-in. This capability helps you adopt a phishing resistant authentication and authenticate with an X.509 certificate against your Public Key Infrastructure (PKI).
Important
For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication when possible.
This option provides superior security without having to provide credentials. Azure manages this identity and helps keep
authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity
for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.
If theClient certificateoption is available and selected, specify these property values:
type
ClientCertificate

pfx
$pfx_cert = [System.IO.File]::ReadAllBytes('c:\certificate.pfx')
ToBase64String()
[System.Convert]::ToBase64String($pfx_cert) | Out-File 'pfx-encoded-bytes.txt'
cert mmc/PowerShell
Could not load the certificate private key. Please check the authentication certificate password is correct and try again.
openssl
openssl pkcs12 -in certificate.pfx -out certificate.pem
openssl pkcs12 -in certificate.pem -export -out certificate2.pfx
password
Note
If you try to authenticate with a client certificate using OpenSSL, you might get the following error:
BadRequest: Could not load private key
BadRequest: Could not load private key
To resolve this error, follow these steps:
Uninstall all OpenSSL instances.
Install OpenSSL version 1.1.1t.
Resign your certificate using the new update.
Add the new certificate to the HTTP operation when using client certificate authentication.
When you usesecured parametersto handle and secure sensitive information, for example, in anAzure Resource Manager template for automating deployment, you can use expressions to access these parameter values at runtime. This example HTTP action definition specifies the authenticationtypeasClientCertificateand uses theparameters() functionto get the parameter values:
type
ClientCertificate
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "@parameters('endpointUrlParam')",
      "authentication": {
         "type": "ClientCertificate",
         "pfx": "@parameters('pfxParam')",
         "password": "@parameters('passwordParam')"
      }
   },
   "runAfter": {}
}
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "@parameters('endpointUrlParam')",
      "authentication": {
         "type": "ClientCertificate",
         "pfx": "@parameters('pfxParam')",
         "password": "@parameters('passwordParam')"
      }
   },
   "runAfter": {}
}
Important
If you have a Standard logic app resource in single-tenant Azure Logic Apps, and you want to use an HTTP
operation with a TSL/SSL certificate, client certificate, or Microsoft Entra ID Open Authentication
(Microsoft Entra ID OAuth) with theCertificatecredential type, make sure to complete the extra setup
steps for this authentication type. Otherwise, the call fails. For more information, reviewAuthentication in single-tenant environment.
Certificate
For more information about securing services by using client certificate authentication, review these topics:
Improve security for APIs by using client certificate authentication in Azure API Management
Improve security for back-end services by using client certificate authentication in Azure API Management
Improve security for your RESTful service by using client certificates
Certificate credentials for application authentication
Use a TLS/SSL certificate in your code in Azure App Service

On theRequesttrigger, you can use theMicrosoft Entra platformto authenticate incoming calls after youset up Microsoft Entra authorization policiesfor your logic app.
Important
For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication when possible.
This option provides superior security without having to provide credentials. Azure manages this identity and helps keep
authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity
for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.
On all other triggers and actions that support theActive Directory OAuth(OAuth 2.0 with Microsoft Entra ID) authentication type, specify these property values:
type
ActiveDirectoryOAuth
authority
https://login.microsoftonline.com/
tenant
audience
https://management.core.windows.net/
clientId
credentialType
secret
pfx
password
When you usesecured parametersto handle and secure sensitive information, for example, in anAzure Resource Manager template for automating deployment, you can use expressions to access these parameter values at runtime. This example HTTP action definition specifies the authenticationtypeasActiveDirectoryOAuth, the credential type asSecret, and uses theparameters() functionto get the parameter values:
type
ActiveDirectoryOAuth
Secret
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "@parameters('endpointUrlParam')",
      "authentication": {
         "type": "ActiveDirectoryOAuth",
         "tenant": "@parameters('tenantIdParam')",
         "audience": "https://management.core.windows.net/",
         "clientId": "@parameters('clientIdParam')",
         "credentialType": "Secret",
         "secret": "@parameters('secretParam')"
     }
   },
   "runAfter": {}
}
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "@parameters('endpointUrlParam')",
      "authentication": {
         "type": "ActiveDirectoryOAuth",
         "tenant": "@parameters('tenantIdParam')",
         "audience": "https://management.core.windows.net/",
         "clientId": "@parameters('clientIdParam')",
         "credentialType": "Secret",
         "secret": "@parameters('secretParam')"
     }
   },
   "runAfter": {}
}
Important
If you have a Standard logic app resource in single-tenant Azure Logic Apps, and you want to use an HTTP
operation with a TSL/SSL certificate, client certificate, or Microsoft Entra ID OAuth with theCertificatecredential type, make sure to complete the extra setup steps for this authentication type. Otherwise, the call
fails. For more information, seeAuthentication in single-tenant environment.
Certificate

If theRawoption is available, you can use this authentication type when you have to useauthentication schemesthat don't follow theOAuth 2.0 protocol. With this type, you manually create the authorization header value that you send with the outgoing request, and specify that header value in your trigger or action.
Important
For optimal security, Microsoft recommends usingMicrosoft Entra IDwithmanaged identitiesfor authentication when possible.
This option provides superior security without having to provide credentials. Azure manages this identity and helps keep
authentication information secure so that you don't have to manage this sensitive information. To set up a managed identity
for Azure Logic Apps, seeAuthenticate access and connections to Azure resources with managed identities in Azure Logic Apps.
The following example shows a sample header for an HTTPS request that follows theOAuth 1.0 protocol:
Authorization: OAuth realm="Photos",
   oauth_consumer_key="dpf43f3p2l4k3l03",
   oauth_signature_method="HMAC-SHA1",
   oauth_timestamp="137131200",
   oauth_nonce="wIjqoS",
   oauth_callback="http%3A%2F%2Fprinter.example.com%2Fready",
   oauth_signature="74KNZJeDHnMBp0EMJ9ZHt%2FXKycU%3D"
Authorization: OAuth realm="Photos",
   oauth_consumer_key="dpf43f3p2l4k3l03",
   oauth_signature_method="HMAC-SHA1",
   oauth_timestamp="137131200",
   oauth_nonce="wIjqoS",
   oauth_callback="http%3A%2F%2Fprinter.example.com%2Fready",
   oauth_signature="74KNZJeDHnMBp0EMJ9ZHt%2FXKycU%3D"
In the trigger or action that supports raw authentication, specify these property values:
type
value
When you usesecured parametersto handle and secure sensitive information, for example, in anAzure Resource Manager template for automating deployment, you can use expressions to access these parameter values at runtime. This example HTTP action definition specifies the authenticationtypeasRaw, and uses theparameters() functionto get the parameter values:
type
Raw
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "@parameters('endpointUrlParam')",
      "authentication": {
         "type": "Raw",
         "value": "@parameters('authHeaderParam')"
      }
   },
   "runAfter": {}
}
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "@parameters('endpointUrlParam')",
      "authentication": {
         "type": "Raw",
         "value": "@parameters('authHeaderParam')"
      }
   },
   "runAfter": {}
}

When themanaged identityoption is available on thetrigger or action that supports managed identity authentication, your logic app can use this identity for authenticating access to Azure resources that are protected by Microsoft Entra ID, rather than credentials, secrets, or Microsoft Entra tokens. Azure manages this identity for you and helps you secure your credentials because you don't have to manage secrets or directly use Microsoft Entra tokens. Learn more aboutAzure services that support managed identities for Microsoft Entra authentication.
A Consumption logic app resource can use the system-assigned identity or asinglemanually created user-assigned identity.
A Consumption logic app resource can use the system-assigned identity or asinglemanually created user-assigned identity.
A Standard logic app resource supports having thesystem-assigned managed identityandmultiple user-assigned managed identitiesenabled at the same time, though you still can only select one identity to use at any time.NoteBy default, the system-assigned identity is already enabled to authenticate connections at run time.
This identity differs from the authentication credentials or connection string that you use when you
create a connection. If you disable this identity, connections won't work at run time. To view
this setting, on your logic app menu, underSettings, selectIdentity.
A Standard logic app resource supports having thesystem-assigned managed identityandmultiple user-assigned managed identitiesenabled at the same time, though you still can only select one identity to use at any time.
Note
By default, the system-assigned identity is already enabled to authenticate connections at run time.
This identity differs from the authentication credentials or connection string that you use when you
create a connection. If you disable this identity, connections won't work at run time. To view
this setting, on your logic app menu, underSettings, selectIdentity.
Before your logic app can use a managed identity, follow the steps inAuthenticate access to Azure resources by using managed identities in Azure Logic Apps. These steps enable the managed identity on your logic app and set up that identity's access to the target Azure resource.
Before your logic app can use a managed identity, follow the steps inAuthenticate access to Azure resources by using managed identities in Azure Logic Apps. These steps enable the managed identity on your logic app and set up that identity's access to the target Azure resource.
Before an Azure function can use a managed identity, firstenable authentication for Azure functions.
Before an Azure function can use a managed identity, firstenable authentication for Azure functions.
In the trigger or action that supports using a managed identity, provide this information:Built-in triggers and actionsProperty (designer)Property (JSON)RequiredValueDescriptionAuthenticationtypeYesManaged IdentityorManagedServiceIdentityThe authentication type to useManaged IdentityidentityNo<user-assigned-identity-ID>The user-assigned managed identity to use.Note: Don't include this property when using the system-assigned managed identity.AudienceaudienceYes<target-resource-ID>The resource ID for the target resource that you want to access.For example,https://storage.azure.com/makes theaccess tokensfor authentication valid for all storage accounts. However, you can also specify a root service URL, such ashttps://fabrikamstorageaccount.blob.core.windows.netfor a specific storage account.Note: TheAudienceproperty might be hidden in some triggers or actions. To make this property visible, in the trigger or action, open theAdvanced parameterslist, and selectAudience.Important: Make sure that this target resource IDexactly matchesthe value that Microsoft Entra ID expects, including any required trailing slashes. So, thehttps://storage.azure.com/resource ID for all Azure Blob Storage accounts requires a trailing slash. However, the resource ID for a specific storage account doesn't require a trailing slash. To find these resource IDs, reviewAzure services that support Microsoft Entra ID.When you usesecured parametersto handle and secure sensitive information, for example, in anAzure Resource Manager template for automating deployment, you can use expressions to access these parameter values at runtime. For example, this HTTP action definition specifies the authenticationtypeasManagedServiceIdentityand uses theparameters() functionto get the parameter values:"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "@parameters('endpointUrlParam')",
      "authentication": {
         "type": "ManagedServiceIdentity",
         "audience": "https://management.azure.com/"
      },
   },
   "runAfter": {}
}Managed connector triggers and actionsProperty (designer)RequiredValueDescriptionConnection nameYes<connection-name>Managed identityYesSystem-assigned managed identityor<user-assigned-managed-identity-name>The authentication type to use
In the trigger or action that supports using a managed identity, provide this information:
Built-in triggers and actions
type
ManagedServiceIdentity
identity
audience
https://storage.azure.com/
https://fabrikamstorageaccount.blob.core.windows.net
https://storage.azure.com/
When you usesecured parametersto handle and secure sensitive information, for example, in anAzure Resource Manager template for automating deployment, you can use expressions to access these parameter values at runtime. For example, this HTTP action definition specifies the authenticationtypeasManagedServiceIdentityand uses theparameters() functionto get the parameter values:
type
ManagedServiceIdentity
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "@parameters('endpointUrlParam')",
      "authentication": {
         "type": "ManagedServiceIdentity",
         "audience": "https://management.azure.com/"
      },
   },
   "runAfter": {}
}
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "@parameters('endpointUrlParam')",
      "authentication": {
         "type": "ManagedServiceIdentity",
         "audience": "https://management.azure.com/"
      },
   },
   "runAfter": {}
}
Managed connector triggers and actions

Block creating connections
If your organization doesn't permit connecting to specific resources by using their connectors in Azure Logic Apps, you canblock the capability to create those connectionsfor specific connectors in logic app workflows by usingAzure Policy. For more information, reviewBlock connections created by specific connectors in Azure Logic Apps.

Isolation guidance for logic apps
You can use Azure Logic Apps inAzure Governmentsupporting all impact levels in the regions described by theAzure Government Impact Level 5 Isolation Guidance. To meet these requirements, Azure Logic Apps supports the capability for you to create and run workflows in an environment with dedicated resources so that you can reduce the performance impact by other Azure tenants on your logic apps and avoid sharing computing resources with other tenants.
You can use Azure Logic Apps inAzure Governmentsupporting all impact levels in the regions described by theAzure Government Impact Level 5 Isolation Guidance. To meet these requirements, Azure Logic Apps supports the capability for you to create and run workflows in an environment with dedicated resources so that you can reduce the performance impact by other Azure tenants on your logic apps and avoid sharing computing resources with other tenants.
Standard logic app workflows can privately and securely communicate with an Azure virtual network through private endpoints that you set up for inbound traffic and virtual network integration for outbound traffic. For more information, reviewSecure traffic between virtual networks and single-tenant Azure Logic Apps using private endpoints.
Standard logic app workflows can privately and securely communicate with an Azure virtual network through private endpoints that you set up for inbound traffic and virtual network integration for outbound traffic. For more information, reviewSecure traffic between virtual networks and single-tenant Azure Logic Apps using private endpoints.
To run your own code or perform XML transformation,create and call an Azure function, rather than use theinline code capabilityor provideassemblies to use as maps, respectively. Also, set up the hosting environment for your function app to comply with your isolation requirements.For example, to meet Impact Level 5 requirements, create your function app with theApp Service planusing theIsolatedpricing tieralong with anApp Service Environment (ASE)that also uses theIsolatedpricing tier. In this environment, function apps run on dedicated Azure virtual machines and dedicated Azure virtual networks, which provide network isolation on top of compute isolation for your apps and maximum scale-out capabilities.For more information, review the following documentation:Azure App Service plansAzure Functions networking optionsAzure Dedicated Hosts for virtual machinesVirtual machine isolation in AzureDeploy dedicated Azure services into virtual networks
To run your own code or perform XML transformation,create and call an Azure function, rather than use theinline code capabilityor provideassemblies to use as maps, respectively. Also, set up the hosting environment for your function app to comply with your isolation requirements.
For example, to meet Impact Level 5 requirements, create your function app with theApp Service planusing theIsolatedpricing tieralong with anApp Service Environment (ASE)that also uses theIsolatedpricing tier. In this environment, function apps run on dedicated Azure virtual machines and dedicated Azure virtual networks, which provide network isolation on top of compute isolation for your apps and maximum scale-out capabilities.
For more information, review the following documentation:
Azure App Service plans
Azure Functions networking options
Azure Dedicated Hosts for virtual machines
Virtual machine isolation in Azure
Deploy dedicated Azure services into virtual networks
For more information about isolation, see the following documentation:
Isolation in the Azure Public Cloud
Security for highly sensitive IaaS apps in Azure
Related content
Azure security baseline for Azure Logic Apps
Automate deployment for Azure Logic Apps
Monitor logic apps
Feedback
Was this page helpful?
Additional resources