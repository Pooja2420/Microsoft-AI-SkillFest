Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Build, test, and deploy .NET Core apps
Article
2025-03-30
34 contributors
In this article
Azure DevOps Services | Azure DevOps Server 2022 - Azure DevOps Server 2019
Use an Azure Pipeline to automatically build, test, and deploy your .NET Core projects. This article shows you how to do the following tasks:
Set up your build environment withself-hostedagents.
Restore dependencies, build your project, and test with the.NET Core task (DotNetCoreCLI@2)or ascript.
Test your code and use thepublish code coverage taskto publish code coverage results.
Package and deliver your build output to:your pipeline.aNuGet feed.a.zipfile to deploy aweb app to Azure.
your pipeline.
aNuGet feed.
a.zipfile to deploy aweb app to Azure.
.zip
Set up your build environment withMicrosoft-hostedorself-hostedagents.
Restore dependencies, build your project, and test with the.NET Core task (DotNetCoreCLI@2)or ascript.
Test your code and use thepublish code coverage taskto publish code coverage results.
Package and deliver your build output to:your pipeline.aNuGet feed.a.zipfile to deploy aweb app to Azure.
your pipeline.
aNuGet feed.
a.zipfile to deploy aweb app to Azure.
.zip
Note
For help with .NET Framework projects, seeBuild ASP.NET apps with .NET Framework.
Prerequisites
Create your first pipeline
Are you new to Azure Pipelines? If so, then we recommend you try the following section first.
Create a .NET project
If you don't have a .NET project to work with, create a new one on your local system. Start by installingthe .NET 8.0 SDK.
Open a terminal window.
Open a terminal window.
Create a project directory and navigate to it.
Create a project directory and navigate to it.
Create a new .NET 8 webapp.dotnet new webapp -f net8.0
Create a new .NET 8 webapp.
dotnet new webapp -f net8.0
dotnet new webapp -f net8.0
From the same terminal session, run the application locally using thedotnet runcommand from your project directory.dotnet run
From the same terminal session, run the application locally using thedotnet runcommand from your project directory.
dotnet run
dotnet run
dotnet run
Once the application starts, press Ctrl-C to shut it down.
Once the application starts, press Ctrl-C to shut it down.
Create a git repo and connect it to GitHub
From the project directory,create a local git repository and commit the application code to the main branch.
From the project directory,create a local git repository and commit the application code to the main branch.
Connect your local Git repo to a GitHub repo.
Connect your local Git repo to a GitHub repo.
Create a DevOps project
Create a new Azure DevOps project to host your pipeline.
In a browser, go todev.azure.comand sign in.
Select your organization.
Create a new project by selectingNew projectorCreate projectif creating the first project in the organization.
Enter aProject name.
Select theVisibilityfor your project.
SelectCreate.
In a browser, go to your Azure DevOps Server.
Select your collection.
Create a new project by selectingNew projectorCreate projectif creating the first project in the collection.
Enter aProject name.
Select theVisibilityfor your project.
SelectCreate.
Set up your build environment
Your builds run onself-hosted agents. Make sure that you have the necessary version of the .NET Core SDK and runtime installed on the agents. You can build your .NET Core projects by using the .NET Core SDK and runtime onWindows,Linux,macOS, andDocker.
You can install a specific version of .NET SDK by adding the UseDotNet@2 task in your pipeline YAML file or add the task to your pipeline using the classic editor.
Example YAML snippet:
steps:
- task: UseDotNet@2
  inputs:
    version: '8.x'
steps:
- task: UseDotNet@2
  inputs:
    version: '8.x'
Your builds run onMicrosoft-hosted agents. You can build your .NET Core projects by using the .NET Core SDK and runtime on Windows, Linux, and macOS.
Alternatively, you can use aself-hosted agent. With a self-hosted agent, you can use preview or private SDKs not officially supported by Azure DevOps Services and run incremental builds.
Create your pipeline
You can use the YAML pipeline editor or the classic editor to create your pipeline. To use the classic editor, selectUse the classic editor.
YAML
Classic
Sign in to your Azure DevOps organization and go to your project.
Sign in to your Azure DevOps organization and go to your project.
Go toPipelines, and then selectNew pipelineorCreate pipelineif creating your first pipeline.
Go toPipelines, and then selectNew pipelineorCreate pipelineif creating your first pipeline.
Do the steps of the wizard by first selectingGitHubas the location of your source code.
Do the steps of the wizard by first selectingGitHubas the location of your source code.
You might be redirected to GitHub to sign in. If so, enter your GitHub credentials.
You might be redirected to GitHub to sign in. If so, enter your GitHub credentials.
When you see the list of repositories, select your repository.
When you see the list of repositories, select your repository.
You might be redirected to GitHub to install the Azure Pipelines app. If so, selectApprove & install.
You might be redirected to GitHub to install the Azure Pipelines app. If so, selectApprove & install.
When theConfiguretab appears, selectShow moreand select theASP.NET Corepipeline template from the list.
When theConfiguretab appears, selectShow moreand select theASP.NET Corepipeline template from the list.
Examine your new pipeline to see what the YAML does.
Examine your new pipeline to see what the YAML does.
You can customize the YAML file for your requirements. For example, you can specify the agent pool or add atask to install different .NET SDK.
When you're ready, selectSave and run.
When you're ready, selectSave and run.

Optionally, you can edit the commit message.
Optionally, you can edit the commit message.
Commit the newazure-pipelines.ymlfile to your repository by selectingSave and run.
Commit the newazure-pipelines.ymlfile to your repository by selectingSave and run.
To watch your pipeline in action, select the job in theJobssection.
To watch your pipeline in action, select the job in theJobssection.
Create and run your pipeline
You can create a pipeline by using the YAML pipeline editor or the classic editor.
Go to your project and selectPipelines.
SelectCreate pipelineorNew pipelineif creating the first pipeline for this project.
Select your source repository. For this example, useGitHub Enterprise Server.Enter the URL for your GitHub account. For example,https://github.com/<username>.Enter your personal access token for your GitHub account.Enter a Service connection name. For example,my-github.SelectCreate.
Select your source repository. For this example, useGitHub Enterprise Server.
Enter the URL for your GitHub account. For example,https://github.com/<username>.
https://github.com/<username>
Enter your personal access token for your GitHub account.
Enter a Service connection name. For example,my-github.
my-github
SelectCreate.
Select your GitHub repository.
Select your GitHub repository.
On theConfiguretab, selectShow moreand select theASP.NET Corepipeline template from the list.
On theConfiguretab, selectShow moreand select theASP.NET Corepipeline template from the list.
Examine your new pipeline to see what the YAML does.
Examine your new pipeline to see what the YAML does.
You can customize the YAML file for your requirements. For example, you can add tasks to install a .NET SDK or to test and publish your project.
SelectSave and run.
SelectSave and run.

To commit the newazure-pipelines.ymlfile to your repository, edit the commit message as needed and selectSave and run.
To commit the newazure-pipelines.ymlfile to your repository, edit the commit message as needed and selectSave and run.
To watch your pipeline in action, select the job in theJobssection.
Use these steps to create your pipeline using the classic editor.
Go to your project and selectPipelines.
Go to your project and selectPipelines.
SelectCreate pipelineorNew pipelineif you're not creating the first pipeline for this project.
SelectCreate pipelineorNew pipelineif you're not creating the first pipeline for this project.
SelectUse the classic editor.
SelectUse the classic editor.
Select your source. For this example, selectGitHub Enterprise Server.
SelectConnect to GitHub Enterprise Server.
Enter your GitHub credentials to create a GitHub service connection to use in your pipeline.
Select your repository and selectContinue.
Select your source. For this example, selectGitHub.
Enter your GitHub credentials to create a GitHub service connection to use in your pipeline.
Select your repository and selectContinue.
FromSelect a template, find then selectASP.NET Core.The pipeline page opens where you can configure your pipeline. Here you can add tasks, specify the agent pools and agents and configure other build options.
FromSelect a template, find then selectASP.NET Core.
The pipeline page opens where you can configure your pipeline. Here you can add tasks, specify the agent pools and agents and configure other build options.
In theTaskstab, select yourAgent pool(usuallyDefault)
In theTaskstab, select yourAgent pool(usuallyDefault)
Select theAgent specification. For this example, selectwindows-latest.You can add other tasks to the Agent job by selecting+on the agent job and selecting another task from the catalog. For example, you might want to add theUse .NET Coretask as the first task to install the necessary version of the .NET SDK.
Select theAgent specification. For this example, selectwindows-latest.
You can add other tasks to the Agent job by selecting+on the agent job and selecting another task from the catalog. For example, you might want to add theUse .NET Coretask as the first task to install the necessary version of the .NET SDK.
SelectSave and queuefrom theSave & queuedropdown list at the top of the page.
InRun pipeline, enter a comment and selectSave and Run.
You can see your pipeline in action by selecting the job from theJobssection on theSummarytab.
From theSave & queuedropdown list, selectSave and queue.
From theSave build pipeline and queuedialog, selectSave and queue.
When theBuild #nnnnnnnn.n has been queuedmessage appears, select the link to see your pipeline in action.
From theSave & queuedropdown list at the top of the page, selectSave and queue.
On theRun pipelinedialog, add aSave commentand selectSave and run.
You can see your pipeline in action by selecting the job from theJobssection on theSummarytab.
You now have a working pipeline that's ready for you to customize! Read further to learn some of the common ways to customize your pipeline.
Build environment
Azure Pipelines uses self-hosted agents to build your .NET Core projects. Make sure that you have the necessary version of the .NET Core SDK and runtime installed on the agents. You can build your .NET Core projects by using the .NET Core SDK and runtime onWindows,Linux,macOS, andDocker.
For example, to select a pool and agent capabilities in the pipeline YAML file:
You can select the agent pool and agent for your build job. Agents are specified based on their capabilities.
pool:
  name: myPrivateAgents
  demands:
  - agent.os -equals Darwin
  - anotherCapability -equals somethingElse
pool:
  name: myPrivateAgents
  demands:
  - agent.os -equals Darwin
  - anotherCapability -equals somethingElse
You can install a specific version of .NET SDK by adding the UseDotNet@2 task in your pipeline. Keep in mind that for agents that run on physical systems, installing SDKs and tools through your pipeline alters the build environment on the agent's host.
To install a newer SDK, setperformMultiLevelLookuptotruein the following snippet:
performMultiLevelLookup
true
steps:
- task: UseDotNet@2
  displayName: 'Install .NET Core SDK'
  inputs:
    version: 8.x
    performMultiLevelLookup: true
    includePreviewVersions: true # Required for preview versions
steps:
- task: UseDotNet@2
  displayName: 'Install .NET Core SDK'
  inputs:
    version: 8.x
    performMultiLevelLookup: true
    includePreviewVersions: true # Required for preview versions
You can use Azure Pipelines to build your .NET Core projects on Windows, Linux, or macOS without the need to set up infrastructure.
For example, Ubuntu is set here in the pipeline YAML file.
pool:
  vmImage: 'ubuntu-latest'
pool:
  vmImage: 'ubuntu-latest'
SeeMicrosoft-hosted agentsfor a complete list of images and further configuration examples.
TheMicrosoft-hosted agentsin Azure Pipelines include several preinstalled versions of supported .NET Core SDKs. Microsoft-hosted agents don't include some of the older versions of the .NET Core SDK. They also don't typically include prerelease versions. If you need these versions of the SDK on Microsoft-hosted agents, install them using theUseDotNet@2task.
For example, to install 5.0.x SDK, add the following snippet:
steps:
- task: UseDotNet@2
  inputs:
    version: '5.x'
steps:
- task: UseDotNet@2
  inputs:
    version: '5.x'
Windows agents already include a .NET Core runtime. To install a newer SDK, setperformMultiLevelLookuptotruein the following snippet:
performMultiLevelLookup
true
steps:
- task: UseDotNet@2
  displayName: 'Install .NET Core SDK'
  inputs:
    version: 8.x
    performMultiLevelLookup: true
    includePreviewVersions: true # Required for preview versions
steps:
- task: UseDotNet@2
  displayName: 'Install .NET Core SDK'
  inputs:
    version: 8.x
    performMultiLevelLookup: true
    includePreviewVersions: true # Required for preview versions
Tip
To save the cost of running the tool installer, you can set up aLinux,macOS, orWindowsself-hosted agent.
You can also use self-hosted agents to save time if you have a large repository or you run incremental builds. A self-hosted agent can also help you in using the SDKs that aren't included in Azure DevOps or are only available on your corporate or on-premises environments.
Restore dependencies
NuGet is a popular way to depend on code that you don't build. You can download NuGet packages and project-specific tools that are specified in the project file by running thedotnet restorecommand either through the.NET Coretask or directly in a script in your pipeline. For more information, see.NET Core task (DotNetCoreCLI@2).
dotnet restore
You can download NuGet packages from Azure Artifacts, NuGet.org, or some other external or internal NuGet repository. The.NET Coretask is especially useful to restore packages from authenticated NuGet feeds. If your feed is in the same project as your pipeline, you don't need to authenticate.
This pipeline uses an Azure Artifact feed fordotnet restorein theDotNetCoreCLI@2task.
dotnet restore
trigger:
- main

pool:
  vmImage: 'windows-latest'

steps:
- task: UseDotNet@2
  displayName: 'Install .NET Core SDK'
  inputs:
    version: 8.x
    performMultiLevelLookup: true
    includePreviewVersions: true # Required for preview versions

variables:
  buildConfiguration: 'Release'

steps:
- task: DotNetCoreCLI@2
  inputs:
    command: 'restore'
    feedsToUse: 'select'
    vstsFeed: 'my-vsts-feed' # A series of numbers and letters

- task: DotNetCoreCLI@2
  inputs:
    command: 'build'
    arguments: '--configuration $(buildConfiguration)'
  displayName: 'dotnet build $(buildConfiguration)'
trigger:
- main

pool:
  vmImage: 'windows-latest'

steps:
- task: UseDotNet@2
  displayName: 'Install .NET Core SDK'
  inputs:
    version: 8.x
    performMultiLevelLookup: true
    includePreviewVersions: true # Required for preview versions

variables:
  buildConfiguration: 'Release'

steps:
- task: DotNetCoreCLI@2
  inputs:
    command: 'restore'
    feedsToUse: 'select'
    vstsFeed: 'my-vsts-feed' # A series of numbers and letters

- task: DotNetCoreCLI@2
  inputs:
    command: 'build'
    arguments: '--configuration $(buildConfiguration)'
  displayName: 'dotnet build $(buildConfiguration)'
Thedotnet restorecommand uses theNuGet.exepackaged with the .NET Core SDK and can only restore packages specified in the .NET Core project.csprojfiles.
dotnet restore
NuGet.exe
.csproj
If you also have a Microsoft .NET Framework project in your solution or usepackage.jsonto specify your dependencies, use theNuGettask to restore those dependencies.
package.json
- task: NuGetCommand@2
  inputs:
    command: 'restore'
    restoreSolution: '**/*.sln'
    feedsToUse: 'select'
- task: NuGetCommand@2
  inputs:
    command: 'restore'
    restoreSolution: '**/*.sln'
    feedsToUse: 'select'
Note
If you're using Ubuntu 24.04 or higher, you must use theNuGetAuthenticatetask with the .NET CLI instead of theNuGetCommand@2task. For more information, seeSupport for newer Ubuntu hosted images.
NuGetAuthenticate
NuGetCommand@2
In .NET Core SDK version 2.0 and newer, packages are restored automatically when running commands such asdotnet build. However, you would still need to use the.NET Coretask to restore packages if you use an authenticated feed.
dotnet build
Your builds can fail because of connection issues when you restore packages from NuGet.org. You can use Azure Artifacts withupstream sourcesto cache the packages. The credentials of the pipeline are automatically used when it connects to Azure Artifacts. These credentials are typically derived from theProject Collection Build Serviceaccount. To learn more about using Azure Artifacts to cache your NuGet packages, seeConnect to Azure Artifact feeds.
To specify a NuGet repository, put the URL in aNuGet.configfile in your repository. If your feed is authenticated, manage its credentials by creating a NuGet service connection in theServicestab underProject Settings.
NuGet.config
When you use Microsoft-hosted agents, you get a new machine every time you run a build, which restores the packages with each run. Restoration can take a significant amount of time. To mitigate, you can either use Azure Artifacts or a self-hosted agent with the benefit of using the package cache.
For more information about NuGet service connections, seepublish to NuGet feeds.
Restore packages from an external feed
Do the following to restore packages from an external feed.
YAML
Classic
You can add the restore command to your pipeline using the YAML pipeline editor by directly inserting the following snippet into yourazure-pipelines.ymlfile or using the task assistant to add the.NET Coretask.
azure-pipelines.yml
# do this before your build tasks
steps:
- task: DotNetCoreCLI@2
  displayName: Restore
  inputs:
    command: restore
    projects: '**/*.csproj'
    feedsToUse: config
    nugetConfigPath: NuGet.config    # Relative to root of the repository
    externalFeedCredentials: <Name of the NuGet service connection>
# do this before your build tasks
steps:
- task: DotNetCoreCLI@2
  displayName: Restore
  inputs:
    command: restore
    projects: '**/*.csproj'
    feedsToUse: config
    nugetConfigPath: NuGet.config    # Relative to root of the repository
    externalFeedCredentials: <Name of the NuGet service connection>
Replace the <placeholder> with your service connection name.
To use the task assistant:
To add a build task using the task assistant, do the following steps:
Go to the position in the YAML file where you want to insert the task.
Go to the position in the YAML file where you want to insert the task.
Select the.NET Corefrom the task catalog.
Select the.NET Corefrom the task catalog.
Select therestorecommand from theCommanddropdown list.
Select therestorecommand from theCommanddropdown list.
In thePath to project(s)field, enter the path to your.csprojfiles.
In thePath to project(s)field, enter the path to your.csprojfiles.
.csproj
SelectAdd.
SelectAdd.
SelectSaveto commit the change.
SelectSaveto commit the change.
Use these steps to add a restore task using the classic editor:
SelectTasksin your pipeline and select the job that runs your build tasks.
SelectTasksin your pipeline and select the job that runs your build tasks.
Select+to add a new task to that job.
Select+to add a new task to that job.
In the task catalog, find and select.NET Coretask and selectAdd.
In the task catalog, find and select.NET Coretask and selectAdd.
Select the task to open the task editor.
Select the task to open the task editor.
Selectrestorein theCommandlist and specify any other options you need for this task.
Selectrestorein theCommandlist and specify any other options you need for this task.
In the task list, drag the task to position it before the build task.
In the task list, drag the task to position it before the build task.
From theSave & queuedropdown list, select an option to save the change.
From theSave & queuedropdown list, select an option to save the change.
Note
Make sure the custom feed is specified in yourNuGet.configfile and that credentials are specified in the NuGet service connection.
NuGet.config
Build your project
Build your .NET Core projects by running thedotnet buildcommand. You can add the command to your pipeline as a command line script or by using the .NET Core task.
dotnet build
Build with the .NET Core task
YAML example to build using the DotNetCoreCLI@2 task:
steps:
- task: DotNetCoreCLI@2
  displayName: Build
  inputs:
    command: build
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfiguration)' # Update this to match your needs
steps:
- task: DotNetCoreCLI@2
  displayName: Build
  inputs:
    command: build
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfiguration)' # Update this to match your needs
YAML
Classic
You can add a build task using the YAML pipeline editor by directly editing the file or adding the.NET Coretask using the task assistant.
To add a build task using the task assistant, do the following steps:
Go to the position in the YAML file where you want to insert the task.
Go to the position in the YAML file where you want to insert the task.
Select the.NET Corefrom the task catalog.
Select the.NET Corefrom the task catalog.
Select thebuildcommand from theCommanddropdown list.
Select thebuildcommand from theCommanddropdown list.
In thePath to project(s)field, enter the path to your.csprojfiles.
In thePath to project(s)field, enter the path to your.csprojfiles.
.csproj
SelectAdd.
SelectAdd.
SelectSaveto commit the change.
SelectSaveto commit the change.
To add a build task using  the classic editor, do the following steps:
SelectTasksin your pipeline.
SelectTasksin your pipeline.
Select the job that runs your build tasks.
Select the job that runs your build tasks.
Select+to add a new task to that job.
Select+to add a new task to that job.
In the task catalog, find and add the.NET Coretask.
In the task catalog, find and add the.NET Coretask.
Select the task and selectbuildfrom theCommanddropdown list.
Select the task and selectbuildfrom theCommanddropdown list.
In thePath to project(s)field, enter the path to your.csprojfiles.
In thePath to project(s)field, enter the path to your.csprojfiles.
.csproj
Drag the task to position it in the correct task sequence in the pipeline.
Drag the task to position it in the correct task sequence in the pipeline.
Select theSave and queuedropdown list and select an option to save your changes.
Select theSave and queuedropdown list and select an option to save your changes.
Build .NET Core with a command line script
YAML example to build usingdotnet buildas a script:
dotnet build
steps:
- script: dotnet build --configuration $(buildConfiguration)
  displayName: 'dotnet build $(buildConfiguration)'
steps:
- script: dotnet build --configuration $(buildConfiguration)
  displayName: 'dotnet build $(buildConfiguration)'
YAML
Classic
You can add a build task using the YAML pipeline editor by directly editing the file or adding theCommand Linetask.
Use the following steps to add theCommand Linetask:
Go to the position in the YAML file where you want to insert the task.
Go to the position in the YAML file where you want to insert the task.
Select theCommand Linefrom the task catalog.
Select theCommand Linefrom the task catalog.
Optionally, add aDisplay name.
Optionally, add aDisplay name.
Enter thedotnet buildcommand with parameters. For example,dotnet build --configuration $(buildConfiguration).
Enter thedotnet buildcommand with parameters. For example,dotnet build --configuration $(buildConfiguration).
dotnet build
dotnet build --configuration $(buildConfiguration)
Enter the path to the.csprojfile as the working directory.
Enter the path to the.csprojfile as the working directory.
.csproj
SelectAdd.
SelectAdd.
SelectSaveto commit the change.
SelectSaveto commit the change.
To add a build task using  the classic editor, do the following steps:
SelectTasksin your pipeline.
SelectTasksin your pipeline.
Select the job that runs your build tasks.
Select the job that runs your build tasks.
Select+to add a new task to that job.
Select+to add a new task to that job.
In the task catalog, find andAddtheCommand Linetask.
In the task catalog, find andAddtheCommand Linetask.
Optionally, add aDisplay name.
Optionally, add aDisplay name.
Enter thedotnet buildcommand with parameters. For example,dotnet build --configuration $(buildConfiguration).
Enter thedotnet buildcommand with parameters. For example,dotnet build --configuration $(buildConfiguration).
dotnet build
dotnet build --configuration $(buildConfiguration)
Enter the path to the.csprojfile as the working directory.
Enter the path to the.csprojfile as the working directory.
.csproj
Drag the task to position it in the correct task sequence in the pipeline.
Drag the task to position it in the correct task sequence in the pipeline.
Select theSave and queuedropdown list and select an option to save your changes.
Select theSave and queuedropdown list and select an option to save your changes.
Add .NET SDK commands to your pipeline
You can add .NET SDK commands to your project as a script or using the .NET Core task. The.NET Core task (DotNetCoreCLI@2)task allows you to easily add dotnet CLI commands to your pipeline. You can add.NET Coretasks by editing your YAML file or using the classic editor.
Add a .NET CLI command with the .NET Core task
YAML
Classic
To add a .NET Core CLI command using the YAML pipeline editor, do the following steps:
Go to the position in the YAML file where you want to insert the task.
Go to the position in the YAML file where you want to insert the task.
Select.NET Corefrom the task catalog.
Select.NET Corefrom the task catalog.
Select the command you want to run.
Select the command you want to run.
Configure any options needed.
Configure any options needed.
SelectAdd.
SelectAdd.
SelectSaveto commit the change.
SelectSaveto commit the change.
To add .NET Core task using  the classic editor, do the following steps:
SelectTasksin your pipeline.
SelectTasksin your pipeline.
Select the job that runs your build tasks.
Select the job that runs your build tasks.
Select+to add a new task to that job.
Select+to add a new task to that job.
In the task catalog, find and add the.NET Coretask.
In the task catalog, find and add the.NET Coretask.
Select the task and select theCommandthat you want to run.
Select the task and select theCommandthat you want to run.
Configure any options needed.
Configure any options needed.
Drag the task to position it in the correct task sequence in the pipeline.
Drag the task to position it in the correct task sequence in the pipeline.
From theSave and queuedropdown list, select an option to save your changes.
From theSave and queuedropdown list, select an option to save your changes.
Add a .NET Core CLI command in a script
You can add .NET Core CLI commands as ascriptin yourazure-pipelines.ymlfile.
script
azure-pipelines.yml
Example:
steps:
# ...
- script: dotnet test <test-project>
steps:
# ...
- script: dotnet test <test-project>
Install a tool
To install a .NET Core global tool likedotnetsayin your build running on Windows, take the following steps:
Add the.NET Coretask and set the following properties:Command: custom.Path to projects:leave empty.Custom command: tool.Arguments:install -g dotnetsay.
Command: custom.Path to projects:leave empty.
Path to projects:leave empty.
Custom command: tool.
Arguments:install -g dotnetsay.
install -g dotnetsay
To run the tool, add aCommand Lineand set the following properties:Script:dotnetsay.
Script:dotnetsay.
dotnetsay
Run your tests
When you have test projects in your repository, you can use the.NET Coretask to run unit tests by using testing frameworks like MSTest, xUnit, and NUnit. The test project must referenceMicrosoft.NET.Test.SDKversion 15.8.0 or higher.
Test results are automatically published to the service. These results are available to you in the build summary and can be used for troubleshooting failed tests and test-timing analysis.
You can add a test task to your pipeline using theDotNetCoreCLI@2task or add the following snippet to yourazure-pipelines.ymlfile:
azure-pipelines.yml
steps:
# ...
# do this after other tasks such as building
- task: DotNetCoreCLI@2
  inputs:
    command: test
    projects: '**/*Tests/*.csproj'
    arguments: '--configuration $(buildConfiguration)'
steps:
# ...
# do this after other tasks such as building
- task: DotNetCoreCLI@2
  inputs:
    command: test
    projects: '**/*Tests/*.csproj'
    arguments: '--configuration $(buildConfiguration)'
When using the.NET Coretask editor, setCommandtotestandPath to projectsshould refer to the test projects in your solution.
Alternatively, you can run thedotnet testcommand with a specific logger and then use thePublish Test Resultstask:
dotnet test
steps:
# ...
# do this after your tests have run
- script: dotnet test <test-project> --logger trx
- task: PublishTestResults@2
  condition: succeededOrFailed()
  inputs:
    testRunner: VSTest
    testResultsFiles: '**/*.trx'
steps:
# ...
# do this after your tests have run
- script: dotnet test <test-project> --logger trx
- task: PublishTestResults@2
  condition: succeededOrFailed()
  inputs:
    testRunner: VSTest
    testResultsFiles: '**/*.trx'
Collect code coverage
When you're building on the Windows platform, code coverage metrics can be collected by using the built-in coverage data collector. The test project must referenceMicrosoft.NET.Test.SDKversion 15.8.0 or higher.
When you use the.NET Coretask to run tests, coverage data is automatically published to the server. The.coveragefile can be downloaded from the build summary for viewing in Visual Studio.
.coverage
Add the following snippet to yourazure-pipelines.ymlfile:
azure-pipelines.yml
steps:
# ...
# do this after other tasks such as building
- task: DotNetCoreCLI@2
  inputs:
    command: test
    projects: '**/*Tests/*.csproj'
    arguments: '--configuration $(buildConfiguration) --collect "Code Coverage"'
steps:
# ...
# do this after other tasks such as building
- task: DotNetCoreCLI@2
  inputs:
    command: test
    projects: '**/*Tests/*.csproj'
    arguments: '--configuration $(buildConfiguration) --collect "Code Coverage"'
To add the.NET Coretask through the task editor:
Add the .NET Core task to your build job and set the following properties:Command: test.Path to projects:Should refer to the test projects in your solution.Arguments:--configuration $(BuildConfiguration) --collect "Code Coverage".
Add the .NET Core task to your build job and set the following properties:
Command: test.
Path to projects:Should refer to the test projects in your solution.
Arguments:--configuration $(BuildConfiguration) --collect "Code Coverage".
--configuration $(BuildConfiguration) --collect "Code Coverage"
Ensure that thePublish test resultsoption remains selected.
Ensure that thePublish test resultsoption remains selected.
If you choose to run thedotnet testcommand, specify the test results logger and coverage options. Then use thePublish Test Resultstask:
dotnet test
steps:
# ...
# do this after your tests have run
- script: dotnet test <test-project> --logger trx --collect "Code Coverage"
- task: PublishTestResults@2
  inputs:
    testRunner: VSTest
    testResultsFiles: '**/*.trx'
steps:
# ...
# do this after your tests have run
- script: dotnet test <test-project> --logger trx --collect "Code Coverage"
- task: PublishTestResults@2
  inputs:
    testRunner: VSTest
    testResultsFiles: '**/*.trx'
Collect code coverage metrics with Coverlet
If you're building on Linux or macOS, you can useCoverletor a similar tool to collect code coverage metrics.
You can publish code coverage results to the server with thePublish Code Coverage Results task (PublishCodeCoverageResults@2)task. The coverage tool must be configured to generate results in Cobertura or JaCoCo coverage format.
To run tests and publish code coverage with Coverlet, do the following tasks:
Add a reference to thecoverlet.collectorNuGet package.
Add a reference to thecoverlet.collectorNuGet package.
coverlet.collector
Add the following snippet to yourazure-pipelines.ymlfile:- task: UseDotNet@2
  inputs:
    version: '8.x'
    includePreviewVersions: true # Required for preview versions

- task: DotNetCoreCLI@2
  displayName: 'dotnet build'
  inputs:
    command: 'build'
    configuration: $(buildConfiguration)

- task: DotNetCoreCLI@2
  displayName: 'dotnet test'
  inputs:
    command: 'test'
    arguments: '--configuration $(buildConfiguration) --collect:"XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura'
    publishTestResults: true
    projects: 'MyTestLibrary' # update with your test project directory

- task: PublishCodeCoverageResults@2
  displayName: 'Publish code coverage report'
  inputs:
    codeCoverageTool: 'Cobertura'
    summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
Add the following snippet to yourazure-pipelines.ymlfile:
azure-pipelines.yml
- task: UseDotNet@2
  inputs:
    version: '8.x'
    includePreviewVersions: true # Required for preview versions

- task: DotNetCoreCLI@2
  displayName: 'dotnet build'
  inputs:
    command: 'build'
    configuration: $(buildConfiguration)

- task: DotNetCoreCLI@2
  displayName: 'dotnet test'
  inputs:
    command: 'test'
    arguments: '--configuration $(buildConfiguration) --collect:"XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura'
    publishTestResults: true
    projects: 'MyTestLibrary' # update with your test project directory

- task: PublishCodeCoverageResults@2
  displayName: 'Publish code coverage report'
  inputs:
    codeCoverageTool: 'Cobertura'
    summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
- task: UseDotNet@2
  inputs:
    version: '8.x'
    includePreviewVersions: true # Required for preview versions

- task: DotNetCoreCLI@2
  displayName: 'dotnet build'
  inputs:
    command: 'build'
    configuration: $(buildConfiguration)

- task: DotNetCoreCLI@2
  displayName: 'dotnet test'
  inputs:
    command: 'test'
    arguments: '--configuration $(buildConfiguration) --collect:"XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura'
    publishTestResults: true
    projects: 'MyTestLibrary' # update with your test project directory

- task: PublishCodeCoverageResults@2
  displayName: 'Publish code coverage report'
  inputs:
    codeCoverageTool: 'Cobertura'
    summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
Package and deliver your code
You can publish your build artifacts by:
Publishing to Azure Pipelines.
Publishing packages to Azure Artifacts.
Creating a NuGet package and publish to your NuGet feed.
Creating a.ziparchive to deploy your web app.
Publish artifacts to Azure Pipelines
To publish the output of your .NETbuildto your pipeline, do the following tasks:
Rundotnet publish --output $(Build.ArtifactStagingDirectory)on the .NET CLI or add theDotNetCoreCLI@2task with the publish command.
dotnet publish --output $(Build.ArtifactStagingDirectory)
Publish the artifact by using thePublish Pipeline Artifacttask.
Add the following snippet to yourazure-pipelines.ymlfile:
azure-pipelines.yml
steps:

- task: DotNetCoreCLI@2
  inputs:
    command: publish
    publishWebProjects: True
    arguments: '--configuration $(BuildConfiguration) --output $(Build.ArtifactStagingDirectory)'
    zipAfterPublish: True

# this code takes all the files in $(Build.ArtifactStagingDirectory) and uploads them as an artifact of your build.
- task: PublishPipelineArtifact@1
  inputs:
    targetPath: '$(Build.ArtifactStagingDirectory)' 
    artifactName: 'myWebsite'
steps:

- task: DotNetCoreCLI@2
  inputs:
    command: publish
    publishWebProjects: True
    arguments: '--configuration $(BuildConfiguration) --output $(Build.ArtifactStagingDirectory)'
    zipAfterPublish: True

# this code takes all the files in $(Build.ArtifactStagingDirectory) and uploads them as an artifact of your build.
- task: PublishPipelineArtifact@1
  inputs:
    targetPath: '$(Build.ArtifactStagingDirectory)' 
    artifactName: 'myWebsite'
Note
TheDotNetCoreCLI@2task has apublishWebProjectsinput that is set totrueby default. This task publishesallweb projects in your repo by default. You can find more help and information in theopen source task on GitHub.
publishWebProjects
To copy more files to the build directory before publishing, use theCopy Files (CopyFile@2)task.
To publish the output of your .NETbuildto your pipeline, do the following tasks:
Rundotnet publish --output $(Build.ArtifactStagingDirectory)on CLI or add theDotNetCoreCLI@2task with the publish command.
dotnet publish --output $(Build.ArtifactStagingDirectory)
Publish the artifact by using thePublish build artifact (PublishBuildArtifacts@1)task.
To publish your build artifacts as a .zip file, add the following snippet to yourazure-pipelines.ymlfile:
azure-pipelines.yml
steps:

- task: DotNetCoreCLI@2
  inputs:
    command: publish
    publishWebProjects: True
    arguments: '--configuration $(BuildConfiguration) --output $(Build.ArtifactStagingDirectory)'
    zipAfterPublish: True

# this code takes all the files in $(Build.ArtifactStagingDirectory) and uploads them as an artifact of your build.
- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'drop'
steps:

- task: DotNetCoreCLI@2
  inputs:
    command: publish
    publishWebProjects: True
    arguments: '--configuration $(BuildConfiguration) --output $(Build.ArtifactStagingDirectory)'
    zipAfterPublish: True

# this code takes all the files in $(Build.ArtifactStagingDirectory) and uploads them as an artifact of your build.
- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'drop'
For more information, seePublish and download build artifacts.
Publish to a NuGet feed
To create a NuGet package and publish it to your NuGet feed, add the following snippet:
steps:
# ...
# do this near the end of your pipeline in most cases
- script: dotnet pack /p:PackageVersion=$(version)  # define version variable elsewhere in your pipeline
- task: NuGetAuthenticate@1
  inputs:
    nuGetServiceConnections: '<Name of the NuGet service connection>'
- task: NuGetCommand@2
  inputs:
    command: push
    nuGetFeedType: external
    publishFeedCredentials: '<Name of the NuGet service connection>'
    versioningScheme: byEnvVar
    versionEnvVar: version
steps:
# ...
# do this near the end of your pipeline in most cases
- script: dotnet pack /p:PackageVersion=$(version)  # define version variable elsewhere in your pipeline
- task: NuGetAuthenticate@1
  inputs:
    nuGetServiceConnections: '<Name of the NuGet service connection>'
- task: NuGetCommand@2
  inputs:
    command: push
    nuGetFeedType: external
    publishFeedCredentials: '<Name of the NuGet service connection>'
    versioningScheme: byEnvVar
    versionEnvVar: version
Note
The NuGetAuthenticate@1 task doesn't support NuGet API key authentication. If you're using a NuGet API key, use the NuGetCommand@2 task with thecommandinput set topushwith the--api-keyargument. For example,dotnet nuget push --api-key $(NuGetApiKey).
command
push
--api-key
dotnet nuget push --api-key $(NuGetApiKey)
For more information about versioning and publishing NuGet packages, seepublish to NuGet feeds.
Publish a NuGet package to Azure Artifacts
You can publish your NuGet packages to your Azure Artifacts feed by using theNuGetCommand@2to push to your Azure Artifact feed. For example, seePublish NuGet packages with Azure Pipelines.
Deploy a web app
To create a .zip file archive that's ready to publish to a web app, add the following snippet:
steps:
# ...
# do this after you've built your app, near the end of your pipeline in most cases
# for example, you do this before you deploy to an Azure web app on Windows
- task: DotNetCoreCLI@2
  inputs:
    command: publish
    publishWebProjects: True
    arguments: '--configuration $(BuildConfiguration) --output $(Build.ArtifactStagingDirectory)'
    zipAfterPublish: True
steps:
# ...
# do this after you've built your app, near the end of your pipeline in most cases
# for example, you do this before you deploy to an Azure web app on Windows
- task: DotNetCoreCLI@2
  inputs:
    command: publish
    publishWebProjects: True
    arguments: '--configuration $(BuildConfiguration) --output $(Build.ArtifactStagingDirectory)'
    zipAfterPublish: True
To publish this archive to a web app, seeAzure Web Apps deployment.
Build an image and push to container registry
You can alsobuild an imagefor your app andpush it to a container registry.

Publish symbols
You can use thePublishSymbols@2task to publish symbols to an Azure Artifacts symbol server or a file share.
For example, to publish symbols to a file share, add the following snippet to yourazure-pipelines.ymlfile:
azure-pipelines.yml
- task: PublishSymbols@2
  inputs:
    SymbolsFolder: '$(Build.SourcesDirectory)'
    SearchPattern: '**/bin/**/*.pdb'
    IndexSources: true
    PublishSymbols: true
    SymbolServerType: 'FileShare' 
    SymbolsPath: '\\server\shareName'
- task: PublishSymbols@2
  inputs:
    SymbolsFolder: '$(Build.SourcesDirectory)'
    SearchPattern: '**/bin/**/*.pdb'
    IndexSources: true
    PublishSymbols: true
    SymbolServerType: 'FileShare' 
    SymbolsPath: '\\server\shareName'
When using the classic editor, selectIndex sources publish symbolsfrom the task catalog to add to your pipeline.
For more information, seePublish symbols.
Troubleshoot
If you can build your project on your development machine, but you're having trouble building it on Azure Pipelines, explore the following potential causes and corrective actions:
Prerelease versions of the .NET Core SDK aren't installed on Microsoft-hosted agents. After a new version of the .NET Core SDK is released, it can take a few weeks to roll out to all the Azure Pipelines data centers. You don't have to wait for this rollout to complete. You can use theUse .NET Coretask to install the .NET Core SDK version you want on Microsoft-hosted agents.
Check the .NET Core SDK versions and runtime on your development machine and make sure they match the agent. You can include a command-line scriptdotnet --versionin your pipeline to print the version of the .NET Core SDK. Either use the.NET Core Tool Installerto deploy the same version on the agent, or update your projects and development machine to the newer version of the .NET Core SDK.
Check the .NET Core SDK versions and runtime on your development machine and make sure they match the agent. You can include a command-line scriptdotnet --versionin your pipeline to print the version of the .NET Core SDK. Either use the.NET Core Tool Installerto deploy the same version on the agent, or update your projects and development machine to the newer version of the .NET Core SDK.
dotnet --version
You might be using some logic in the Visual Studio IDE that isn't encoded in your pipeline.
Azure Pipelines runs each of the commands you specify in the tasks one after the other in a new process.
Examine the logs from the pipelines build to see the exact commands that ran as part of the build.
To locate the problem, repeat the same commands in the same order on your development machine.
You might be using some logic in the Visual Studio IDE that isn't encoded in your pipeline.
Azure Pipelines runs each of the commands you specify in the tasks one after the other in a new process.
Examine the logs from the pipelines build to see the exact commands that ran as part of the build.
To locate the problem, repeat the same commands in the same order on your development machine.
If you have a mixed solution that includes some .NET Core projects and some .NET Framework projects,
you should also use theNuGettask to restore packages specified inpackages.configfiles.
Add theMSBuildorVisual Studio Buildtask to build the .NET Framework projects.
If you have a mixed solution that includes some .NET Core projects and some .NET Framework projects,
you should also use theNuGettask to restore packages specified inpackages.configfiles.
Add theMSBuildorVisual Studio Buildtask to build the .NET Framework projects.
packages.config
Your builds might fail intermittently while restoring packages: either NuGet.org is having issues or there are networking problems between the Azure data center and NuGet.org. You can explore whether using Azure Artifacts with NuGet.org as an upstream source improves the reliability of your builds, as it's not in our control.
Your builds might fail intermittently while restoring packages: either NuGet.org is having issues or there are networking problems between the Azure data center and NuGet.org. You can explore whether using Azure Artifacts with NuGet.org as an upstream source improves the reliability of your builds, as it's not in our control.
Occasionally, a when new version of the .NET Core SDK or Visual Studio is rolled out, your build might break. For example, a newer version or feature of the NuGet tool is shipped with the SDK could break your build. To isolate this issue, use the.NET Core Tool Installertask to specify the version of the .NET Core SDK used in your build.
Occasionally, a when new version of the .NET Core SDK or Visual Studio is rolled out, your build might break. For example, a newer version or feature of the NuGet tool is shipped with the SDK could break your build. To isolate this issue, use the.NET Core Tool Installertask to specify the version of the .NET Core SDK used in your build.
FAQ
Q: Where can I learn more about Azure Artifacts?
A:Azure Artifacts
Q: Where can I learn more about .NET Core commands?
A:.NET Core CLI tools
Q: Where can I learn more about running tests in my solution?
A:Unit testing in .NET Core projects
Q: Where can I learn more about tasks?
A:Build and release tasks
Feedback
Was this page helpful?
Additional resources