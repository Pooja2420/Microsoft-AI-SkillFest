Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Connect Azure Functions to Azure Storage using Visual Studio Code
Article
2024-04-26
15 contributors
In this article
Azure Functions lets you connect Azure services and other resources to functions without having to write your own integration code. Thesebindings, which represent both input and output, are declared within the function definition. Data from bindings is provided to the function as parameters. Atriggeris a special type of input binding. Although a function has only one trigger, it can have multiple input and output bindings. To learn more, seeAzure Functions triggers and bindings concepts.
In this article, you learn how to use Visual Studio Code to connect Azure Storage to the function you created in the previous quickstart article. The output binding that you add to this function writes data from the HTTP request to a message in an Azure Queue storage queue.
Most bindings require a stored connection string that Functions uses to access the bound service. To make it easier, you use the storage account that you created with your function app. The connection to this account is already stored in an app setting namedAzureWebJobsStorage.
AzureWebJobsStorage
Note
This article currently supportsNode.js v4 for Functions.
Configure your local environment
Before you begin, you must meet the following requirements:
Install theAzure Storage extension for Visual Studio Code.
Install theAzure Storage extension for Visual Studio Code.
InstallAzure Storage Explorer. Storage Explorer is a tool that you'll use to examine queue messages generated by your output binding. Storage Explorer is supported on macOS, Windows, and Linux-based operating systems.
InstallAzure Storage Explorer. Storage Explorer is a tool that you'll use to examine queue messages generated by your output binding. Storage Explorer is supported on macOS, Windows, and Linux-based operating systems.
Install.NET Core CLI tools.
Install.NET Core CLI tools.
Complete the steps inpart 1 of the Visual Studio Code quickstart.
Complete the steps inpart 1 of the Visual Studio Code quickstart.
Complete the steps inpart 1 of the Visual Studio Code quickstart.
Complete the steps inpart 1 of the Visual Studio Code quickstart.
Complete the steps inpart 1 of the Visual Studio Code quickstart.
Complete the steps inpart 1 of the Visual Studio Code quickstart.
Complete the steps inpart 1 of the Visual Studio Code quickstart.
This article assumes that you're already signed in to your Azure subscription from Visual Studio Code. You can sign in by runningAzure: Sign Infrom the command palette.
Azure: Sign In
Download the function app settings
In theprevious quickstart article, you created a function app in Azure along with the required storage account. The connection string for this account is stored securely in the app settings in Azure. In this article, you write messages to a Storage queue in the same account. To connect to your storage account when running the function locally, you must download app settings to thelocal.settings.jsonfile.
PressF1to open the command palette, then search for and run the commandAzure Functions: Download Remote Settings....
PressF1to open the command palette, then search for and run the commandAzure Functions: Download Remote Settings....
Azure Functions: Download Remote Settings...
Choose the function app you created in the previous article. SelectYes to allto overwrite the existing local settings.ImportantBecause thelocal.settings.jsonfile contains secrets, it never gets published, and is excluded from the source control.
Choose the function app you created in the previous article. SelectYes to allto overwrite the existing local settings.
Important
Because thelocal.settings.jsonfile contains secrets, it never gets published, and is excluded from the source control.
Copy the valueAzureWebJobsStorage, which is the key for the storage account connection string value. You use this connection to verify that the output binding works as expected.
Copy the valueAzureWebJobsStorage, which is the key for the storage account connection string value. You use this connection to verify that the output binding works as expected.
AzureWebJobsStorage
Register binding extensions
Because you're using a Queue storage output binding, you must have the Storage bindings extension installed before you run the project.
Your project has been configured to useextension bundles, which automatically installs a predefined set of extension packages.
Extension bundles is already enabled in thehost.jsonfile at the root of the project, which should look like the following example:
{
  "version": "2.0",
  "extensionBundle": {
    "id": "Microsoft.Azure.Functions.ExtensionBundle",
    "version": "[3.*, 4.0.0)"
  }
}
{
  "version": "2.0",
  "extensionBundle": {
    "id": "Microsoft.Azure.Functions.ExtensionBundle",
    "version": "[3.*, 4.0.0)"
  }
}
Now, you can add the storage output binding to your project.
Your project has been configured to useextension bundles, which automatically installs a predefined set of extension packages.
Extension bundles is already enabled in thehost.jsonfile at the root of the project, which should look like the following example:
{
  "version": "2.0",
  "logging": {
    "applicationInsights": {
      "samplingSettings": {
        "isEnabled": true,
        "excludedTypes": "Request"
      }
    }
  },
  "extensionBundle": {
    "id": "Microsoft.Azure.Functions.ExtensionBundle",
    "version": "[4.*, 5.0.0)"
  }
}
{
  "version": "2.0",
  "logging": {
    "applicationInsights": {
      "samplingSettings": {
        "isEnabled": true,
        "excludedTypes": "Request"
      }
    }
  },
  "extensionBundle": {
    "id": "Microsoft.Azure.Functions.ExtensionBundle",
    "version": "[4.*, 5.0.0)"
  }
}
Now, you can add the storage output binding to your project.
Except for HTTP and timer triggers, bindings are implemented as extension packages. Run the followingdotnet add packagecommand in the Terminal window to add the Storage extension package to your project.
Isolated process
In-process
dotnet add package Microsoft.Azure.Functions.Worker.Extensions.Storage.Queues --prerelease
dotnet add package Microsoft.Azure.Functions.Worker.Extensions.Storage.Queues --prerelease
dotnet add package Microsoft.Azure.WebJobs.Extensions.Storage
dotnet add package Microsoft.Azure.WebJobs.Extensions.Storage
Now, you can add the storage output binding to your project.
Add an output binding
To write to an Azure Storage queue:
Add anextraOutputsproperty to the binding configuration{
    methods: ['GET', 'POST'],
    extraOutputs: [sendToQueue], // add output binding to HTTP trigger
    authLevel: 'anonymous',
    handler: () => {}
}
Add anextraOutputsproperty to the binding configuration
extraOutputs
{
    methods: ['GET', 'POST'],
    extraOutputs: [sendToQueue], // add output binding to HTTP trigger
    authLevel: 'anonymous',
    handler: () => {}
}
{
    methods: ['GET', 'POST'],
    extraOutputs: [sendToQueue], // add output binding to HTTP trigger
    authLevel: 'anonymous',
    handler: () => {}
}
Add aoutput.storageQueuefunction above theapp.httpcallconst sendToQueue = output.storageQueue({
  queueName: 'outqueue',
  connection: 'AzureWebJobsStorage',
});
Add aoutput.storageQueuefunction above theapp.httpcall
output.storageQueue
app.http
const sendToQueue = output.storageQueue({
  queueName: 'outqueue',
  connection: 'AzureWebJobsStorage',
});
const sendToQueue = output.storageQueue({
  queueName: 'outqueue',
  connection: 'AzureWebJobsStorage',
});
To write to an Azure Storage queue:
Add anextraOutputsproperty to the binding configuration{
    methods: ['GET', 'POST'],
    extraOutputs: [sendToQueue], // add output binding to HTTP trigger
    authLevel: 'anonymous',
    handler: () => {}
}
Add anextraOutputsproperty to the binding configuration
extraOutputs
{
    methods: ['GET', 'POST'],
    extraOutputs: [sendToQueue], // add output binding to HTTP trigger
    authLevel: 'anonymous',
    handler: () => {}
}
{
    methods: ['GET', 'POST'],
    extraOutputs: [sendToQueue], // add output binding to HTTP trigger
    authLevel: 'anonymous',
    handler: () => {}
}
Add aoutput.storageQueuefunction above theapp.httpcallconst sendToQueue: StorageQueueOutput = output.storageQueue({
  queueName: 'outqueue',
  connection: 'AzureWebJobsStorage',
});
Add aoutput.storageQueuefunction above theapp.httpcall
output.storageQueue
app.http
const sendToQueue: StorageQueueOutput = output.storageQueue({
  queueName: 'outqueue',
  connection: 'AzureWebJobsStorage',
});
const sendToQueue: StorageQueueOutput = output.storageQueue({
  queueName: 'outqueue',
  connection: 'AzureWebJobsStorage',
});
In Functions, each type of binding requires adirection,type, and uniquename. The way you define these attributes depends on the language of your function app.
direction
type
name
Binding attributes are defined in thefunction.jsonfile for a given function. Depending on the binding type, additional properties may be required. Thequeue output configurationdescribes the fields required for an Azure Storage queue binding. The extension makes it easy to add bindings to thefunction.jsonfile.
To create a binding, right-click (Ctrl+click on macOS) thefunction.jsonfile in your HttpTrigger folder and chooseAdd binding.... Follow the prompts to define the following binding properties for the new binding:
function.json
out
Azure Queue Storage
msg
outqueue
AzureWebJobsStorage
AzureWebJobsStorage
A binding is added to thebindingsarray in yourfunction.json, which should look like the following:
bindings
"name": "msg",
      "queueName": "outqueue",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
"name": "msg",
      "queueName": "outqueue",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
Binding attributes are defined by decorating specific function code in thefunction_app.pyfile. You use thequeue_outputdecorator to add anAzure Queue storage output binding.
queue_output
By using thequeue_outputdecorator, the binding direction is implicitly 'out' and type is Azure Storage Queue. Add the following decorator to your function code inHttpExample\function_app.py:
queue_output
@app.queue_output(arg_name="msg", queue_name="outqueue", connection="AzureWebJobsStorage")
@app.queue_output(arg_name="msg", queue_name="outqueue", connection="AzureWebJobsStorage")
In this code,arg_nameidentifies the binding parameter referenced in your code,queue_nameis name of the queue that the binding writes to, andconnectionis the name of an application setting that contains the connection string for the Storage account. In quickstarts you use the same storage account as the function app, which is in theAzureWebJobsStoragesetting. When thequeue_namedoesn't exist, the binding creates it on first use.
arg_name
queue_name
connection
AzureWebJobsStorage
queue_name
In a C# project, the bindings are defined as binding attributes on the function method. Specific definitions depend on whether your app runs in-process (C# class library) or in an isolated worker process.
Isolated worker model
In-process model
Open theHttpExample.csproject file and add the followingMultiResponseclass:
MultiResponse
public class MultiResponse
{
    [QueueOutput("outqueue",Connection = "AzureWebJobsStorage")]
    public string[] Messages { get; set; }
    public HttpResponseData HttpResponse { get; set; }
}
public class MultiResponse
{
    [QueueOutput("outqueue",Connection = "AzureWebJobsStorage")]
    public string[] Messages { get; set; }
    public HttpResponseData HttpResponse { get; set; }
}
TheMultiResponseclass allows you to write to a storage queue namedoutqueueand an HTTP success message. Multiple messages could be sent to the queue because theQueueOutputattribute is applied to a string array.
MultiResponse
outqueue
QueueOutput
TheConnectionproperty sets the connection string for the storage account. In this case, you could omitConnectionbecause you're already using the default storage account.
Connection
Connection
Important
Support will end for the in-process model on November 10, 2026. We highly recommend that youmigrate your apps to the isolated worker modelfor full support.
Open theHttpExample.csproject file and add the following parameter to theRunmethod definition:
Run
[Queue("outqueue"),StorageAccount("AzureWebJobsStorage")] ICollector<string> msg,
[Queue("outqueue"),StorageAccount("AzureWebJobsStorage")] ICollector<string> msg,
Themsgparameter is anICollector<T>type, representing a collection of messages written to an output binding when the function completes. In this case, the output is a storage queue namedoutqueue. TheStorageAccountAttributesets the connection string for the storage account. This attribute indicates the setting that contains the storage account connection string and can be applied at the class, method, or parameter level. In this case, you could omitStorageAccountAttributebecause you're already using the default storage account.
msg
ICollector<T>
outqueue
StorageAccountAttribute
StorageAccountAttribute
The Run method definition must now look like the following code:
[FunctionName("HttpExample")]
public static async Task<IActionResult> Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req, 
    [Queue("outqueue"),StorageAccount("AzureWebJobsStorage")] ICollector<string> msg, 
    ILogger log)
[FunctionName("HttpExample")]
public static async Task<IActionResult> Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req, 
    [Queue("outqueue"),StorageAccount("AzureWebJobsStorage")] ICollector<string> msg, 
    ILogger log)
In a Java project, the bindings are defined as binding annotations on the function method. Thefunction.jsonfile is then autogenerated based on these annotations.
Browse to the location of your function code undersrc/main/java, open theFunction.javaproject file, and add the following parameter to therunmethod definition:
run
@QueueOutput(name = "msg", queueName = "outqueue", 
connection = "AzureWebJobsStorage") OutputBinding<String> msg,
@QueueOutput(name = "msg", queueName = "outqueue", 
connection = "AzureWebJobsStorage") OutputBinding<String> msg,
Themsgparameter is anOutputBinding<T>type, which represents a collection of strings that are written as messages to an output binding when the function completes. In this case, the output is a storage queue namedoutqueue. The connection string for the Storage account is set by theconnectionmethod. Rather than the connection string itself, you pass the application setting that contains the Storage account connection string.
msg
OutputBinding<T>
outqueue
connection
Therunmethod definition should now look like the following example:
run
@FunctionName("HttpExample")
public HttpResponseMessage run(
        @HttpTrigger(name = "req", methods = {HttpMethod.GET, HttpMethod.POST}, authLevel = AuthorizationLevel.ANONYMOUS) 
        HttpRequestMessage<Optional<String>> request, 
        @QueueOutput(name = "msg", queueName = "outqueue", 
        connection = "AzureWebJobsStorage") OutputBinding<String> msg, 
        final ExecutionContext context) {
@FunctionName("HttpExample")
public HttpResponseMessage run(
        @HttpTrigger(name = "req", methods = {HttpMethod.GET, HttpMethod.POST}, authLevel = AuthorizationLevel.ANONYMOUS) 
        HttpRequestMessage<Optional<String>> request, 
        @QueueOutput(name = "msg", queueName = "outqueue", 
        connection = "AzureWebJobsStorage") OutputBinding<String> msg, 
        final ExecutionContext context) {
Add code that uses the output binding
After the binding is defined, you can use thenameof the binding to access it as an attribute in the function signature. By using an output binding, you don't have to use the Azure Storage SDK code for authentication, getting a queue reference, or writing data. The Functions runtime and queue output binding do those tasks for you.
name
Add code that uses the output binding object oncontext.extraOutputsto create a queue message. Add this code before the return statement.
context.extraOutputs
context.extraOutputs.set(sendToQueue, [msg]);
context.extraOutputs.set(sendToQueue, [msg]);
At this point, your function could look as follows:
const { app, output } = require('@azure/functions');

const sendToQueue = output.storageQueue({
  queueName: 'outqueue',
  connection: 'AzureWebJobsStorage',
});

app.http('HttpExample', {
  methods: ['GET', 'POST'],
  authLevel: 'anonymous',
  extraOutputs: [sendToQueue],
  handler: async (request, context) => {
    try {
      context.log(`Http function processed request for url "${request.url}"`);

      const name = request.query.get('name') || (await request.text());
      context.log(`Name: ${name}`);

      if (name) {
        const msg = `Name passed to the function ${name}`;
        context.extraOutputs.set(sendToQueue, [msg]);
        return { body: msg };
      } else {
        context.log('Missing required data');
        return { status: 404, body: 'Missing required data' };
      }
    } catch (error) {
      context.log(`Error: ${error}`);
      return { status: 500, body: 'Internal Server Error' };
    }
  },
});
const { app, output } = require('@azure/functions');

const sendToQueue = output.storageQueue({
  queueName: 'outqueue',
  connection: 'AzureWebJobsStorage',
});

app.http('HttpExample', {
  methods: ['GET', 'POST'],
  authLevel: 'anonymous',
  extraOutputs: [sendToQueue],
  handler: async (request, context) => {
    try {
      context.log(`Http function processed request for url "${request.url}"`);

      const name = request.query.get('name') || (await request.text());
      context.log(`Name: ${name}`);

      if (name) {
        const msg = `Name passed to the function ${name}`;
        context.extraOutputs.set(sendToQueue, [msg]);
        return { body: msg };
      } else {
        context.log('Missing required data');
        return { status: 404, body: 'Missing required data' };
      }
    } catch (error) {
      context.log(`Error: ${error}`);
      return { status: 500, body: 'Internal Server Error' };
    }
  },
});
Add code that uses the output binding object oncontext.extraOutputsto create a queue message. Add this code before the return statement.
context.extraOutputs
context.extraOutputs.set(sendToQueue, [msg]);
context.extraOutputs.set(sendToQueue, [msg]);
At this point, your function could look as follows:
import {
  app,
  output,
  HttpRequest,
  HttpResponseInit,
  InvocationContext,
  StorageQueueOutput,
} from '@azure/functions';

const sendToQueue: StorageQueueOutput = output.storageQueue({
  queueName: 'outqueue',
  connection: 'AzureWebJobsStorage',
});

export async function HttpExample(
  request: HttpRequest,
  context: InvocationContext,
): Promise<HttpResponseInit> {
  try {
    context.log(`Http function processed request for url "${request.url}"`);

    const name = request.query.get('name') || (await request.text());
    context.log(`Name: ${name}`);

    if (name) {
      const msg = `Name passed to the function ${name}`;
      context.extraOutputs.set(sendToQueue, [msg]);
      return { body: msg };
    } else {
      context.log('Missing required data');
      return { status: 404, body: 'Missing required data' };
    }
  } catch (error) {
    context.log(`Error: ${error}`);
    return { status: 500, body: 'Internal Server Error' };
  }
}

app.http('HttpExample', {
  methods: ['GET', 'POST'],
  authLevel: 'anonymous',
  handler: HttpExample,
});
import {
  app,
  output,
  HttpRequest,
  HttpResponseInit,
  InvocationContext,
  StorageQueueOutput,
} from '@azure/functions';

const sendToQueue: StorageQueueOutput = output.storageQueue({
  queueName: 'outqueue',
  connection: 'AzureWebJobsStorage',
});

export async function HttpExample(
  request: HttpRequest,
  context: InvocationContext,
): Promise<HttpResponseInit> {
  try {
    context.log(`Http function processed request for url "${request.url}"`);

    const name = request.query.get('name') || (await request.text());
    context.log(`Name: ${name}`);

    if (name) {
      const msg = `Name passed to the function ${name}`;
      context.extraOutputs.set(sendToQueue, [msg]);
      return { body: msg };
    } else {
      context.log('Missing required data');
      return { status: 404, body: 'Missing required data' };
    }
  } catch (error) {
    context.log(`Error: ${error}`);
    return { status: 500, body: 'Internal Server Error' };
  }
}

app.http('HttpExample', {
  methods: ['GET', 'POST'],
  authLevel: 'anonymous',
  handler: HttpExample,
});
Add code that uses thePush-OutputBindingcmdlet to write text to the queue using themsgoutput binding. Add this code before you set the OK status in theifstatement.
Push-OutputBinding
msg
if
$outputMsg = $name
Push-OutputBinding -name msg -Value $outputMsg
$outputMsg = $name
Push-OutputBinding -name msg -Value $outputMsg
At this point, your function must look as follows:
using namespace System.Net

# Input bindings are passed in via param block.
param($Request, $TriggerMetadata)

# Write to the Azure Functions log stream.
Write-Host "PowerShell HTTP trigger function processed a request."

# Interact with query parameters or the body of the request.
$name = $Request.Query.Name
if (-not $name) {
    $name = $Request.Body.Name
}

if ($name) {
    # Write the $name value to the queue, 
    # which is the name passed to the function.
    $outputMsg = $name
    Push-OutputBinding -name msg -Value $outputMsg

    $status = [HttpStatusCode]::OK
    $body = "Hello $name"
}
else {
    $status = [HttpStatusCode]::BadRequest
    $body = "Please pass a name on the query string or in the request body."
}

# Associate values to output bindings by calling 'Push-OutputBinding'.
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
    StatusCode = $status
    Body = $body
})
using namespace System.Net

# Input bindings are passed in via param block.
param($Request, $TriggerMetadata)

# Write to the Azure Functions log stream.
Write-Host "PowerShell HTTP trigger function processed a request."

# Interact with query parameters or the body of the request.
$name = $Request.Query.Name
if (-not $name) {
    $name = $Request.Body.Name
}

if ($name) {
    # Write the $name value to the queue, 
    # which is the name passed to the function.
    $outputMsg = $name
    Push-OutputBinding -name msg -Value $outputMsg

    $status = [HttpStatusCode]::OK
    $body = "Hello $name"
}
else {
    $status = [HttpStatusCode]::BadRequest
    $body = "Please pass a name on the query string or in the request body."
}

# Associate values to output bindings by calling 'Push-OutputBinding'.
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
    StatusCode = $status
    Body = $body
})
UpdateHttpExample\function_app.pyto match the following code, add themsgparameter to the function definition andmsg.set(name)under theif name:statement:
msg
msg.set(name)
if name:
import azure.functions as func
import logging

app = func.FunctionApp(http_auth_level=func.AuthLevel.ANONYMOUS)

@app.route(route="HttpExample")
@app.queue_output(arg_name="msg", queue_name="outqueue", connection="AzureWebJobsStorage")
def HttpExample(req: func.HttpRequest, msg: func.Out [func.QueueMessage]) -> func.HttpResponse:
    logging.info('Python HTTP trigger function processed a request.')

    name = req.params.get('name')
    if not name:
        try:
            req_body = req.get_json()
        except ValueError:
            pass
        else:
            name = req_body.get('name')

    if name:
        msg.set(name)
        return func.HttpResponse(f"Hello, {name}. This HTTP triggered function executed successfully.")
    else:
        return func.HttpResponse(
             "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.",
             status_code=200
        )
import azure.functions as func
import logging

app = func.FunctionApp(http_auth_level=func.AuthLevel.ANONYMOUS)

@app.route(route="HttpExample")
@app.queue_output(arg_name="msg", queue_name="outqueue", connection="AzureWebJobsStorage")
def HttpExample(req: func.HttpRequest, msg: func.Out [func.QueueMessage]) -> func.HttpResponse:
    logging.info('Python HTTP trigger function processed a request.')

    name = req.params.get('name')
    if not name:
        try:
            req_body = req.get_json()
        except ValueError:
            pass
        else:
            name = req_body.get('name')

    if name:
        msg.set(name)
        return func.HttpResponse(f"Hello, {name}. This HTTP triggered function executed successfully.")
    else:
        return func.HttpResponse(
             "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.",
             status_code=200
        )
Themsgparameter is an instance of theazure.functions.Out class. Thesetmethod writes a string message to the queue. In this case, it's thenamepassed to the function in the URL query string.
msg
azure.functions.Out class
set
name
Isolated worker model
In-process model
Replace the existingHttpExampleclass with the following code:
HttpExample
[Function("HttpExample")]
    public static MultiResponse Run([HttpTrigger(AuthorizationLevel.Function, "get", "post")] HttpRequestData req,
        FunctionContext executionContext)
    {
        var logger = executionContext.GetLogger("HttpExample");
        logger.LogInformation("C# HTTP trigger function processed a request.");

        var message = "Welcome to Azure Functions!";

        var response = req.CreateResponse(HttpStatusCode.OK);
        response.Headers.Add("Content-Type", "text/plain; charset=utf-8");
        response.WriteString(message);

        // Return a response to both HTTP trigger and storage output binding.
        return new MultiResponse()
        {
            // Write a single message.
            Messages = new string[] { message },
            HttpResponse = response
        };
    }
}
[Function("HttpExample")]
    public static MultiResponse Run([HttpTrigger(AuthorizationLevel.Function, "get", "post")] HttpRequestData req,
        FunctionContext executionContext)
    {
        var logger = executionContext.GetLogger("HttpExample");
        logger.LogInformation("C# HTTP trigger function processed a request.");

        var message = "Welcome to Azure Functions!";

        var response = req.CreateResponse(HttpStatusCode.OK);
        response.Headers.Add("Content-Type", "text/plain; charset=utf-8");
        response.WriteString(message);

        // Return a response to both HTTP trigger and storage output binding.
        return new MultiResponse()
        {
            // Write a single message.
            Messages = new string[] { message },
            HttpResponse = response
        };
    }
}
Important
Support will end for the in-process model on November 10, 2026. We highly recommend that youmigrate your apps to the isolated worker modelfor full support.
Add code that uses themsgoutput binding object to create a queue message. Add this code before the method returns.
msg
if (!string.IsNullOrEmpty(name))
{
    // Add a message to the output collection.
    msg.Add(name);
}
if (!string.IsNullOrEmpty(name))
{
    // Add a message to the output collection.
    msg.Add(name);
}
At this point, your function must look as follows:
[FunctionName("HttpExample")]
public static async Task<IActionResult> Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req, 
    [Queue("outqueue"),StorageAccount("AzureWebJobsStorage")] ICollector<string> msg, 
    ILogger log)
{
    log.LogInformation("C# HTTP trigger function processed a request.");

    string name = req.Query["name"];

    string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
    dynamic data = JsonConvert.DeserializeObject(requestBody);
    name = name ?? data?.name;

    if (!string.IsNullOrEmpty(name))
    {
        // Add a message to the output collection.
        msg.Add(name);
    }
    return name != null
        ? (ActionResult)new OkObjectResult($"Hello, {name}")
        : new BadRequestObjectResult("Please pass a name on the query string or in the request body");
}
[FunctionName("HttpExample")]
public static async Task<IActionResult> Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req, 
    [Queue("outqueue"),StorageAccount("AzureWebJobsStorage")] ICollector<string> msg, 
    ILogger log)
{
    log.LogInformation("C# HTTP trigger function processed a request.");

    string name = req.Query["name"];

    string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
    dynamic data = JsonConvert.DeserializeObject(requestBody);
    name = name ?? data?.name;

    if (!string.IsNullOrEmpty(name))
    {
        // Add a message to the output collection.
        msg.Add(name);
    }
    return name != null
        ? (ActionResult)new OkObjectResult($"Hello, {name}")
        : new BadRequestObjectResult("Please pass a name on the query string or in the request body");
}
Now, you can use the newmsgparameter to write to the output binding from your function code. Add the following line of code before the success response to add the value ofnameto themsgoutput binding.
msg
name
msg
msg.setValue(name);
msg.setValue(name);
When you use an output binding, you don't have to use the Azure Storage SDK code for authentication, getting a queue reference, or writing data. The Functions runtime and queue output binding do those tasks for you.
Yourrunmethod should now look like the following example:
run
@FunctionName("HttpExample")
public HttpResponseMessage run(
        @HttpTrigger(name = "req", methods = {HttpMethod.GET, HttpMethod.POST}, authLevel = AuthorizationLevel.ANONYMOUS) 
        HttpRequestMessage<Optional<String>> request, 
        @QueueOutput(name = "msg", queueName = "outqueue", 
        connection = "AzureWebJobsStorage") OutputBinding<String> msg, 
        final ExecutionContext context) {
    context.getLogger().info("Java HTTP trigger processed a request.");

    // Parse query parameter
    String query = request.getQueryParameters().get("name");
    String name = request.getBody().orElse(query);

    if (name == null) {
        return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
        .body("Please pass a name on the query string or in the request body").build();
    } else {
        // Write the name to the message queue. 
        msg.setValue(name);

        return request.createResponseBuilder(HttpStatus.OK).body("Hello, " + name).build();
    }
}
@FunctionName("HttpExample")
public HttpResponseMessage run(
        @HttpTrigger(name = "req", methods = {HttpMethod.GET, HttpMethod.POST}, authLevel = AuthorizationLevel.ANONYMOUS) 
        HttpRequestMessage<Optional<String>> request, 
        @QueueOutput(name = "msg", queueName = "outqueue", 
        connection = "AzureWebJobsStorage") OutputBinding<String> msg, 
        final ExecutionContext context) {
    context.getLogger().info("Java HTTP trigger processed a request.");

    // Parse query parameter
    String query = request.getQueryParameters().get("name");
    String name = request.getBody().orElse(query);

    if (name == null) {
        return request.createResponseBuilder(HttpStatus.BAD_REQUEST)
        .body("Please pass a name on the query string or in the request body").build();
    } else {
        // Write the name to the message queue. 
        msg.setValue(name);

        return request.createResponseBuilder(HttpStatus.OK).body("Hello, " + name).build();
    }
}
Update the tests
Because the archetype also creates a set of tests, you need to update these tests to handle the newmsgparameter in therunmethod signature.
msg
run
Browse to the location of your test code undersrc/test/java, open theFunction.javaproject file, and replace the line of code under//Invokewith the following code.
//Invoke
@SuppressWarnings("unchecked")
final OutputBinding<String> msg = (OutputBinding<String>)mock(OutputBinding.class);
final HttpResponseMessage ret = new Function().run(req, msg, context);
@SuppressWarnings("unchecked")
final OutputBinding<String> msg = (OutputBinding<String>)mock(OutputBinding.class);
final HttpResponseMessage ret = new Function().run(req, msg, context);
Run the function locally
Visual Studio Code integrates withAzure Functions Core toolsto let you run this project on your local development computer before you publish to Azure. If you don't already have Core Tools installed locally, you are prompted to install it the first time you run your project.
To call your function, pressF5to start the function app project. TheTerminalpanel displays the output from Core Tools. Your app starts in theTerminalpanel. You can see the URL endpoint of your HTTP-triggered function running locally.If you don't already have Core Tools installed, selectInstallto install Core Tools when prompted to do so.If you have trouble running on Windows, make sure that the default terminal for Visual Studio Code isn't set toWSL Bash.
To call your function, pressF5to start the function app project. TheTerminalpanel displays the output from Core Tools. Your app starts in theTerminalpanel. You can see the URL endpoint of your HTTP-triggered function running locally.

If you don't already have Core Tools installed, selectInstallto install Core Tools when prompted to do so.If you have trouble running on Windows, make sure that the default terminal for Visual Studio Code isn't set toWSL Bash.
With the Core Tools running, go to theAzure: Functionsarea. UnderFunctions, expandLocal Project>Functions. Right-click (Windows) orCtrl -click (macOS) theHttpExamplefunction and chooseExecute Function Now....
With the Core Tools running, go to theAzure: Functionsarea. UnderFunctions, expandLocal Project>Functions. Right-click (Windows) orCtrl -click (macOS) theHttpExamplefunction and chooseExecute Function Now....
HttpExample

In theEnter request body, pressEnterto send a request message to your function.
In theEnter request body, pressEnterto send a request message to your function.
When the function executes locally and returns a response, a notification is raised in Visual Studio Code. Information about the function execution is shown in theTerminalpanel.
When the function executes locally and returns a response, a notification is raised in Visual Studio Code. Information about the function execution is shown in theTerminalpanel.
PressCtrl + Cto stop Core Tools and disconnect the debugger.
PressCtrl + Cto stop Core Tools and disconnect the debugger.
Run the function locally
As in the previous article, pressF5to start the function app project and Core Tools.
As in the previous article, pressF5to start the function app project and Core Tools.
With the Core Tools running, go to theAzure: Functionsarea. UnderFunctions, expandLocal Project>Functions. Right-click (Ctrl-click on Mac) theHttpExamplefunction and selectExecute Function Now....
With the Core Tools running, go to theAzure: Functionsarea. UnderFunctions, expandLocal Project>Functions. Right-click (Ctrl-click on Mac) theHttpExamplefunction and selectExecute Function Now....
HttpExample

In theEnter request body, you see the request message body value of{ "name": "Azure" }. PressEnterto send this request message to your function.
In theEnter request body, you see the request message body value of{ "name": "Azure" }. PressEnterto send this request message to your function.
{ "name": "Azure" }
After a response is returned, pressCtrl + Cto stop Core Tools.
After a response is returned, pressCtrl + Cto stop Core Tools.
Because you're using the storage connection string, your function connects to the Azure storage account when running locally. A new queue namedoutqueueis created in your storage account by the Functions runtime when the output binding is first used. You'll use Storage Explorer to verify that the queue was created along with the new message.
Connect Storage Explorer to your account
Skip this section if you've already installed Azure Storage Explorer and connected it to your Azure account.
Run theAzure Storage Explorertool, select the connect icon on the left, and selectAdd an account.
Run theAzure Storage Explorertool, select the connect icon on the left, and selectAdd an account.

In theConnectdialog, chooseAdd an Azure account, choose yourAzure environment, and then selectSign in....
In theConnectdialog, chooseAdd an Azure account, choose yourAzure environment, and then selectSign in....

After you successfully sign in to your account, you see all of the Azure subscriptions associated with your account. Choose your subscription and selectOpen Explorer.
Examine the output queue
In Visual Studio Code, pressF1to open the command palette, then search for and run the commandAzure Storage: Open in Storage Explorerand choose your storage account name. Your storage account opens in the Azure Storage Explorer.
In Visual Studio Code, pressF1to open the command palette, then search for and run the commandAzure Storage: Open in Storage Explorerand choose your storage account name. Your storage account opens in the Azure Storage Explorer.
Azure Storage: Open in Storage Explorer
Expand theQueuesnode, and then select the queue namedoutqueue.The queue contains the message that the queue output binding created when you ran the HTTP-triggered function. If you invoked the function with the defaultnamevalue ofAzure, the queue message isName passed to the function: Azure.
Expand theQueuesnode, and then select the queue namedoutqueue.
The queue contains the message that the queue output binding created when you ran the HTTP-triggered function. If you invoked the function with the defaultnamevalue ofAzure, the queue message isName passed to the function: Azure.
name

Run the function again, send another request, and you see a new message in the queue.
Run the function again, send another request, and you see a new message in the queue.
Now, it's time to republish the updated function app to Azure.
Redeploy and verify the updated app
In Visual Studio Code, pressF1to open the command palette. In the command palette, search for and selectAzure Functions: Deploy to function app....
In Visual Studio Code, pressF1to open the command palette. In the command palette, search for and selectAzure Functions: Deploy to function app....
Azure Functions: Deploy to function app...
Choose the function app that you created in the first article. Because you're redeploying your project to the same app, selectDeployto dismiss the warning about overwriting files.
Choose the function app that you created in the first article. Because you're redeploying your project to the same app, selectDeployto dismiss the warning about overwriting files.
After the deployment completes, you can again use theExecute Function Now...feature to trigger the function in Azure.
After the deployment completes, you can again use theExecute Function Now...feature to trigger the function in Azure.
Againview the message in the storage queueto verify that the output binding generates a new message in the queue.
Againview the message in the storage queueto verify that the output binding generates a new message in the queue.
Clean up resources
In Azure,resourcesrefer to function apps, functions, storage accounts, and so forth. They're grouped intoresource groups, and you can delete everything in a group by deleting the group.
You've created resources to complete these quickstarts. You may be billed for these resources, depending on youraccount statusandservice pricing. If you don't need the resources anymore, here's how to delete them:
In Visual Studio Code, pressF1to open the command palette. In the command palette, search for and selectAzure: Open in portal.
In Visual Studio Code, pressF1to open the command palette. In the command palette, search for and selectAzure: Open in portal.
Azure: Open in portal
Choose your function app and pressEnter. The function app page opens in the Azure portal.
Choose your function app and pressEnter. The function app page opens in the Azure portal.
In theOverviewtab, select the named link next toResource group.
In theOverviewtab, select the named link next toResource group.

On theResource grouppage, review the list of included resources, and verify that they're the ones you want to delete.
On theResource grouppage, review the list of included resources, and verify that they're the ones you want to delete.
SelectDelete resource group, and follow the instructions.Deletion may take a couple of minutes. When it's done, a notification appears for a few seconds. You can also select the bell icon at the top of the page to view the notification.
SelectDelete resource group, and follow the instructions.
Deletion may take a couple of minutes. When it's done, a notification appears for a few seconds. You can also select the bell icon at the top of the page to view the notification.
Next steps
You've updated your HTTP triggered function to write data to a Storage queue. Now you can learn more about developing Functions using Visual Studio Code:
Develop Azure Functions using Visual Studio Code
Develop Azure Functions using Visual Studio Code
Azure Functions triggers and bindings.
Azure Functions triggers and bindings.
Examples of complete Function projects in C#.
Examples of complete Function projects in C#.
Azure Functions C# developer reference
Azure Functions C# developer reference
Examples of complete Function projects in JavaScript.
Examples of complete Function projects in JavaScript.
Azure Functions JavaScript developer guide
Azure Functions JavaScript developer guide
Examples of complete Function projects in Java.
Examples of complete Function projects in Java.
Azure Functions Java developer guide
Azure Functions Java developer guide
Examples of complete Function projects in TypeScript.
Examples of complete Function projects in TypeScript.
Azure Functions TypeScript developer guide
Azure Functions TypeScript developer guide
Examples of complete Function projects in Python.
Examples of complete Function projects in Python.
Azure Functions Python developer guide
Azure Functions Python developer guide
Examples of complete Function projects in PowerShell.
Examples of complete Function projects in PowerShell.
Azure Functions PowerShell developer guide
Azure Functions PowerShell developer guide
Feedback
Was this page helpful?
Additional resources