Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Connect to and query Azure SQL Database using Node.js and mssql npm package
Article
2025-03-04
5 contributors
In this article
Applies to:Azure SQL Database
This quickstart describes how to connect an application to a database in Azure SQL Database and perform queries using Node.js and mssql. This quickstart follows the recommended passwordless approach to connect to the database.
Passwordless connections for developers
Passwordless connections offer a more secure mechanism for accessing Azure resources. The following high-level steps are used to connect to Azure SQL Database using passwordless connections in this article:
Prepare your environment for password-free authentication.For a local environment: Your personal identity is used. This identity can be pulled from an IDE, CLI, or other local development tools.For a cloud environment: Amanaged identityis used.
For a local environment: Your personal identity is used. This identity can be pulled from an IDE, CLI, or other local development tools.
For a cloud environment: Amanaged identityis used.
Authenticate in the environment using theDefaultAzureCredentialfrom the Azure Identity library to obtain a verified credential.
DefaultAzureCredential
Use the verified credential to create Azure SDK client objects for resource access.
You can learn more about passwordless connections on thepasswordless hub.
Prerequisites
AnAzure subscription
A database in Azure SQL Database configured for authentication with Microsoft Entra ID (formerly Azure Active Directory). You can create one using theCreate database quickstart.
Bash-enabled shell
Node.js LTS
Visual Studio Code
Visual Studio Code App Service extension
The latest version of theAzure CLI
Configure the database server
Secure, passwordless connections to Azure SQL Database require certain database configurations. Verify the following settings on yourlogical server in Azureto properly connect to Azure SQL Database in both local and hosted environments:
For local development connections, make sure your logical server is configured to allow your local machine IP address and other Azure services to connect:Navigate to theNetworkingpage of your server.Toggle theSelected networksradio button to show additional configuration options.SelectAdd your client IPv4 address(xx.xx.xx.xx)to add a firewall rule that will enable connections from your local machine IPv4 address. Alternatively, you can also select+ Add a firewall ruleto enter a specific IP address of your choice.Make sure theAllow Azure services and resources to access this servercheckbox is selected.WarningEnabling theAllow Azure services and resources to access this serversetting is not a recommended security practice for production scenarios. Real applications should implement more secure approaches, such as stronger firewall restrictions or virtual network configurations.You can read more about database security configurations on the following resources:Configure Azure SQL Database firewall rules.Configure a virtual network with private endpoints.
For local development connections, make sure your logical server is configured to allow your local machine IP address and other Azure services to connect:
Navigate to theNetworkingpage of your server.
Navigate to theNetworkingpage of your server.
Toggle theSelected networksradio button to show additional configuration options.
Toggle theSelected networksradio button to show additional configuration options.
SelectAdd your client IPv4 address(xx.xx.xx.xx)to add a firewall rule that will enable connections from your local machine IPv4 address. Alternatively, you can also select+ Add a firewall ruleto enter a specific IP address of your choice.
SelectAdd your client IPv4 address(xx.xx.xx.xx)to add a firewall rule that will enable connections from your local machine IPv4 address. Alternatively, you can also select+ Add a firewall ruleto enter a specific IP address of your choice.
Make sure theAllow Azure services and resources to access this servercheckbox is selected.WarningEnabling theAllow Azure services and resources to access this serversetting is not a recommended security practice for production scenarios. Real applications should implement more secure approaches, such as stronger firewall restrictions or virtual network configurations.You can read more about database security configurations on the following resources:Configure Azure SQL Database firewall rules.Configure a virtual network with private endpoints.
Make sure theAllow Azure services and resources to access this servercheckbox is selected.

Warning
Enabling theAllow Azure services and resources to access this serversetting is not a recommended security practice for production scenarios. Real applications should implement more secure approaches, such as stronger firewall restrictions or virtual network configurations.
You can read more about database security configurations on the following resources:
Configure Azure SQL Database firewall rules.
Configure a virtual network with private endpoints.
The server must also have Microsoft Entra authentication enabled and have a Microsoft Entra admin account assigned. For local development connections, the Microsoft Entra admin account should be an account you can also log into Visual Studio or the Azure CLI with locally. You can verify whether your server has Microsoft Entra authentication enabled on theMicrosoft Entra IDpage of your logical server.
The server must also have Microsoft Entra authentication enabled and have a Microsoft Entra admin account assigned. For local development connections, the Microsoft Entra admin account should be an account you can also log into Visual Studio or the Azure CLI with locally. You can verify whether your server has Microsoft Entra authentication enabled on theMicrosoft Entra IDpage of your logical server.

If you're using a personal Azure account, make sure you haveMicrosoft Entra setup and configured for Azure SQL Databasein order to assign your account as a server admin. If you're using a corporate account, Microsoft Entra ID will most likely already be configured for you.
If you're using a personal Azure account, make sure you haveMicrosoft Entra setup and configured for Azure SQL Databasein order to assign your account as a server admin. If you're using a corporate account, Microsoft Entra ID will most likely already be configured for you.
Create the project
The steps in this section create a Node.js REST API.
Create a new directory for the project and navigate into it.
Create a new directory for the project and navigate into it.
Initialize the project by running the following command in the terminal:npm init -y
Initialize the project by running the following command in the terminal:
npm init -y
npm init -y
Install the required packages used in the sample code in this article:npm install mssql express swagger-ui-express yamljs dotenv
Install the required packages used in the sample code in this article:
npm install mssql express swagger-ui-express yamljs dotenv
npm install mssql express swagger-ui-express yamljs dotenv
Open the project in Visual Studio Code.code .
Open the project in Visual Studio Code.
code .
code .
Open thepackage.jsonfile and add the following property and value after thenameproperty to configure the project for ESM modules."type": "module",
Open thepackage.jsonfile and add the following property and value after thenameproperty to configure the project for ESM modules.
package.json
"type": "module",
"type": "module",
Create Express.js application code
To create the Express.js OpenAPI application, you'll create several files:
.env.development
index.js
person.js
openapi.js
openApiSchema.yml
config.js
database.js
./vscode/settings.json
Create anindex.jsfile and add the following code:import express from 'express';

// Import App routes
import person from './person.js';
import openapi from './openapi.js';

const port = process.env.PORT || 3000;

const app = express();

// Connect App routes
app.use('/api-docs', openapi);
app.use('/persons', person);
app.use('*', (_, res) => {
  res.redirect('/api-docs');
});

// Start the server
app.listen(port, () => {
  console.log(`Server started on port ${port}`);
});
Create anindex.jsfile and add the following code:
index.js
import express from 'express';

// Import App routes
import person from './person.js';
import openapi from './openapi.js';

const port = process.env.PORT || 3000;

const app = express();

// Connect App routes
app.use('/api-docs', openapi);
app.use('/persons', person);
app.use('*', (_, res) => {
  res.redirect('/api-docs');
});

// Start the server
app.listen(port, () => {
  console.log(`Server started on port ${port}`);
});
import express from 'express';

// Import App routes
import person from './person.js';
import openapi from './openapi.js';

const port = process.env.PORT || 3000;

const app = express();

// Connect App routes
app.use('/api-docs', openapi);
app.use('/persons', person);
app.use('*', (_, res) => {
  res.redirect('/api-docs');
});

// Start the server
app.listen(port, () => {
  console.log(`Server started on port ${port}`);
});
Create aperson.jsroute file and add the following code:import express from 'express';
import { 
  passwordConfig as SQLAuthentication, 
  noPasswordConfig as PasswordlessConfig 
} from './config.js';
import { createDatabaseConnection } from './database.js';

const router = express.Router();
router.use(express.json());

const database = await createDatabaseConnection(SQLAuthentication);

router.get('/', async (req, res) => {
  try {
    // Return a list of persons

    const persons = await database.readAll();
    console.log(`persons: ${JSON.stringify(persons)}`);
    res.status(200).json(persons);
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.post('/', async (req, res) => {
  try {
    // add a person
    const person = req.body;
    console.log(`person: ${JSON.stringify(person)}`);
    const rowsAffected = await database.create(person);
    res.status(201).json({ rowsAffected });
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.get('/:id', async (req, res) => {
  try {
    // Get the person with the specified ID
    const personId = req.params.id;
    console.log(`personId: ${personId}`);
    if (personId) {
      const result = await database.read(personId);
      console.log(`persons: ${JSON.stringify(result)}`);
      res.status(200).json(result);
    } else {
      res.status(404);
    }
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.put('/:id', async (req, res) => {
  try {
    // Update the person with the specified ID
    const personId = req.params.id;
    console.log(`personId: ${personId}`);
    const person = req.body;

    if (personId && person) {
      delete person.id;
      console.log(`person: ${JSON.stringify(person)}`);
      const rowsAffected = await database.update(personId, person);
      res.status(200).json({ rowsAffected });
    } else {
      res.status(404);
    }
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.delete('/:id', async (req, res) => {
  try {
    // Delete the person with the specified ID
    const personId = req.params.id;
    console.log(`personId: ${personId}`);

    if (!personId) {
      res.status(404);
    } else {
      const rowsAffected = await database.delete(personId);
      res.status(204).json({ rowsAffected });
    }
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

export default router;For passwordless authentication, change the param passed intocreateDatabaseConnectionfromSQLAuthenticationtoPasswordlessConfig.const database = await createDatabaseConnection(PasswordlessConfig);
Create aperson.jsroute file and add the following code:
person.js
import express from 'express';
import { 
  passwordConfig as SQLAuthentication, 
  noPasswordConfig as PasswordlessConfig 
} from './config.js';
import { createDatabaseConnection } from './database.js';

const router = express.Router();
router.use(express.json());

const database = await createDatabaseConnection(SQLAuthentication);

router.get('/', async (req, res) => {
  try {
    // Return a list of persons

    const persons = await database.readAll();
    console.log(`persons: ${JSON.stringify(persons)}`);
    res.status(200).json(persons);
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.post('/', async (req, res) => {
  try {
    // add a person
    const person = req.body;
    console.log(`person: ${JSON.stringify(person)}`);
    const rowsAffected = await database.create(person);
    res.status(201).json({ rowsAffected });
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.get('/:id', async (req, res) => {
  try {
    // Get the person with the specified ID
    const personId = req.params.id;
    console.log(`personId: ${personId}`);
    if (personId) {
      const result = await database.read(personId);
      console.log(`persons: ${JSON.stringify(result)}`);
      res.status(200).json(result);
    } else {
      res.status(404);
    }
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.put('/:id', async (req, res) => {
  try {
    // Update the person with the specified ID
    const personId = req.params.id;
    console.log(`personId: ${personId}`);
    const person = req.body;

    if (personId && person) {
      delete person.id;
      console.log(`person: ${JSON.stringify(person)}`);
      const rowsAffected = await database.update(personId, person);
      res.status(200).json({ rowsAffected });
    } else {
      res.status(404);
    }
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.delete('/:id', async (req, res) => {
  try {
    // Delete the person with the specified ID
    const personId = req.params.id;
    console.log(`personId: ${personId}`);

    if (!personId) {
      res.status(404);
    } else {
      const rowsAffected = await database.delete(personId);
      res.status(204).json({ rowsAffected });
    }
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

export default router;
import express from 'express';
import { 
  passwordConfig as SQLAuthentication, 
  noPasswordConfig as PasswordlessConfig 
} from './config.js';
import { createDatabaseConnection } from './database.js';

const router = express.Router();
router.use(express.json());

const database = await createDatabaseConnection(SQLAuthentication);

router.get('/', async (req, res) => {
  try {
    // Return a list of persons

    const persons = await database.readAll();
    console.log(`persons: ${JSON.stringify(persons)}`);
    res.status(200).json(persons);
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.post('/', async (req, res) => {
  try {
    // add a person
    const person = req.body;
    console.log(`person: ${JSON.stringify(person)}`);
    const rowsAffected = await database.create(person);
    res.status(201).json({ rowsAffected });
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.get('/:id', async (req, res) => {
  try {
    // Get the person with the specified ID
    const personId = req.params.id;
    console.log(`personId: ${personId}`);
    if (personId) {
      const result = await database.read(personId);
      console.log(`persons: ${JSON.stringify(result)}`);
      res.status(200).json(result);
    } else {
      res.status(404);
    }
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.put('/:id', async (req, res) => {
  try {
    // Update the person with the specified ID
    const personId = req.params.id;
    console.log(`personId: ${personId}`);
    const person = req.body;

    if (personId && person) {
      delete person.id;
      console.log(`person: ${JSON.stringify(person)}`);
      const rowsAffected = await database.update(personId, person);
      res.status(200).json({ rowsAffected });
    } else {
      res.status(404);
    }
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

router.delete('/:id', async (req, res) => {
  try {
    // Delete the person with the specified ID
    const personId = req.params.id;
    console.log(`personId: ${personId}`);

    if (!personId) {
      res.status(404);
    } else {
      const rowsAffected = await database.delete(personId);
      res.status(204).json({ rowsAffected });
    }
  } catch (err) {
    res.status(500).json({ error: err?.message });
  }
});

export default router;
For passwordless authentication, change the param passed intocreateDatabaseConnectionfromSQLAuthenticationtoPasswordlessConfig.
createDatabaseConnection
SQLAuthentication
PasswordlessConfig
const database = await createDatabaseConnection(PasswordlessConfig);
const database = await createDatabaseConnection(PasswordlessConfig);
Create anopenapi.jsroute file and add the following code for the OpenAPI UI explorer:import express from 'express';
import { join, dirname } from 'path';
import swaggerUi from 'swagger-ui-express';
import yaml from 'yamljs';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

const router = express.Router();
router.use(express.json());

const pathToSpec = join(__dirname, './openApiSchema.yml');
const openApiSpec = yaml.load(pathToSpec);

router.use('/', swaggerUi.serve, swaggerUi.setup(openApiSpec));

export default router;
Create anopenapi.jsroute file and add the following code for the OpenAPI UI explorer:
openapi.js
import express from 'express';
import { join, dirname } from 'path';
import swaggerUi from 'swagger-ui-express';
import yaml from 'yamljs';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

const router = express.Router();
router.use(express.json());

const pathToSpec = join(__dirname, './openApiSchema.yml');
const openApiSpec = yaml.load(pathToSpec);

router.use('/', swaggerUi.serve, swaggerUi.setup(openApiSpec));

export default router;
import express from 'express';
import { join, dirname } from 'path';
import swaggerUi from 'swagger-ui-express';
import yaml from 'yamljs';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

const router = express.Router();
router.use(express.json());

const pathToSpec = join(__dirname, './openApiSchema.yml');
const openApiSpec = yaml.load(pathToSpec);

router.use('/', swaggerUi.serve, swaggerUi.setup(openApiSpec));

export default router;
Create anopenApiSchema.ymlfile and add the following code so the OpenAPI UI explorer knows what APIs and models to display:openapi: 3.0.0
info:
  version: 1.0.0
  title: Persons API
paths:
  /persons:
    get:
      summary: Get all persons
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Person'
    post:
      summary: Create a new person
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Person'
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Person'
  /persons/{id}:
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    get:
      summary: Get a person by ID
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Person'
        '404':
          description: Person not found
    put:
      summary: Update a person by ID
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Person'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Person'
        '404':
          description: Person not found
    delete:
      summary: Delete a person by ID
      responses:
        '204':
          description: No Content
        '404':
          description: Person not found
components:
  schemas:
    Person:
      type: object
      properties:
        id:
          type: integer
          readOnly: true
        firstName:
          type: string
        lastName:
          type: string
Create anopenApiSchema.ymlfile and add the following code so the OpenAPI UI explorer knows what APIs and models to display:
openApiSchema.yml
openapi: 3.0.0
info:
  version: 1.0.0
  title: Persons API
paths:
  /persons:
    get:
      summary: Get all persons
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Person'
    post:
      summary: Create a new person
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Person'
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Person'
  /persons/{id}:
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    get:
      summary: Get a person by ID
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Person'
        '404':
          description: Person not found
    put:
      summary: Update a person by ID
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Person'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Person'
        '404':
          description: Person not found
    delete:
      summary: Delete a person by ID
      responses:
        '204':
          description: No Content
        '404':
          description: Person not found
components:
  schemas:
    Person:
      type: object
      properties:
        id:
          type: integer
          readOnly: true
        firstName:
          type: string
        lastName:
          type: string
openapi: 3.0.0
info:
  version: 1.0.0
  title: Persons API
paths:
  /persons:
    get:
      summary: Get all persons
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Person'
    post:
      summary: Create a new person
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Person'
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Person'
  /persons/{id}:
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    get:
      summary: Get a person by ID
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Person'
        '404':
          description: Person not found
    put:
      summary: Update a person by ID
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Person'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Person'
        '404':
          description: Person not found
    delete:
      summary: Delete a person by ID
      responses:
        '204':
          description: No Content
        '404':
          description: Person not found
components:
  schemas:
    Person:
      type: object
      properties:
        id:
          type: integer
          readOnly: true
        firstName:
          type: string
        lastName:
          type: string
Configure the mssql connection object
Themssqlpackage implements the connection to Azure SQL Database by providing a configuration setting for an authentication type.
In Visual Studio Code, create aconfig.jsfile and add the following mssql configuration code to authenticate to Azure SQL Database.import * as dotenv from 'dotenv';

if(process.env.NODE_ENV === 'development') {
  dotenv.config({ path: `.env.${process.env.NODE_ENV}`, debug: true });
}

// TIP: Port must be a number, not a string!
const server = process.env.AZURE_SQL_SERVER;
const database = process.env.AZURE_SQL_DATABASE;
const port = +process.env.AZURE_SQL_PORT;
const type = process.env.AZURE_SQL_AUTHENTICATIONTYPE;
const user = process.env.AZURE_SQL_USER;
const password = process.env.AZURE_SQL_PASSWORD;

export const noPasswordConfig = {
  server,
  port,
  database,
  authentication: {
    type
  },
  options: {
    encrypt: true
  }
};

export const passwordConfig = {
  server,
  port,
  database,
  user,
  password,
  options: {
    encrypt: true
  }
};
In Visual Studio Code, create aconfig.jsfile and add the following mssql configuration code to authenticate to Azure SQL Database.
config.js
import * as dotenv from 'dotenv';

if(process.env.NODE_ENV === 'development') {
  dotenv.config({ path: `.env.${process.env.NODE_ENV}`, debug: true });
}

// TIP: Port must be a number, not a string!
const server = process.env.AZURE_SQL_SERVER;
const database = process.env.AZURE_SQL_DATABASE;
const port = +process.env.AZURE_SQL_PORT;
const type = process.env.AZURE_SQL_AUTHENTICATIONTYPE;
const user = process.env.AZURE_SQL_USER;
const password = process.env.AZURE_SQL_PASSWORD;

export const noPasswordConfig = {
  server,
  port,
  database,
  authentication: {
    type
  },
  options: {
    encrypt: true
  }
};

export const passwordConfig = {
  server,
  port,
  database,
  user,
  password,
  options: {
    encrypt: true
  }
};
import * as dotenv from 'dotenv';

if(process.env.NODE_ENV === 'development') {
  dotenv.config({ path: `.env.${process.env.NODE_ENV}`, debug: true });
}

// TIP: Port must be a number, not a string!
const server = process.env.AZURE_SQL_SERVER;
const database = process.env.AZURE_SQL_DATABASE;
const port = +process.env.AZURE_SQL_PORT;
const type = process.env.AZURE_SQL_AUTHENTICATIONTYPE;
const user = process.env.AZURE_SQL_USER;
const password = process.env.AZURE_SQL_PASSWORD;

export const noPasswordConfig = {
  server,
  port,
  database,
  authentication: {
    type
  },
  options: {
    encrypt: true
  }
};

export const passwordConfig = {
  server,
  port,
  database,
  user,
  password,
  options: {
    encrypt: true
  }
};
Create a local environment variable file
Create a.env.developmentfile for your local environment variables
.env.development
Passwordless (recommended)
SQL authentication
Add the following text and update with your values for<YOURSERVERNAME>and<YOURDATABASENAME>.
<YOURSERVERNAME>
<YOURDATABASENAME>
AZURE_SQL_SERVER=<YOURSERVERNAME>.database.windows.net
AZURE_SQL_DATABASE=<YOURDATABASENAME>
AZURE_SQL_PORT=1433
AZURE_SQL_AUTHENTICATIONTYPE=azure-active-directory-default
AZURE_SQL_SERVER=<YOURSERVERNAME>.database.windows.net
AZURE_SQL_DATABASE=<YOURDATABASENAME>
AZURE_SQL_PORT=1433
AZURE_SQL_AUTHENTICATIONTYPE=azure-active-directory-default
Note
Passwordless configuration objects are safe to commit to source control, since they do not contain any secrets such as usernames, passwords, or access keys.
Add the following text and update with your values for<YOURSERVERNAME>,<YOURDATABASENAME>,<YOURUSERNAME>, and<YOURPASSWORD>.
<YOURSERVERNAME>
<YOURDATABASENAME>
<YOURUSERNAME>
<YOURPASSWORD>
AZURE_SQL_SERVER=<YOURSERVERNAME>.database.windows.net
AZURE_SQL_DATABASE=<YOURDATABASENAME>
AZURE_SQL_PORT=1433
AZURE_SQL_USER=<YOURUSERNAME>
AZURE_SQL_PASSWORD=<YOURPASSWORD>
AZURE_SQL_SERVER=<YOURSERVERNAME>.database.windows.net
AZURE_SQL_DATABASE=<YOURDATABASENAME>
AZURE_SQL_PORT=1433
AZURE_SQL_USER=<YOURUSERNAME>
AZURE_SQL_PASSWORD=<YOURPASSWORD>
Warning
Use caution when managing connection objects that contain secrets such as usernames, passwords, or access keys. These secrets shouldn't be committed to source control or placed in unsecure locations where they might be accessed by unintended users.
Add the code to connect to Azure SQL Database
Create adatabase.jsfile and add the following code:import sql from 'mssql';

let database = null;

export default class Database {
  config = {};
  poolconnection = null;
  connected = false;

  constructor(config) {
    this.config = config;
  }

  async connect() {
    try {
      this.poolconnection = await sql.connect(this.config);
      this.connected = true;
      console.log('Database connected successfully.');
      return this.poolconnection;
    } catch (error) {
      console.error('Error connecting to the database:', error);
      this.connected = false;
    }
  }

  async disconnect() {
    try {
      if (this.connected) {
        await this.poolconnection.close();
        this.connected = false;
        console.log('Database disconnected successfully.');
      }
    } catch (error) {
      console.error('Error disconnecting from the database:', error);
    }
  }

  async executeQuery(query) {
    const request = this.poolconnection.request();
    const result = await request.query(query);

    return result.rowsAffected[0];
  }

  async create(data) {
    const request = this.poolconnection.request();

    request.input('firstName', sql.NVarChar(255), data.firstName);
    request.input('lastName', sql.NVarChar(255), data.lastName);

    const result = await request.query(
      `INSERT INTO Person (firstName, lastName) VALUES (@firstName, @lastName)`
    );

    return result.rowsAffected[0];
  }

  async readAll() {
    const request = this.poolconnection.request();
    const result = await request.query(`SELECT * FROM Person`);

    return result.recordsets[0];
  }

  async read(id) {
    const request = this.poolconnection.request();
    const result = await request
      .input('id', sql.Int, +id)
      .query(`SELECT * FROM Person WHERE id = @id`);

    return result.recordset[0];
  }

  async update(id, data) {
    const request = this.poolconnection.request();

    request.input('id', sql.Int, +id);
    request.input('firstName', sql.NVarChar(255), data.firstName);
    request.input('lastName', sql.NVarChar(255), data.lastName);

    const result = await request.query(
      `UPDATE Person SET firstName=@firstName, lastName=@lastName WHERE id = @id`
    );

    return result.rowsAffected[0];
  }

  async delete(id) {
    const idAsNumber = Number(id);

    const request = this.poolconnection.request();
    const result = await request
      .input('id', sql.Int, idAsNumber)
      .query(`DELETE FROM Person WHERE id = @id`);

    return result.rowsAffected[0];
  }

  async createTable() {
    if (process.env.NODE_ENV === 'development') {
      this.executeQuery(
        `IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Person')
         BEGIN
           CREATE TABLE Person (
             id int NOT NULL IDENTITY, 
             firstName varchar(255), 
             lastName varchar(255)
           );
         END`
      )
        .then(() => {
          console.log('Table created');
        })
        .catch((err) => {
          // Table may already exist
          console.error(`Error creating table: ${err}`);
        });
    }
  }
}

export const createDatabaseConnection = async (passwordConfig) => {
  database = new Database(passwordConfig);
  await database.connect();
  await database.createTable();
  return database;
};
Create adatabase.jsfile and add the following code:
database.js
import sql from 'mssql';

let database = null;

export default class Database {
  config = {};
  poolconnection = null;
  connected = false;

  constructor(config) {
    this.config = config;
  }

  async connect() {
    try {
      this.poolconnection = await sql.connect(this.config);
      this.connected = true;
      console.log('Database connected successfully.');
      return this.poolconnection;
    } catch (error) {
      console.error('Error connecting to the database:', error);
      this.connected = false;
    }
  }

  async disconnect() {
    try {
      if (this.connected) {
        await this.poolconnection.close();
        this.connected = false;
        console.log('Database disconnected successfully.');
      }
    } catch (error) {
      console.error('Error disconnecting from the database:', error);
    }
  }

  async executeQuery(query) {
    const request = this.poolconnection.request();
    const result = await request.query(query);

    return result.rowsAffected[0];
  }

  async create(data) {
    const request = this.poolconnection.request();

    request.input('firstName', sql.NVarChar(255), data.firstName);
    request.input('lastName', sql.NVarChar(255), data.lastName);

    const result = await request.query(
      `INSERT INTO Person (firstName, lastName) VALUES (@firstName, @lastName)`
    );

    return result.rowsAffected[0];
  }

  async readAll() {
    const request = this.poolconnection.request();
    const result = await request.query(`SELECT * FROM Person`);

    return result.recordsets[0];
  }

  async read(id) {
    const request = this.poolconnection.request();
    const result = await request
      .input('id', sql.Int, +id)
      .query(`SELECT * FROM Person WHERE id = @id`);

    return result.recordset[0];
  }

  async update(id, data) {
    const request = this.poolconnection.request();

    request.input('id', sql.Int, +id);
    request.input('firstName', sql.NVarChar(255), data.firstName);
    request.input('lastName', sql.NVarChar(255), data.lastName);

    const result = await request.query(
      `UPDATE Person SET firstName=@firstName, lastName=@lastName WHERE id = @id`
    );

    return result.rowsAffected[0];
  }

  async delete(id) {
    const idAsNumber = Number(id);

    const request = this.poolconnection.request();
    const result = await request
      .input('id', sql.Int, idAsNumber)
      .query(`DELETE FROM Person WHERE id = @id`);

    return result.rowsAffected[0];
  }

  async createTable() {
    if (process.env.NODE_ENV === 'development') {
      this.executeQuery(
        `IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Person')
         BEGIN
           CREATE TABLE Person (
             id int NOT NULL IDENTITY, 
             firstName varchar(255), 
             lastName varchar(255)
           );
         END`
      )
        .then(() => {
          console.log('Table created');
        })
        .catch((err) => {
          // Table may already exist
          console.error(`Error creating table: ${err}`);
        });
    }
  }
}

export const createDatabaseConnection = async (passwordConfig) => {
  database = new Database(passwordConfig);
  await database.connect();
  await database.createTable();
  return database;
};
import sql from 'mssql';

let database = null;

export default class Database {
  config = {};
  poolconnection = null;
  connected = false;

  constructor(config) {
    this.config = config;
  }

  async connect() {
    try {
      this.poolconnection = await sql.connect(this.config);
      this.connected = true;
      console.log('Database connected successfully.');
      return this.poolconnection;
    } catch (error) {
      console.error('Error connecting to the database:', error);
      this.connected = false;
    }
  }

  async disconnect() {
    try {
      if (this.connected) {
        await this.poolconnection.close();
        this.connected = false;
        console.log('Database disconnected successfully.');
      }
    } catch (error) {
      console.error('Error disconnecting from the database:', error);
    }
  }

  async executeQuery(query) {
    const request = this.poolconnection.request();
    const result = await request.query(query);

    return result.rowsAffected[0];
  }

  async create(data) {
    const request = this.poolconnection.request();

    request.input('firstName', sql.NVarChar(255), data.firstName);
    request.input('lastName', sql.NVarChar(255), data.lastName);

    const result = await request.query(
      `INSERT INTO Person (firstName, lastName) VALUES (@firstName, @lastName)`
    );

    return result.rowsAffected[0];
  }

  async readAll() {
    const request = this.poolconnection.request();
    const result = await request.query(`SELECT * FROM Person`);

    return result.recordsets[0];
  }

  async read(id) {
    const request = this.poolconnection.request();
    const result = await request
      .input('id', sql.Int, +id)
      .query(`SELECT * FROM Person WHERE id = @id`);

    return result.recordset[0];
  }

  async update(id, data) {
    const request = this.poolconnection.request();

    request.input('id', sql.Int, +id);
    request.input('firstName', sql.NVarChar(255), data.firstName);
    request.input('lastName', sql.NVarChar(255), data.lastName);

    const result = await request.query(
      `UPDATE Person SET firstName=@firstName, lastName=@lastName WHERE id = @id`
    );

    return result.rowsAffected[0];
  }

  async delete(id) {
    const idAsNumber = Number(id);

    const request = this.poolconnection.request();
    const result = await request
      .input('id', sql.Int, idAsNumber)
      .query(`DELETE FROM Person WHERE id = @id`);

    return result.rowsAffected[0];
  }

  async createTable() {
    if (process.env.NODE_ENV === 'development') {
      this.executeQuery(
        `IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Person')
         BEGIN
           CREATE TABLE Person (
             id int NOT NULL IDENTITY, 
             firstName varchar(255), 
             lastName varchar(255)
           );
         END`
      )
        .then(() => {
          console.log('Table created');
        })
        .catch((err) => {
          // Table may already exist
          console.error(`Error creating table: ${err}`);
        });
    }
  }
}

export const createDatabaseConnection = async (passwordConfig) => {
  database = new Database(passwordConfig);
  await database.connect();
  await database.createTable();
  return database;
};
Test the app locally
The app is ready to be tested locally. Make sure you're signed in to the Azure Cloud in Visual Studio Code with the same account you set as the admin for your database.
Run the application with the following command. The app starts on port 3000.NODE_ENV=development node index.jsThePersontable is created in the database when you run this application.
Run the application with the following command. The app starts on port 3000.
NODE_ENV=development node index.js
NODE_ENV=development node index.js
ThePersontable is created in the database when you run this application.
In a browser, navigate to the OpenAPI explorer athttp://localhost:3000.
In a browser, navigate to the OpenAPI explorer athttp://localhost:3000.
On the Swagger UI page, expand the POST method and selectTry it.
On the Swagger UI page, expand the POST method and selectTry it.
Modify the sample JSON to include values for the properties. The ID property is ignored.
Modify the sample JSON to include values for the properties. The ID property is ignored.

SelectExecuteto add a new record to the database. The API returns a successful response.
SelectExecuteto add a new record to the database. The API returns a successful response.
Expand theGETmethod on the Swagger UI page and selectTry it. SelectExecute, and the person you just created is returned.
Expand theGETmethod on the Swagger UI page and selectTry it. SelectExecute, and the person you just created is returned.
Configure project for zip deployment
Create a.vscodefolder and create asettings.jsonfile in the folder.
Create a.vscodefolder and create asettings.jsonfile in the folder.
.vscode
settings.json
Add the following to ignore environment variables and dependencies during the zip deployment.{
    "appService.zipIgnorePattern": ["./.env*","node_modules{,/**}"]
}
Add the following to ignore environment variables and dependencies during the zip deployment.
{
    "appService.zipIgnorePattern": ["./.env*","node_modules{,/**}"]
}
{
    "appService.zipIgnorePattern": ["./.env*","node_modules{,/**}"]
}
Deploy to Azure App Service
The app is ready to be deployed to Azure. Visual Studio Code can create an Azure App Service and deploy your application in a single workflow.
Make sure the app is stopped.
Make sure the app is stopped.
Sign in to Azure, if you haven't already, by selecting theAzure: Sign In to Azure Cloudcommand in the Command Palette (Ctrl+Shift+P)
Sign in to Azure, if you haven't already, by selecting theAzure: Sign In to Azure Cloudcommand in the Command Palette (Ctrl+Shift+P)
In Visual Studio Code'sAzure Explorerwindow, right-click on theApp Servicesnode and selectCreate New Web App (Advanced).
In Visual Studio Code'sAzure Explorerwindow, right-click on theApp Servicesnode and selectCreate New Web App (Advanced).
Use the following table to create the App Service:PromptValueEnter a globally unique name for the new web app.Enter a prompt such asazure-sql-passwordless. Post-pend a unique string such as123.Select a resource group for new resources.Select+Create a new resource groupthen select the default name.Select a runtime stack.Select an LTS version of the Node.js stack.Select an OS.SelectLinux.Select a location for new resources.Select a location close to you.Select a Linux App Service plan.SelectCreate new App Service plan.then select the default name.Select a pricing tier.SelectFree (F1).Select an Application Insights resource for your app.SelectSkip for now.
Use the following table to create the App Service:
azure-sql-passwordless
123
Wait until the notification that your app was created before continuing.
Wait until the notification that your app was created before continuing.
In theAzure Explorer, expand theApp Servicesnode and right-click your new app.
In theAzure Explorer, expand theApp Servicesnode and right-click your new app.
SelectDeploy to Web App.
SelectDeploy to Web App.

Select the root folder of the JavaScript project.
Select the root folder of the JavaScript project.
When the Visual Studio Code pop-up appears, selectDeploy.
When the Visual Studio Code pop-up appears, selectDeploy.
When the deployment finishes, the app doesn't work correctly on Azure. You still need to configure the secure connection between the App Service and the SQL database to retrieve your data.
Connect the App Service to Azure SQL Database
Passwordless (recommended)
SQL Authentication
The following steps are required to connect the App Service instance to Azure SQL Database:
Create a managed identity for the App Service.
Create a SQL database user and associate it with the App Service managed identity.
Assign SQL roles to the database user that allow for read, write, and potentially other permissions.
There are multiple tools available to implement these steps:
Service Connector (Recommended)
Azure portal
Service Connector is a tool that streamlines authenticated connections between different services in Azure. Service Connector currently supports connecting an App Service to an Azure SQL database via the Azure CLI using theaz webapp connection create sqlcommand. This single command completes the three steps mentioned above for you.
az webapp connection create sql
Create the managed identity with Service Connector
Run the following command in the Azure portal's Cloud Shell. The Cloud Shell has the latest version of the Azure CLI. Replace the variables in<>with your own values.
<>
az webapp connection create sql \
    -g <app-service-resource-group> \
    -n <app-service-name> \
    --tg <database-server-resource-group> \
    --server <database-server-name> \
    --database <database-name> \
    --system-identity
az webapp connection create sql \
    -g <app-service-resource-group> \
    -n <app-service-name> \
    --tg <database-server-resource-group> \
    --server <database-server-name> \
    --database <database-name> \
    --system-identity
Verify the App Service app settings
You can verify the changes made by Service Connector on the App Service settings.
In Visual Studio Code, in the Azure explorer, right-click your App Service and selectOpen in portal.
In Visual Studio Code, in the Azure explorer, right-click your App Service and selectOpen in portal.
Navigate to theIdentitypage for your App Service. Under theSystem assignedtab, theStatusshould be set toOn. This value means that a system-assigned managed identity was enabled for your app.
Navigate to theIdentitypage for your App Service. Under theSystem assignedtab, theStatusshould be set toOn. This value means that a system-assigned managed identity was enabled for your app.
Navigate to theConfigurationpage for your App Service. Under theApplication Settingstab, you should see several environment variables, which were already in themssqlconfiguration object.AZURE_SQL_SERVERAZURE_SQL_DATABASEAZURE_SQL_PORTAZURE_SQL_AUTHENTICATIONTYPEDon't delete or change the property names or values.
Navigate to theConfigurationpage for your App Service. Under theApplication Settingstab, you should see several environment variables, which were already in themssqlconfiguration object.
AZURE_SQL_SERVER
AZURE_SQL_SERVER
AZURE_SQL_DATABASE
AZURE_SQL_DATABASE
AZURE_SQL_PORT
AZURE_SQL_PORT
AZURE_SQL_AUTHENTICATIONTYPE
AZURE_SQL_AUTHENTICATIONTYPE
Don't delete or change the property names or values.
The Azure portal allows you to work with managed identities and run queries against Azure SQL Database. Complete the following steps to create a passwordless connection from your App Service instance to Azure SQL Database:
Create the managed identity
In the Azure portal, navigate to your App Service and selectIdentityon the left navigation.
In the Azure portal, navigate to your App Service and selectIdentityon the left navigation.
On the identity page, change theSystem-assignedstatus toonand selectSave.
On the identity page, change theSystem-assignedstatus toonand selectSave.
When asked to enable the identity, selectYes.When this setting is enabled, a system-assigned managed identity is created with the same name as your App Service. System-assigned identities are tied to the service instance and are destroyed with the app when it's deleted.
When asked to enable the identity, selectYes.
When this setting is enabled, a system-assigned managed identity is created with the same name as your App Service. System-assigned identities are tied to the service instance and are destroyed with the app when it's deleted.
Create the database user and assign roles
In the Azure portal, browse to your SQL database and selectQuery editor (preview).
In the Azure portal, browse to your SQL database and selectQuery editor (preview).
SelectContinue as<your-username>on the right side of the screen to sign into the database using your account.
SelectContinue as<your-username>on the right side of the screen to sign into the database using your account.
<your-username>
On the query editor view, run the following T-SQL commands. Replace<your-app-service-name>with your App Service resource's name.CREATE USER "<your-app-service-name>" FROM EXTERNAL PROVIDER;
ALTER ROLE db_datareader ADD MEMBER "<your-app-service-name>";
ALTER ROLE db_datawriter ADD MEMBER "<your-app-service-name>";
ALTER ROLE db_ddladmin ADD MEMBER "<your-app-service-name>";
GOThis SQL script creates a SQL database user that maps back to the managed identity of your App Service instance. It also assigns the necessary SQL roles to the user to allow your app to read, write, and modify the data and schema of your database. After this step is completed, your services are connected.
On the query editor view, run the following T-SQL commands. Replace<your-app-service-name>with your App Service resource's name.
<your-app-service-name>
CREATE USER "<your-app-service-name>" FROM EXTERNAL PROVIDER;
ALTER ROLE db_datareader ADD MEMBER "<your-app-service-name>";
ALTER ROLE db_datawriter ADD MEMBER "<your-app-service-name>";
ALTER ROLE db_ddladmin ADD MEMBER "<your-app-service-name>";
GO
CREATE USER "<your-app-service-name>" FROM EXTERNAL PROVIDER;
ALTER ROLE db_datareader ADD MEMBER "<your-app-service-name>";
ALTER ROLE db_datawriter ADD MEMBER "<your-app-service-name>";
ALTER ROLE db_ddladmin ADD MEMBER "<your-app-service-name>";
GO

This SQL script creates a SQL database user that maps back to the managed identity of your App Service instance. It also assigns the necessary SQL roles to the user to allow your app to read, write, and modify the data and schema of your database. After this step is completed, your services are connected.
Important
Although this solution provides a simple approach for getting started, it's not a best practice for production-grade environments. In those scenarios, the app shouldn't perform all operations using a single, elevated identity. You should try to implement the principle of least privilege by configuring multiple identities with specific permissions for specific tasks.
You can read more about configuring database roles and security on the following resources:
Tutorial: Secure a database in Azure SQL Database
Authorize database access to SQL Database
Create the App Service app settings
In the Azure portal, navigate to your App Service and selectConfigurationon the left navigation.
In the Azure portal, navigate to your App Service and selectConfigurationon the left navigation.
Select+ New application settingfor each environment variable below. Add your own appropriate value to create the required environment variables for your App Service instance to connect to your database.AZURE_SQL_SERVER=<YOURSERVERNAME>.database.windows.net
AZURE_SQL_DATABASE=<YOURDATABASENAME>
AZURE_SQL_PORT=1433
AZURE_SQL_AUTHENTICATIONTYPE=azure-active-directory-default
Select+ New application settingfor each environment variable below. Add your own appropriate value to create the required environment variables for your App Service instance to connect to your database.
AZURE_SQL_SERVER=<YOURSERVERNAME>.database.windows.net
AZURE_SQL_DATABASE=<YOURDATABASENAME>
AZURE_SQL_PORT=1433
AZURE_SQL_AUTHENTICATIONTYPE=azure-active-directory-default
AZURE_SQL_SERVER=<YOURSERVERNAME>.database.windows.net
AZURE_SQL_DATABASE=<YOURDATABASENAME>
AZURE_SQL_PORT=1433
AZURE_SQL_AUTHENTICATIONTYPE=azure-active-directory-default
When you're done adding settings, selectSave.
When you're done adding settings, selectSave.
In Visual Studio Code, in the Azure explorer, right-click your App Service and selectOpen in portal.
In Visual Studio Code, in the Azure explorer, right-click your App Service and selectOpen in portal.
Navigate to theConfigurationpage for your App Service. Under theApplication Settingstab, create environment variables for each property in the following table, with your own values.AZURE_SQL_SERVER=<YOURSERVERNAME>.database.windows.net
AZURE_SQL_DATABASE=<YOURDATABASENAME>
AZURE_SQL_PORT=1433
AZURE_SQL_USER=<YOURUSERNAME>
AZURE_SQL_PASSWORD=<PASSWORD>
NODE_ENV=development
Navigate to theConfigurationpage for your App Service. Under theApplication Settingstab, create environment variables for each property in the following table, with your own values.
AZURE_SQL_SERVER=<YOURSERVERNAME>.database.windows.net
AZURE_SQL_DATABASE=<YOURDATABASENAME>
AZURE_SQL_PORT=1433
AZURE_SQL_USER=<YOURUSERNAME>
AZURE_SQL_PASSWORD=<PASSWORD>
NODE_ENV=development
AZURE_SQL_SERVER=<YOURSERVERNAME>.database.windows.net
AZURE_SQL_DATABASE=<YOURDATABASENAME>
AZURE_SQL_PORT=1433
AZURE_SQL_USER=<YOURUSERNAME>
AZURE_SQL_PASSWORD=<PASSWORD>
NODE_ENV=development
Warning
Use caution when managing connection objects that contain secrets such as usernames, passwords, or access keys. These secrets shouldn't be committed to source control or placed in unsecure locations where they might be accessed by unintended users. For a real application in a production-grade Azure environment, you can store connection information in a secure location such as App Service configuration settings or Azure Key Vault. During local development, you'll generally connect to a local database that doesn't require storing secrets or connecting directly to Azure.
Test the deployed application
Browse to the URL of the app to test that the connection to Azure SQL Database is working. You can locate the URL of your app on the App Service overview page.
The person you created locally should display in the browser. Congratulations! Your application is now connected to Azure SQL Database in both local and hosted environments.
Tip
If you receive a 500 Internal Server error while testing, it may be due to your database networking configurations. Verify that your logical server is configured with the settings outlined in theConfigure the databasesection.
Clean up the resources
When you are finished working with the Azure SQL Database, delete the resource to avoid unintended costs.
Azure portal
Azure CLI
In the Azure portal search bar, search forAzure SQLand select the matching result.
In the Azure portal search bar, search forAzure SQLand select the matching result.
Locate and select your database in the list of databases.
Locate and select your database in the list of databases.
On theOverviewpage of your Azure SQL Database, selectDelete.
On theOverviewpage of your Azure SQL Database, selectDelete.
On theAzure you sure you want to delete...page that opens, type the name of your database to confirm, and then selectDelete.
On theAzure you sure you want to delete...page that opens, type the name of your database to confirm, and then selectDelete.
Delete your database by using theaz sql db deletecommand. Replace the placeholder parameters with your own values.
az sql db delete
az sql db delete --name <database-name> --resource-group <resource-group-name> --server <logical-server-name>
az sql db delete --name <database-name> --resource-group <resource-group-name> --server <logical-server-name>
Sample code
The sample code for this application is available:
JavaScript
TypeScript
Next steps
Tutorial: Secure a database in Azure SQL Database
Authorize database access to SQL Database
An overview of Azure SQL Database security capabilities
Azure SQL Database security best practices
Feedback
Was this page helpful?
Additional resources