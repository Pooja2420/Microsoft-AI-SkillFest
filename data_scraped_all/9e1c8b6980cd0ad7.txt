Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Develop Azure Functions using Visual Studio
Article
2025-03-17
28 contributors
In this article
Visual Studio lets you develop, test, and deploy C# class library functions to Azure. If this experience is your first with Azure Functions, seeAzure Functions overview.
To get started right away, consider completing theFunctions quickstart for Visual Studio.
This article provides details about how to use Visual Studio to develop C# class library functions and publish them to Azure.
There are two models for developing C# class library functions: theIsolated worker modeland theIn-process model.
You're reading the isolated worker model version this article. You can choose your preferred model at the top of the article.
You're reading the in-process model version this article. You can choose your preferred model at the top of the article.
Important
Support for the in-process model ends on November 10, 2026. We recommend that youmigrate your apps to the isolated worker model.
Unless otherwise noted, procedures and examples shown are for Visual Studio 2022. For more information about Visual Studio 2022 releases, seethe release notesor thepreview release notes.
Prerequisites
Visual Studio 2022, including theAzure developmentworkload.
Visual Studio 2022, including theAzure developmentworkload.
Other resources that you need, such as an Azure Storage account, are created in your subscription during the publishing process.
Other resources that you need, such as an Azure Storage account, are created in your subscription during the publishing process.
If you don't have anAzure subscription, create anAzure free accountbefore you begin.
If you don't have anAzure subscription, create anAzure free accountbefore you begin.
Create an Azure Functions project
The Azure Functions project template in Visual Studio creates a C# class library project that you can publish to a function app in Azure. You can use a function app to group functions as a logical unit for easier management, deployment, scaling, and sharing of resources.
From the Visual Studio menu, selectFile>New>Project.
From the Visual Studio menu, selectFile>New>Project.
InCreate a new project, enterfunctionsin the search box, choose theAzure Functionstemplate, and then selectNext.
InCreate a new project, enterfunctionsin the search box, choose theAzure Functionstemplate, and then selectNext.
InConfigure your new project, enter aProject namefor your project, and then selectCreate. The function app name must be valid as a C# namespace, so don't use underscores, hyphens, or any other nonalphanumeric characters.
InConfigure your new project, enter aProject namefor your project, and then selectCreate. The function app name must be valid as a C# namespace, so don't use underscores, hyphens, or any other nonalphanumeric characters.
For theCreate a new Azure Functions applicationsettings, use the values in the following table:SettingValueDescription.NET version.NET 8 IsolatedThis value creates a function project that runs in anisolated worker process. Isolated worker process supports other non-LTS version of .NET and also .NET Framework. For more information, seeAzure Functions runtime versions overview.Function templateHTTP triggerThis value creates a function triggered by an HTTP request.Storage account (AzureWebJobsStorage)Storage emulatorBecause a function app in Azure requires a storage account, one is assigned or created when you publish your project to Azure. An HTTP trigger doesn't use an Azure Storage account connection string; all other trigger types require a valid Azure Storage account connection string.Authorization levelAnonymousThe created function can be triggered by any client without providing a key. This authorization setting makes it easy to test your new function. For more information, seeAuthorization level.SettingValueDescription.NET version.NET 8This value creates a function project that runs in-process with version 4.x of the Azure Functions runtime. For more information, seeAzure Functions runtime versions overview.Function templateHTTP triggerThis value creates a function triggered by an HTTP request.Storage account (AzureWebJobsStorage)Storage emulatorBecause a function app in Azure requires a storage account, one is assigned or created when you publish your project to Azure. An HTTP trigger doesn't use an Azure Storage account connection string; all other trigger types require a valid Azure Storage account connection string.Authorization levelAnonymousThe created function can be triggered by any client without providing a key. This authorization setting makes it easy to test your new function. For more information, seeAuthorization level.Make sure you set theAuthorization leveltoAnonymous. If you choose the default level ofFunction, you're required to present thefunction keyin requests to access your function endpoint.
For theCreate a new Azure Functions applicationsettings, use the values in the following table:


Make sure you set theAuthorization leveltoAnonymous. If you choose the default level ofFunction, you're required to present thefunction keyin requests to access your function endpoint.
SelectCreateto create the function project and HTTP trigger function.
SelectCreateto create the function project and HTTP trigger function.
After you create an Azure Functions project, the project template creates a C# project, installs theMicrosoft.Azure.Functions.WorkerandMicrosoft.Azure.Functions.Worker.SdkNuGet packages, and sets the target framework.
Microsoft.Azure.Functions.Worker
Microsoft.Azure.Functions.Worker.Sdk
After you create an Azure Functions project, the project template creates a C# project, installs theMicrosoft.NET.Sdk.FunctionsNuGet package, and sets the target framework.
Microsoft.NET.Sdk.Functions
The new project has the following files:
host.json: Lets you configure the Functions host. These settings apply both when running locally and in Azure. For more information, seehost.json reference.
host.json: Lets you configure the Functions host. These settings apply both when running locally and in Azure. For more information, seehost.json reference.
local.settings.json: Maintains settings used when running functions locally. These settings aren't used when running in Azure. For more information, seeLocal settings file.ImportantBecause thelocal.settings.jsonfile can contain secrets, you must exclude it from your project source control. Make sure theCopy to Output Directorysetting for this file is set toCopy if newer.
local.settings.json: Maintains settings used when running functions locally. These settings aren't used when running in Azure. For more information, seeLocal settings file.
Important
Because thelocal.settings.jsonfile can contain secrets, you must exclude it from your project source control. Make sure theCopy to Output Directorysetting for this file is set toCopy if newer.
For more information, seeProject structurein the Isolated worker guide.
For more information, seeFunctions class library project.
Work with app settings locally
When running in a function app in Azure, settings required by your functions arestored securely in app settings. During local development, these settings are instead added to theValuescollection in thelocal.settings.jsonfile. The local.settings.json file also stores settings used by local development tools.
Values
Items in theValuescollection in your project'slocal.settings.jsonfile are intended to mirror items in your function app'sapplication settingsin Azure.
Values
Visual Studio doesn't automatically upload the settings inlocal.settings.jsonwhen you publish the project. To make sure that these settings also exist in your function app in Azure, upload them after you publish your project. For more information, seeFunction app settings. The values in aConnectionStringscollection are never published.
ConnectionStrings
Your code can also read the function app settings values as environment variables. For more information, seeEnvironment variables.
Configure the project for local development
The Functions runtime uses an Azure Storage account internally. For all trigger types other than HTTP and webhooks, set theValues.AzureWebJobsStoragekey to a valid Azure Storage account connection string. Your function app can also use theAzurite emulatorfor theAzureWebJobsStorageconnection setting required by the project. To use the emulator, set the value ofAzureWebJobsStoragetoUseDevelopmentStorage=true. Change this setting to an actual storage account connection string before deployment. For more information, seeLocal storage emulator.
Values.AzureWebJobsStorage
AzureWebJobsStorage
AzureWebJobsStorage
UseDevelopmentStorage=true
To set the storage account connection string:
In the Azure portal, navigate to your storage account.
In the Azure portal, navigate to your storage account.
In theAccess keystab, belowSecurity + networking, copy theConnection stringofkey1.
In theAccess keystab, belowSecurity + networking, copy theConnection stringofkey1.
In your project, open thelocal.settings.jsonfile and set the value of theAzureWebJobsStoragekey to the connection string you copied.
In your project, open thelocal.settings.jsonfile and set the value of theAzureWebJobsStoragekey to the connection string you copied.
AzureWebJobsStorage
Repeat the previous step to add unique keys to theValuesarray for any other connections required by your functions.
Repeat the previous step to add unique keys to theValuesarray for any other connections required by your functions.
Values
Add a function to your project
In C# class library functions, the bindings used by the function are defined by applying attributes in the code. When you create your function triggers from the provided templates, the trigger attributes are applied for you.
InSolution Explorer, right-click your project node and selectAdd>New Azure Function.
InSolution Explorer, right-click your project node and selectAdd>New Azure Function.
Enter aNamefor the class, and then selectAdd.
Enter aNamefor the class, and then selectAdd.
Choose your trigger, set the required binding properties, and then selectAdd. The following example shows the settings for creating a Queue storage trigger function.For an Azure Storage service trigger, check theConfigure connectionbox and you're prompted to choose between using an Azurite storage emulator or referencing a provisioned Azure storage account. SelectNextand if you choose a storage account, Visual Studio tries to connect to your Azure account and get the connection string. ChooseSave connection string value in Local user secrets fileand thenFinishto create the trigger class.This trigger example uses an application setting for the storage connection with a key namedQueueStorage. This key, stored in thelocal.settings.json file, either references the Azurite emulator or an Azure storage account.
Choose your trigger, set the required binding properties, and then selectAdd. The following example shows the settings for creating a Queue storage trigger function.

For an Azure Storage service trigger, check theConfigure connectionbox and you're prompted to choose between using an Azurite storage emulator or referencing a provisioned Azure storage account. SelectNextand if you choose a storage account, Visual Studio tries to connect to your Azure account and get the connection string. ChooseSave connection string value in Local user secrets fileand thenFinishto create the trigger class.
This trigger example uses an application setting for the storage connection with a key namedQueueStorage. This key, stored in thelocal.settings.json file, either references the Azurite emulator or an Azure storage account.
QueueStorage
Examine the newly added class. For example, the following C# class represents a basic Queue storage trigger function:You see a staticRun()method attributed withFunction. This attribute indicates that the method is the entry point for the function.using System;
using Azure.Storage.Queues.Models;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;

namespace Company.Function;

public class QueueTriggerCSharp
{
    private readonly ILogger<QueueTriggerCSharp> _logger;

    public QueueTriggerCSharp(ILogger<QueueTriggerCSharp> logger)
    {
        _logger = logger;
    }

    [Function(nameof(QueueTriggerCSharp))]
    public void Run([QueueTrigger("PathValue", Connection = "ConnectionValue")] QueueMessage message)
    {
        _logger.LogInformation("C# Queue trigger function processed: {messageText}", message.MessageText);
    }
}You see a staticRun()method attributed withFunctionName. This attribute indicates that the method is the entry point for the function.using System;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Host;
using Microsoft.Extensions.Logging;

namespace Company.Function
{
    public class QueueTriggerCSharp
    {
        [FunctionName("QueueTriggerCSharp")]
        public void Run([QueueTrigger("PathValue", Connection = "ConnectionValue")]string myQueueItem, ILogger log)
        {
            log.LogInformation($"C# Queue trigger function processed: {myQueueItem}");
        }
    }
}
Examine the newly added class. For example, the following C# class represents a basic Queue storage trigger function:
You see a staticRun()method attributed withFunction. This attribute indicates that the method is the entry point for the function.
Run()
Function
using System;
using Azure.Storage.Queues.Models;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;

namespace Company.Function;

public class QueueTriggerCSharp
{
    private readonly ILogger<QueueTriggerCSharp> _logger;

    public QueueTriggerCSharp(ILogger<QueueTriggerCSharp> logger)
    {
        _logger = logger;
    }

    [Function(nameof(QueueTriggerCSharp))]
    public void Run([QueueTrigger("PathValue", Connection = "ConnectionValue")] QueueMessage message)
    {
        _logger.LogInformation("C# Queue trigger function processed: {messageText}", message.MessageText);
    }
}
using System;
using Azure.Storage.Queues.Models;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;

namespace Company.Function;

public class QueueTriggerCSharp
{
    private readonly ILogger<QueueTriggerCSharp> _logger;

    public QueueTriggerCSharp(ILogger<QueueTriggerCSharp> logger)
    {
        _logger = logger;
    }

    [Function(nameof(QueueTriggerCSharp))]
    public void Run([QueueTrigger("PathValue", Connection = "ConnectionValue")] QueueMessage message)
    {
        _logger.LogInformation("C# Queue trigger function processed: {messageText}", message.MessageText);
    }
}
You see a staticRun()method attributed withFunctionName. This attribute indicates that the method is the entry point for the function.
Run()
FunctionName
using System;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Host;
using Microsoft.Extensions.Logging;

namespace Company.Function
{
    public class QueueTriggerCSharp
    {
        [FunctionName("QueueTriggerCSharp")]
        public void Run([QueueTrigger("PathValue", Connection = "ConnectionValue")]string myQueueItem, ILogger log)
        {
            log.LogInformation($"C# Queue trigger function processed: {myQueueItem}");
        }
    }
}
using System;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Host;
using Microsoft.Extensions.Logging;

namespace Company.Function
{
    public class QueueTriggerCSharp
    {
        [FunctionName("QueueTriggerCSharp")]
        public void Run([QueueTrigger("PathValue", Connection = "ConnectionValue")]string myQueueItem, ILogger log)
        {
            log.LogInformation($"C# Queue trigger function processed: {myQueueItem}");
        }
    }
}
A binding-specific attribute is applied to each binding parameter supplied to the entry point method. The attribute takes the binding information as parameters. In the previous example, the first parameter has aQueueTriggerattribute applied, indicating a Queue storage trigger function. The queue name and connection string setting name are passed as parameters to theQueueTriggerattribute. For more information, seeAzure Queue storage bindings for Azure Functions.
QueueTrigger
QueueTrigger
Use the previous procedure to add more functions to your function app project. Each function in the project can have a different trigger, but a function must have exactly one trigger. For more information, seeAzure Functions triggers and bindings concepts.
Add bindings
As with triggers, input and output bindings are added to your function as binding attributes. Add bindings to a function as follows:
Make sure youconfigure the project for local development.
Make sure youconfigure the project for local development.
Add the appropriate NuGet extension package for the specific binding by finding the binding-specific NuGet package requirements in the reference article for the binding. For example, find package requirements for the Event Hubs trigger in theEvent Hubs binding reference article.
Add the appropriate NuGet extension package for the specific binding by finding the binding-specific NuGet package requirements in the reference article for the binding. For example, find package requirements for the Event Hubs trigger in theEvent Hubs binding reference article.
Use the following command in the Package Manager Console to install a specific package:Install-Package Microsoft.Azure.Functions.Worker.Extensions.<BINDING_TYPE> -Version <TARGET_VERSION>Install-Package Microsoft.Azure.WebJobs.Extensions.<BINDING_TYPE> -Version <TARGET_VERSION>In this example, replace<BINDING_TYPE>with the name specific to the binding extension and<TARGET_VERSION>with a specific version of the package, such as4.0.0. Valid versions are listed on the individual package pages atNuGet.org.
Use the following command in the Package Manager Console to install a specific package:
Install-Package Microsoft.Azure.Functions.Worker.Extensions.<BINDING_TYPE> -Version <TARGET_VERSION>
Install-Package Microsoft.Azure.Functions.Worker.Extensions.<BINDING_TYPE> -Version <TARGET_VERSION>
Install-Package Microsoft.Azure.WebJobs.Extensions.<BINDING_TYPE> -Version <TARGET_VERSION>
Install-Package Microsoft.Azure.WebJobs.Extensions.<BINDING_TYPE> -Version <TARGET_VERSION>
In this example, replace<BINDING_TYPE>with the name specific to the binding extension and<TARGET_VERSION>with a specific version of the package, such as4.0.0. Valid versions are listed on the individual package pages atNuGet.org.
<BINDING_TYPE>
<TARGET_VERSION>
4.0.0
If there are app settings that the binding needs, add them to theValuescollection in thelocal setting file.The function uses these values when it runs locally. When the function runs in the function app in Azure, it uses thefunction app settings. Visual Studio makes it easy topublish local settings to Azure.
If there are app settings that the binding needs, add them to theValuescollection in thelocal setting file.
Values
The function uses these values when it runs locally. When the function runs in the function app in Azure, it uses thefunction app settings. Visual Studio makes it easy topublish local settings to Azure.
Add the appropriate binding attribute to the method signature. In the following example, a queue message triggers the function, and the output binding creates a new queue message with the same text in a different queue.public class QueueTrigger
{
    private readonly ILogger _logger;

    public QueueTrigger(ILoggerFactory loggerFactory)
    {
        _logger = loggerFactory.CreateLogger<QueueTrigger>();
    }

    [Function("CopyQueueMessage")]
    [QueueOutput("myqueue-items-destination", Connection = "QueueStorage")]
    public string Run([QueueTrigger("myqueue-items-source", Connection = "QueueStorage")] string myQueueItem)
    {
        _logger.LogInformation($"C# Queue trigger function processed: {myQueueItem}");
        return myQueueItem;
    }
}TheQueueOutputattribute defines the binding on the method. For multiple output bindings, you would instead place this attribute on a string property of the returned object. For more information, seeMultiple output bindings.public static class SimpleExampleWithOutput
{
    [FunctionName("CopyQueueMessage")]
    public static void Run(
        [QueueTrigger("myqueue-items-source", Connection = "QueueStorage")] string myQueueItem, 
        [Queue("myqueue-items-destination", Connection = "QueueStorage")] out string myQueueItemCopy,
        ILogger log)
    {
        log.LogInformation($"CopyQueueMessage function processed: {myQueueItem}");
        myQueueItemCopy = myQueueItem;
    }
}TheQueueattribute on theoutparameter defines the output binding.The connection to Queue storage is obtained from theQueueStoragesetting. For more information, see the reference article for the specific binding.
Add the appropriate binding attribute to the method signature. In the following example, a queue message triggers the function, and the output binding creates a new queue message with the same text in a different queue.
public class QueueTrigger
{
    private readonly ILogger _logger;

    public QueueTrigger(ILoggerFactory loggerFactory)
    {
        _logger = loggerFactory.CreateLogger<QueueTrigger>();
    }

    [Function("CopyQueueMessage")]
    [QueueOutput("myqueue-items-destination", Connection = "QueueStorage")]
    public string Run([QueueTrigger("myqueue-items-source", Connection = "QueueStorage")] string myQueueItem)
    {
        _logger.LogInformation($"C# Queue trigger function processed: {myQueueItem}");
        return myQueueItem;
    }
}
public class QueueTrigger
{
    private readonly ILogger _logger;

    public QueueTrigger(ILoggerFactory loggerFactory)
    {
        _logger = loggerFactory.CreateLogger<QueueTrigger>();
    }

    [Function("CopyQueueMessage")]
    [QueueOutput("myqueue-items-destination", Connection = "QueueStorage")]
    public string Run([QueueTrigger("myqueue-items-source", Connection = "QueueStorage")] string myQueueItem)
    {
        _logger.LogInformation($"C# Queue trigger function processed: {myQueueItem}");
        return myQueueItem;
    }
}
TheQueueOutputattribute defines the binding on the method. For multiple output bindings, you would instead place this attribute on a string property of the returned object. For more information, seeMultiple output bindings.
QueueOutput
public static class SimpleExampleWithOutput
{
    [FunctionName("CopyQueueMessage")]
    public static void Run(
        [QueueTrigger("myqueue-items-source", Connection = "QueueStorage")] string myQueueItem, 
        [Queue("myqueue-items-destination", Connection = "QueueStorage")] out string myQueueItemCopy,
        ILogger log)
    {
        log.LogInformation($"CopyQueueMessage function processed: {myQueueItem}");
        myQueueItemCopy = myQueueItem;
    }
}
public static class SimpleExampleWithOutput
{
    [FunctionName("CopyQueueMessage")]
    public static void Run(
        [QueueTrigger("myqueue-items-source", Connection = "QueueStorage")] string myQueueItem, 
        [Queue("myqueue-items-destination", Connection = "QueueStorage")] out string myQueueItemCopy,
        ILogger log)
    {
        log.LogInformation($"CopyQueueMessage function processed: {myQueueItem}");
        myQueueItemCopy = myQueueItem;
    }
}
TheQueueattribute on theoutparameter defines the output binding.
Queue
out
The connection to Queue storage is obtained from theQueueStoragesetting. For more information, see the reference article for the specific binding.
QueueStorage
For a full list of the bindings supported by Functions, seeSupported bindings. For a more complete example of this scenario, seeConnect functions to Azure Storage using Visual Studio.
Run functions locally
Azure Functions Core Tools lets you run Azure Functions project on your local development computer. When you pressF5to debug a Functions project, the local Functions host (func.exe) starts to listen on a local port (usually 7071). Any callable function endpoints are written to the output, and you can use these endpoints for testing your functions. For more information, seeDevelop Azure Functions locally using Core Tools. You're prompted to install these tools the first time you start a function from Visual Studio.
Important
Starting with version 4.0.6517 of the Core Tools, in-process model projects must referenceversion 4.5.0 or later ofMicrosoft.NET.Sdk.Functions. If an earlier version is used, thefunc startcommand will error.
Microsoft.NET.Sdk.Functions
func start
To start your function in Visual Studio in debug mode:
PressF5. If prompted, accept the request from Visual Studio to download and install Azure Functions Core (CLI) tools. You might also need to enable a firewall exception so that the tools can handle HTTP requests.
PressF5. If prompted, accept the request from Visual Studio to download and install Azure Functions Core (CLI) tools. You might also need to enable a firewall exception so that the tools can handle HTTP requests.
With the project running, test your code as you would test a deployed function.When you run Visual Studio in debug mode, breakpoints are hit as expected.
With the project running, test your code as you would test a deployed function.
When you run Visual Studio in debug mode, breakpoints are hit as expected.
For a more detailed testing scenario using Visual Studio, seeTesting functions.
Publish to Azure
When you publish your functions project to Azure, Visual Studio useszip deploymentto deploy the project files. When possible, you should also selectRun-From-Packageso that the project runs in the deployment (.zip) package. For more information, seeRun your functions from a package file in Azure.
Don't deploy to Azure Functions using Web Deploy (msdeploy).
msdeploy
Use the following steps to publish your project to a function app in Azure.
InSolution Explorer, right-click the project and selectPublish. InTarget, selectAzure, and then selectNext.
InSolution Explorer, right-click the project and selectPublish. InTarget, selectAzure, and then selectNext.

OnSpecific target, selectAzure Function App (Windows). A function app that runs on Windows is created. SelectNext.
OnSpecific target, selectAzure Function App (Windows). A function app that runs on Windows is created. SelectNext.

OnFunctions instance, selectCreate a new Azure Function.
OnFunctions instance, selectCreate a new Azure Function.

Create a new instance by using the values specified in the following table:SettingValueDescriptionNameGlobally unique nameName that uniquely identifies your new function app. Accept this name or enter a new name. Valid characters are:a-z,0-9, and-.SubscriptionYour subscriptionThe Azure subscription to use. Accept this subscription or select a new one from the dropdown list.Resource groupName of your resource groupThe resource group in which you want to create your function app. SelectNewto create a new resource group. You can also choose to use an existing resource group from the dropdown list.Plan TypeConsumptionWhen you publish your project to a function app that runs in aConsumption plan, you pay only for executions of your functions app. Other hosting plans incur higher costs.LocationLocation of the app serviceSelect aLocationin anAzure regionnear you or other services your functions access.Azure StorageGeneral-purpose storage accountAn Azure storage account is required by the Functions runtime. SelectNewto configure a general-purpose storage account. You can also choose to use an existing account that meets thestorage account requirements.Application InsightsApplication Insights instanceYou should enable Azure Application Insights integration for your function app. SelectNewto create a new instance, either in a new or in an existing Log Analytics workspace. You can also choose to use an existing instance.
Create a new instance by using the values specified in the following table:
a-z
0-9
-

SelectCreateto create a function app and its related resources in Azure. The status of resource creation is shown in the lower-left corner of the window.
SelectCreateto create a function app and its related resources in Azure. The status of resource creation is shown in the lower-left corner of the window.
OnFunctions instance, make sure that theRun from package filecheckbox is selected. Your function app is deployed by usingZip DeploywithRun-From-Packagemode enabled. Zip Deploy is the recommended deployment method for your functions project for better performance.
OnFunctions instance, make sure that theRun from package filecheckbox is selected. Your function app is deployed by usingZip DeploywithRun-From-Packagemode enabled. Zip Deploy is the recommended deployment method for your functions project for better performance.

SelectFinish, and on thePublishpane, selectPublishto deploy the package that contains your project files to your new function app in Azure.When deployment is completed, the root URL of the function app in Azure is shown on thePublishtab.
SelectFinish, and on thePublishpane, selectPublishto deploy the package that contains your project files to your new function app in Azure.
When deployment is completed, the root URL of the function app in Azure is shown on thePublishtab.
On thePublishtab, in theHostingsection, selectOpen in Azure portal. The new function app Azure resource opens in the Azure portal.
On thePublishtab, in theHostingsection, selectOpen in Azure portal. The new function app Azure resource opens in the Azure portal.

Function app settings
Visual Studio doesn't upload these settings automatically when you publish the project. Any settings you add in thelocal.settings.jsonyou must also add to the function app in Azure.
The easiest way to upload the required settings to your function app in Azure is to expand the three dots next to theHostingsection and select theManage Azure App Service settingslink that appears after you successfully publish your project.

Selecting this link displays theApplication settingsdialog for the function app, where you can add new application settings or modify existing ones.

Localdisplays a setting value in thelocal.settings.jsonfile, andRemotedisplays a current setting value in the function app in Azure. ChooseAdd settingto create a new app setting. Use theInsert value from Locallink to copy a setting value to theRemotefield. Pending changes are written to the local settings file and the function app when you selectOK.
Note
By default, thelocal.settings.jsonfile isn't checked into source control. This means that if you clone a local Functions project from source control, the project doesn't have alocal.settings.jsonfile. In this case, you need to manually create thelocal.settings.jsonfile in the project root so that theApplication settingsdialog works as expected.
You can also manage application settings in one of these other ways:
Use the Azure portal
Use the--publish-local-settingspublish option in the Azure Functions Core Tools
--publish-local-settings
Use the Azure CLI
Remote debugging
To debug your function app remotely, you must publish a debug configuration of your project. You also need to enable remote debugging in your function app in Azure.
This section assumes you've already published to your function app using a release configuration.
Remote debugging considerations
Remote debugging isn't recommended on a production service.
If you haveJust My Code debuggingenabled, disable it.
Avoid long stops at breakpoints when remote debugging. Azure treats a process that is stopped for longer than a few minutes as an unresponsive process, and shuts it down.
While you're debugging, the server sends data to Visual Studio, which could affect bandwidth charges. For information about bandwidth rates, seePricing calculator.
Remote debugging is automatically disabled in your function app after 48 hours. After 48 hours, you'll need to reenable remote debugging.
Attach the debugger
The way you attach the debugger depends on your execution mode. When debugging an isolated worker process app, you currently need to attach the remote debugger to a separate .NET process, and several other configuration steps are required.
When you're done, you shoulddisable remote debugging.
To attach a remote debugger to a function app running in a process separate from the Functions host:
From thePublishtab, select the ellipses (...) in theHostingsection, and then chooseDownload publish profile. This action downloads a copy of the publish profile and opens the download location. You need this file, which contains the credentials used to attach to your isolated worker process running in Azure.CautionThe.publishsettingsfile contains your credentials (unencoded) that are used to administer your function app. The security best practice for this file is to store it temporarily outside your source directories (for example in the Libraries\Documents folder), and then delete it after it's no longer needed. A malicious user who gains access to the.publishsettingsfile can edit, create, and delete your function app.
From thePublishtab, select the ellipses (...) in theHostingsection, and then chooseDownload publish profile. This action downloads a copy of the publish profile and opens the download location. You need this file, which contains the credentials used to attach to your isolated worker process running in Azure.
Caution
The.publishsettingsfile contains your credentials (unencoded) that are used to administer your function app. The security best practice for this file is to store it temporarily outside your source directories (for example in the Libraries\Documents folder), and then delete it after it's no longer needed. A malicious user who gains access to the.publishsettingsfile can edit, create, and delete your function app.
Again from thePublishtab, select the ellipses (...) in theHostingsection, and then chooseAttach debugger.Visual Studio connects to your function app and enables remote debugging, if not already enabled.NoteBecause the remote debugger isn't able to connect to the host process, you could see an error. In any case, the default debugging doesn't break into your code.
Again from thePublishtab, select the ellipses (...) in theHostingsection, and then chooseAttach debugger.
Visual Studio connects to your function app and enables remote debugging, if not already enabled.
Note
Because the remote debugger isn't able to connect to the host process, you could see an error. In any case, the default debugging doesn't break into your code.
Back in Visual Studio, copy the URL for theSiteunderHostingin thePublishpage.
Back in Visual Studio, copy the URL for theSiteunderHostingin thePublishpage.
From theDebugmenu, selectAttach to Process, and in theAttach to processwindow, paste the URL in theConnection Target, removehttps://and append the port:4024.Verify that your target looks like<FUNCTION_APP>.azurewebsites.net:4024and pressEnter.
From theDebugmenu, selectAttach to Process, and in theAttach to processwindow, paste the URL in theConnection Target, removehttps://and append the port:4024.
https://
:4024
Verify that your target looks like<FUNCTION_APP>.azurewebsites.net:4024and pressEnter.
<FUNCTION_APP>.azurewebsites.net:4024

If prompted, allow Visual Studio access through your local firewall.
If prompted, allow Visual Studio access through your local firewall.
When prompted for credentials, instead of local user credentials choose a different account (More choiceson Windows). Provide the values ofuserNameanduserPWDfrom the published profile forEmail addressandPasswordin the authentication dialog on Windows. After a secure connection is established with the deployment server, the available processes are shown.
When prompted for credentials, instead of local user credentials choose a different account (More choiceson Windows). Provide the values ofuserNameanduserPWDfrom the published profile forEmail addressandPasswordin the authentication dialog on Windows. After a secure connection is established with the deployment server, the available processes are shown.

CheckShow process from all usersand then choosedotnet.exeand selectAttach. When the operation completes, you're attached to your C# class library code running in an isolated worker process. At this point, you can debug your function app as normal.
CheckShow process from all usersand then choosedotnet.exeand selectAttach. When the operation completes, you're attached to your C# class library code running in an isolated worker process. At this point, you can debug your function app as normal.
To attach a remote debugger to a function app running in-process with the Functions host:
From thePublishtab, select the ellipses (...) in theHostingsection, and then chooseAttach debugger.
Visual Studio connects to your function app and enables remote debugging, if not already enabled. It also locates and attaches the debugger to the host process for the app. At this point, you can debug your function app as normal.
Disable remote debugging
After you're done remote debugging your code, you should disable remote debugging in theAzure portal. Remote debugging is automatically disabled after 48 hours, in case you forget.
In thePublishtab in your project, select the ellipses (...) in theHostingsection, and chooseOpen in Azure portal. This action opens the function app in the Azure portal to which your project is deployed.
In thePublishtab in your project, select the ellipses (...) in theHostingsection, and chooseOpen in Azure portal. This action opens the function app in the Azure portal to which your project is deployed.
In the functions app, selectConfigurationundersettings, chooseGeneral Settings, setRemote DebuggingtoOff, and selectSavethenContinue.
In the functions app, selectConfigurationundersettings, chooseGeneral Settings, setRemote DebuggingtoOff, and selectSavethenContinue.
After the function app restarts, you can no longer remotely connect to your remote processes. You can use this same tab in the Azure portal to enable remote debugging outside of Visual Studio.
Monitoring functions
The recommended way to monitor the execution of your functions is by integrating your function app with Azure Application Insights. You should enable this integration when you create your function app during Visual Studio publishing.
If for some reason the integration wasn't done during publishing, you should stillenable Application Insights integrationfor your function app in Azure.
To learn more about monitoring using Application Insights, seeMonitor Azure Functions.
Testing functions
This section describes how to create a C# in-process model project that you can test withxUnit, which is an open-source unit testing tool for .NET.
Step 1: Setup
Follow these steps to configure the environment, including the app project and functions, required to support your tests:
Create a new Functions appand name itFunctions
Create an HTTP function from the templateand name itMyHttpTrigger.
Create a timer function from the templateand name itMyTimerTrigger.
Create an xUnit Test appin the solution and name itFunctions.Tests. Remove the default test files.
Use NuGet to add a reference from the test app toMicrosoft.AspNetCore.Mvc
Reference theFunctionsappfromFunctions.Testsapp.
Now that the projects are created, you can create the classes used to run the automated tests.
Step 2: Create test classes
Each function takes an instance ofILoggerto handle message logging. Some tests either don't log messages or have no concern for how logging is implemented. Other tests need to evaluate messages logged to determine whether a test is passing.
ILogger
Create a class namedListLogger, which holds an internal list of messages to evaluate during testing. To implement the requiredILoggerinterface, the class needs a scope. The following class mocks a scope for the test cases to pass to theListLoggerclass.
Create a class namedListLogger, which holds an internal list of messages to evaluate during testing. To implement the requiredILoggerinterface, the class needs a scope. The following class mocks a scope for the test cases to pass to theListLoggerclass.
ListLogger
ILogger
ListLogger
Create a new class in yourFunctions.Testsproject namedNullScope.csand add this code:using System;

namespace Functions.Tests
{
    public class NullScope : IDisposable
    {
        public static NullScope Instance { get; } = new NullScope();

        private NullScope() { }

        public void Dispose() { }
    }
}
Create a new class in yourFunctions.Testsproject namedNullScope.csand add this code:
using System;

namespace Functions.Tests
{
    public class NullScope : IDisposable
    {
        public static NullScope Instance { get; } = new NullScope();

        private NullScope() { }

        public void Dispose() { }
    }
}
using System;

namespace Functions.Tests
{
    public class NullScope : IDisposable
    {
        public static NullScope Instance { get; } = new NullScope();

        private NullScope() { }

        public void Dispose() { }
    }
}
Create a class in yourFunctions.Testsproject namedListLogger.csand add this code:using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Text;

namespace Functions.Tests
{
    public class ListLogger : ILogger
    {
        public IList<string> Logs;

        public IDisposable BeginScope<TState>(TState state) => NullScope.Instance;

        public bool IsEnabled(LogLevel logLevel) => false;

        public ListLogger()
        {
            this.Logs = new List<string>();
        }

        public void Log<TState>(LogLevel logLevel,
                                EventId eventId,
                                TState state,
                                Exception exception,
                                Func<TState, Exception, string> formatter)
        {
            string message = formatter(state, exception);
            this.Logs.Add(message);
        }
    }
}TheListLoggerclass implements the following members as contracted by theILoggerinterface:BeginScope: Scopes add context to your logging. In this case, the test just points to the static instance on theNullScopeclass to allow the test to function.IsEnabled: A default value offalseis provided.Log: This method uses the providedformatterfunction to format the message and then adds the resulting text to theLogscollection.TheLogscollection is an instance ofList<string>and is initialized in the constructor.
Create a class in yourFunctions.Testsproject namedListLogger.csand add this code:
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Text;

namespace Functions.Tests
{
    public class ListLogger : ILogger
    {
        public IList<string> Logs;

        public IDisposable BeginScope<TState>(TState state) => NullScope.Instance;

        public bool IsEnabled(LogLevel logLevel) => false;

        public ListLogger()
        {
            this.Logs = new List<string>();
        }

        public void Log<TState>(LogLevel logLevel,
                                EventId eventId,
                                TState state,
                                Exception exception,
                                Func<TState, Exception, string> formatter)
        {
            string message = formatter(state, exception);
            this.Logs.Add(message);
        }
    }
}
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Text;

namespace Functions.Tests
{
    public class ListLogger : ILogger
    {
        public IList<string> Logs;

        public IDisposable BeginScope<TState>(TState state) => NullScope.Instance;

        public bool IsEnabled(LogLevel logLevel) => false;

        public ListLogger()
        {
            this.Logs = new List<string>();
        }

        public void Log<TState>(LogLevel logLevel,
                                EventId eventId,
                                TState state,
                                Exception exception,
                                Func<TState, Exception, string> formatter)
        {
            string message = formatter(state, exception);
            this.Logs.Add(message);
        }
    }
}
TheListLoggerclass implements the following members as contracted by theILoggerinterface:
ListLogger
ILogger
BeginScope: Scopes add context to your logging. In this case, the test just points to the static instance on theNullScopeclass to allow the test to function.
BeginScope: Scopes add context to your logging. In this case, the test just points to the static instance on theNullScopeclass to allow the test to function.
BeginScope
NullScope
IsEnabled: A default value offalseis provided.
IsEnabled: A default value offalseis provided.
IsEnabled
false
Log: This method uses the providedformatterfunction to format the message and then adds the resulting text to theLogscollection.
Log: This method uses the providedformatterfunction to format the message and then adds the resulting text to theLogscollection.
Log
formatter
Logs
TheLogscollection is an instance ofList<string>and is initialized in the constructor.
Logs
List<string>
Create a code file inFunctions.Testsproject namedLoggerTypes.csand add this code:namespace Functions.Tests
{
    public enum LoggerTypes
    {
        Null,
        List
    }
}This enumeration specifies the type of logger used by the tests.
Create a code file inFunctions.Testsproject namedLoggerTypes.csand add this code:
namespace Functions.Tests
{
    public enum LoggerTypes
    {
        Null,
        List
    }
}
namespace Functions.Tests
{
    public enum LoggerTypes
    {
        Null,
        List
    }
}
This enumeration specifies the type of logger used by the tests.
Create a class inFunctions.Testsproject namedTestFactory.csand add this code:using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Http.Internal;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Primitives;
using System.Collections.Generic;

namespace Functions.Tests
{
    public class TestFactory
    {
        public static IEnumerable<object[]> Data()
        {
            return new List<object[]>
            {
                new object[] { "name", "Bill" },
                new object[] { "name", "Paul" },
                new object[] { "name", "Steve" }

            };
        }

        private static Dictionary<string, StringValues> CreateDictionary(string key, string value)
        {
            var qs = new Dictionary<string, StringValues>
            {
                { key, value }
            };
            return qs;
        }

        public static HttpRequest CreateHttpRequest(string queryStringKey, string queryStringValue)
        {
            var context = new DefaultHttpContext();
            var request = context.Request;
            request.Query = new QueryCollection(CreateDictionary(queryStringKey, queryStringValue));
            return request;
        }

        public static ILogger CreateLogger(LoggerTypes type = LoggerTypes.Null)
        {
            ILogger logger;

            if (type == LoggerTypes.List)
            {
                logger = new ListLogger();
            }
            else
            {
                logger = NullLoggerFactory.Instance.CreateLogger("Null Logger");
            }

            return logger;
        }
    }
}TheTestFactoryclass implements the following members:Data: This property returns anIEnumerablecollection of sample data. The key value pairs represent values that are passed into a query string.CreateDictionary: This method accepts a key/value pair as arguments and returns a newDictionaryused to createQueryCollectionto represent query string values.CreateHttpRequest: This method creates an HTTP request initialized with the given query string parameters.CreateLogger: Based on the logger type, this method returns a logger class used for testing. TheListLoggerkeeps track of logged messages available for evaluation in tests.
Create a class inFunctions.Testsproject namedTestFactory.csand add this code:
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Http.Internal;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Primitives;
using System.Collections.Generic;

namespace Functions.Tests
{
    public class TestFactory
    {
        public static IEnumerable<object[]> Data()
        {
            return new List<object[]>
            {
                new object[] { "name", "Bill" },
                new object[] { "name", "Paul" },
                new object[] { "name", "Steve" }

            };
        }

        private static Dictionary<string, StringValues> CreateDictionary(string key, string value)
        {
            var qs = new Dictionary<string, StringValues>
            {
                { key, value }
            };
            return qs;
        }

        public static HttpRequest CreateHttpRequest(string queryStringKey, string queryStringValue)
        {
            var context = new DefaultHttpContext();
            var request = context.Request;
            request.Query = new QueryCollection(CreateDictionary(queryStringKey, queryStringValue));
            return request;
        }

        public static ILogger CreateLogger(LoggerTypes type = LoggerTypes.Null)
        {
            ILogger logger;

            if (type == LoggerTypes.List)
            {
                logger = new ListLogger();
            }
            else
            {
                logger = NullLoggerFactory.Instance.CreateLogger("Null Logger");
            }

            return logger;
        }
    }
}
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Http.Internal;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Primitives;
using System.Collections.Generic;

namespace Functions.Tests
{
    public class TestFactory
    {
        public static IEnumerable<object[]> Data()
        {
            return new List<object[]>
            {
                new object[] { "name", "Bill" },
                new object[] { "name", "Paul" },
                new object[] { "name", "Steve" }

            };
        }

        private static Dictionary<string, StringValues> CreateDictionary(string key, string value)
        {
            var qs = new Dictionary<string, StringValues>
            {
                { key, value }
            };
            return qs;
        }

        public static HttpRequest CreateHttpRequest(string queryStringKey, string queryStringValue)
        {
            var context = new DefaultHttpContext();
            var request = context.Request;
            request.Query = new QueryCollection(CreateDictionary(queryStringKey, queryStringValue));
            return request;
        }

        public static ILogger CreateLogger(LoggerTypes type = LoggerTypes.Null)
        {
            ILogger logger;

            if (type == LoggerTypes.List)
            {
                logger = new ListLogger();
            }
            else
            {
                logger = NullLoggerFactory.Instance.CreateLogger("Null Logger");
            }

            return logger;
        }
    }
}
TheTestFactoryclass implements the following members:
TestFactory
Data: This property returns anIEnumerablecollection of sample data. The key value pairs represent values that are passed into a query string.
Data: This property returns anIEnumerablecollection of sample data. The key value pairs represent values that are passed into a query string.
Data
CreateDictionary: This method accepts a key/value pair as arguments and returns a newDictionaryused to createQueryCollectionto represent query string values.
CreateDictionary: This method accepts a key/value pair as arguments and returns a newDictionaryused to createQueryCollectionto represent query string values.
CreateDictionary
Dictionary
QueryCollection
CreateHttpRequest: This method creates an HTTP request initialized with the given query string parameters.
CreateHttpRequest: This method creates an HTTP request initialized with the given query string parameters.
CreateHttpRequest
CreateLogger: Based on the logger type, this method returns a logger class used for testing. TheListLoggerkeeps track of logged messages available for evaluation in tests.
CreateLogger: Based on the logger type, this method returns a logger class used for testing. TheListLoggerkeeps track of logged messages available for evaluation in tests.
CreateLogger
ListLogger
Create a class inFunctions.Testsproject namedFunctionsTests.csand add this code:using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Xunit;

namespace Functions.Tests
{
    public class FunctionsTests
    {
        private readonly ILogger logger = TestFactory.CreateLogger();

        [Fact]
        public async void Http_trigger_should_return_known_string()
        {
            var request = TestFactory.CreateHttpRequest("name", "Bill");
            var response = (OkObjectResult)await MyHttpTrigger.Run(request, logger);
            Assert.Equal("Hello, Bill. This HTTP triggered function executed successfully.", response.Value);
        }

        [Theory]
        [MemberData(nameof(TestFactory.Data), MemberType = typeof(TestFactory))]
        public async void Http_trigger_should_return_known_string_from_member_data(string queryStringKey, string queryStringValue)
        {
            var request = TestFactory.CreateHttpRequest(queryStringKey, queryStringValue);
            var response = (OkObjectResult)await MyHttpTrigger.Run(request, logger);
            Assert.Equal($"Hello, {queryStringValue}. This HTTP triggered function executed successfully.", response.Value);
        }

        [Fact]
        public void Timer_should_log_message()
        {
            var logger = (ListLogger)TestFactory.CreateLogger(LoggerTypes.List);
            new MyTimerTrigger().Run(null, logger);
            var msg = logger.Logs[0];
            Assert.Contains("C# Timer trigger function executed at", msg);
        }
    }
}The members implemented in this class are:Http_trigger_should_return_known_string: This test creates a request with the query string values ofname=Billto an HTTP function and checks that the expected response is returned.Http_trigger_should_return_string_from_member_data: This test uses xUnit attributes to provide sample data to the HTTP function.Timer_should_log_message: This test creates an instance ofListLoggerand passes it to a timer function. Once the function is run, then the log is checked to make sure the expected message is present.
Create a class inFunctions.Testsproject namedFunctionsTests.csand add this code:
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Xunit;

namespace Functions.Tests
{
    public class FunctionsTests
    {
        private readonly ILogger logger = TestFactory.CreateLogger();

        [Fact]
        public async void Http_trigger_should_return_known_string()
        {
            var request = TestFactory.CreateHttpRequest("name", "Bill");
            var response = (OkObjectResult)await MyHttpTrigger.Run(request, logger);
            Assert.Equal("Hello, Bill. This HTTP triggered function executed successfully.", response.Value);
        }

        [Theory]
        [MemberData(nameof(TestFactory.Data), MemberType = typeof(TestFactory))]
        public async void Http_trigger_should_return_known_string_from_member_data(string queryStringKey, string queryStringValue)
        {
            var request = TestFactory.CreateHttpRequest(queryStringKey, queryStringValue);
            var response = (OkObjectResult)await MyHttpTrigger.Run(request, logger);
            Assert.Equal($"Hello, {queryStringValue}. This HTTP triggered function executed successfully.", response.Value);
        }

        [Fact]
        public void Timer_should_log_message()
        {
            var logger = (ListLogger)TestFactory.CreateLogger(LoggerTypes.List);
            new MyTimerTrigger().Run(null, logger);
            var msg = logger.Logs[0];
            Assert.Contains("C# Timer trigger function executed at", msg);
        }
    }
}
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Xunit;

namespace Functions.Tests
{
    public class FunctionsTests
    {
        private readonly ILogger logger = TestFactory.CreateLogger();

        [Fact]
        public async void Http_trigger_should_return_known_string()
        {
            var request = TestFactory.CreateHttpRequest("name", "Bill");
            var response = (OkObjectResult)await MyHttpTrigger.Run(request, logger);
            Assert.Equal("Hello, Bill. This HTTP triggered function executed successfully.", response.Value);
        }

        [Theory]
        [MemberData(nameof(TestFactory.Data), MemberType = typeof(TestFactory))]
        public async void Http_trigger_should_return_known_string_from_member_data(string queryStringKey, string queryStringValue)
        {
            var request = TestFactory.CreateHttpRequest(queryStringKey, queryStringValue);
            var response = (OkObjectResult)await MyHttpTrigger.Run(request, logger);
            Assert.Equal($"Hello, {queryStringValue}. This HTTP triggered function executed successfully.", response.Value);
        }

        [Fact]
        public void Timer_should_log_message()
        {
            var logger = (ListLogger)TestFactory.CreateLogger(LoggerTypes.List);
            new MyTimerTrigger().Run(null, logger);
            var msg = logger.Logs[0];
            Assert.Contains("C# Timer trigger function executed at", msg);
        }
    }
}
The members implemented in this class are:
Http_trigger_should_return_known_string: This test creates a request with the query string values ofname=Billto an HTTP function and checks that the expected response is returned.
Http_trigger_should_return_known_string: This test creates a request with the query string values ofname=Billto an HTTP function and checks that the expected response is returned.
Http_trigger_should_return_known_string
name=Bill
Http_trigger_should_return_string_from_member_data: This test uses xUnit attributes to provide sample data to the HTTP function.
Http_trigger_should_return_string_from_member_data: This test uses xUnit attributes to provide sample data to the HTTP function.
Http_trigger_should_return_string_from_member_data
Timer_should_log_message: This test creates an instance ofListLoggerand passes it to a timer function. Once the function is run, then the log is checked to make sure the expected message is present.
Timer_should_log_message: This test creates an instance ofListLoggerand passes it to a timer function. Once the function is run, then the log is checked to make sure the expected message is present.
Timer_should_log_message
ListLogger
To access application settings in your tests, you caninjectanIConfigurationinstance with mocked environment variable values into your function.
To access application settings in your tests, you caninjectanIConfigurationinstance with mocked environment variable values into your function.
IConfiguration
Step 3: Run tests
To run the tests, navigate to theTest Explorerand selectRun All Tests in View.

Step 4: Debug tests
To debug the tests, set a breakpoint on a test, then navigate to theTest Explorerand selectRun > Debug Last Run.
Related content
Develop Azure Functions locally using Core Tools
C# in-process model guide
C# isolated worker model guide
Feedback
Was this page helpful?
Additional resources