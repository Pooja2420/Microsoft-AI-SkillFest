Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Limits and configuration reference for Azure Logic Apps
Article
2025-03-27
46 contributors
In this article
Applies to:Azure Logic Apps (Consumption + Standard)
Important
For Power Automate, seeLimits and configuration in Power Automate.
This reference guide describes the limits and configuration information for Azure Logic Apps and related resources. Based on your scenario, solution requirements, the capabilities that you want, and the environment where you want to run your workflows, you choose whether to create a Consumption logic app workflow that runs inmultitenantAzure Logic Apps or a Standard logic app workflow that runs insingle-tenantAzure Logic Apps or an App Service Environment (v3 - Windows plans only).
Note
Many limits are the same across the available environments where Azure Logic Apps runs, but differences are noted where they exist.
The following table briefly summarizes differences between a Consumption logic app and a Standard logic app.

Workflow definition limits
The following tables list the values for a single workflow definition:
description
parameters
outputs
trackedProperties

Run duration and history retention limits
The following table lists the values for a single workflow run:

Change run duration and history retention in storage
If a run's duration exceeds the current run history retention limit, the run is removed from the run history in storage. To avoid losing run history, make sure that the retention limit isalwaysmore than the run's longest possible duration.
Consumption
Standard
For Consumption logic app workflows, the same setting controls the maximum number of days that a workflow can run and for keeping run history in storage.
In multitenant Azure Logic Apps, the 90-day default limit is the same as the maximum limit. You can only decrease this value.
For example, suppose that you reduce the retention limit from 90 days to 30 days. A 60-day-old run is removed from the run history. If you increase the retention period from 30 days to 60 days, a 20-day-old run stays in the run history for another 40 days.
In theAzure portalsearch box, open your logic app workflow in the designer.
In theAzure portalsearch box, open your logic app workflow in the designer.
On the logic app menu, selectWorkflow settings.
On the logic app menu, selectWorkflow settings.
UnderRuntime options, from theRun history retention in dayslist, selectCustom.
UnderRuntime options, from theRun history retention in dayslist, selectCustom.
Drag the slider to change the number of days that you want.
Drag the slider to change the number of days that you want.
When you're done, on theWorkflow settingstoolbar, selectSave.
When you're done, on theWorkflow settingstoolbar, selectSave.
If you use an Azure Resource Manager template, this setting appears as a property in your workflow's resource definition, which is described in theMicrosoft.Logic workflows template reference:
{
   "name": "{logic-app-name}",
   "type": "Microsoft.Logic/workflows",
   "location": "{Azure-region}",
   "apiVersion": "2019-05-01",
   "properties": {
      "definition": {},
      "parameters": {},
      "runtimeConfiguration": {
         "lifetime": {
            "unit": "day",
            "count": {number-of-days}
         }
      }
   }
}
{
   "name": "{logic-app-name}",
   "type": "Microsoft.Logic/workflows",
   "location": "{Azure-region}",
   "apiVersion": "2019-05-01",
   "properties": {
      "definition": {},
      "parameters": {},
      "runtimeConfiguration": {
         "lifetime": {
            "unit": "day",
            "count": {number-of-days}
         }
      }
   }
}
For Standard logic app workflows, you can decrease or increase the 90-day default limit, but you need to add the following settings and their values to your logic app resource or project:
An app setting namedWorkflows.RuntimeConfiguration.RetentionInDays
An app setting namedWorkflows.RuntimeConfiguration.RetentionInDays
A host setting namedRuntime.FlowMaintenanceJob.RetentionCooldownInterval
A host setting namedRuntime.FlowMaintenanceJob.RetentionCooldownInterval
By default, the app setting namedWorkflows.RuntimeConfiguration.RetentionInDaysis set to keep 90 days of data. The host setting namedRuntime.FlowMaintenanceJob.RetentionCooldownIntervalis set to check every 7 days for old data to delete. If you leave these default values, you might see dataup to97 days old. For example, suppose Azure Logic Apps checks on Day X and deletes data older than Day X - 90 days, and then waits for 7 days before running again. This behavior results in data that ages up to 97 days before the job runs again. However, if you set the interval to 1 day, but leave the retention days at the default value, the maximum delay to delete old data is 90+1 days.
Follow these steps to add the app setting namedWorkflows.RuntimeConfiguration.RetentionInDays, and set the value to the number days that you want to keep your workflow run history.
Follow these steps to add the app setting namedWorkflows.RuntimeConfiguration.RetentionInDays, and set the value to the number days that you want to keep your workflow run history.
Follow these steps to add the host setting namedRuntime.FlowMaintenanceJob.RetentionCooldownInterval, and set the value to the number of days as the interval between when to check for and delete run history that you don't want to keep.
Follow these steps to add the host setting namedRuntime.FlowMaintenanceJob.RetentionCooldownInterval, and set the value to the number of days as the interval between when to check for and delete run history that you don't want to keep.
Follow these steps to add the app setting namedWorkflows.RuntimeConfiguration.RetentionInDays, and set the value to the number days that you want to keep your workflow run history.
Follow these steps to add the app setting namedWorkflows.RuntimeConfiguration.RetentionInDays, and set the value to the number days that you want to keep your workflow run history.
Follow these steps to add the host setting namedRuntime.FlowMaintenanceJob.RetentionCooldownInterval, and set the value to the number of days as the interval between when to check for and delete run history that you don't want to keep.
Follow these steps to add the host setting namedRuntime.FlowMaintenanceJob.RetentionCooldownInterval, and set the value to the number of days as the interval between when to check for and delete run history that you don't want to keep.

Looping, concurrency, and debatching limits
The following table lists the values for a single workflow run:
Loop actions

The following table lists the values for aFor eachloop:

The following table lists the values for anUntilloop:

Concurrency and debatching

Throughput limits
The following table lists the values for a single workflow definition:

Scale for high throughput
Standard
Consumption
In single-tenant Azure Logic Apps, a Standard logic app resource uses storage and compute as the primary resources to run workflows.
Storage
Stateful workflows in single-tenant Azure Logic Apps use Azure Table Storage for persistent data storage during runtime, Azure Blob Storage for maintaining workflow run histories, and Azure Queue Storage for scheduling purposes. For example, a single storage account enables handling a substantial number of requests with rates of up to 2,000 requests per partition and 20,000 requests per second at the storage account level. While a single storage account can handle reasonably high throughput, beyond these thresholds, request rates are subject to throttling, and your workflows might experience partition level throttling or account level throttling as workflow execution rate increases. To make sure that your workflows operate smoothly, it's crucial that you understand the possible limitations and the ways that you can address them.
For more information about scaling targets and limitations for the various Azure Storage services, see the following documentation:
Scale targets for Table Storage
Data operation targets for Table Storage
Scale targets for Blob Storage
Scale targets for Queue Storage
The following recommendations apply to scaling Standard logic app workflows:
Share workload across multiple workflows.Single-tenant Azure Logic Apps already minimizes partition-level throttling by distributing storage transactions across multiple partitions. However, to improve distribution and mitigate partition-level throttling,distribute the workload across multiple workflows, rather than rely on a single workflow.
Share workload across multiple workflows.
Single-tenant Azure Logic Apps already minimizes partition-level throttling by distributing storage transactions across multiple partitions. However, to improve distribution and mitigate partition-level throttling,distribute the workload across multiple workflows, rather than rely on a single workflow.
Share workload across multiple storage accounts.If your workflows require high throughput, you can significantly increase throughput by distributing the workload across multiple storage accounts, rather than rely on a single storage account. You can set up your Standard logic app resource to use up to 32 storage accounts as the limit. To determine the number of storage accounts that you need, use the general guideline of aiming for ~100,000 action executions per minute, per storage account. While this estimate works well for most scenarios, you might use a lower number of action executions if your workflow actions are compute heavy, for example, a query action that processes large data arrays. Make sure that you perform load testing and tune your solution before using in production.To enable using multiple storage accounts, follow these steps before you create your Standard logic app. Otherwise, if you change the settings after creation, you might experience data loss or not achieve the necessary scalability.Create the storage accountsthat you want to use. Save the connection string for each storage account.Find and open your Standard logic app, and thenedit your logic app's host settings (host.jsonfile)to include the followingextensionsobject, which contains theworkflowandsettingsobjects with theRuntime.ScaleUnitsCountsetting:"extensions": {
    "workflow": {
        "settings": {
            "Runtime.ScaleUnitsCount": "<storage-accounts-number>"
        }
    }
}The following example specifies3as the number of storage accounts:{
    "version": "2.0",
    "extensionBundle": {
        "id": "Microsoft.Azure.Functions.ExtensionBundle.Workflows",
        "version": "[1.*, 2.0.0)"
    },
    "extensions": {
        "workflow": {
            "settings": {
                "Runtime.ScaleUnitsCount": "3"
            }
        }
    }
}Edit your logic app's application configuration settings (local.settings.json)to add an app setting namedCloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU0<storage-account-number>.ConnectionStringand the corresponding storage account connection string using the following syntax where the first storage account number is00up to the number of storage accounts minus 1, for example:App setting nameValueCloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU00.ConnectionString<connection-string-1>CloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU01.ConnectionString<connection-string-2>CloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU02.ConnectionString<connection-string-3>ImportantWhen you have sensitive information, such as connection strings that include usernames and passwords,
make sure to use the most secure authentication flow available. For example, in Standard logic app workflows,
secure data types, such assecurestringandsecureobject, aren't supported. Microsoft recommends that you
authenticate access to Azure resources with amanaged identitywhen possible, and assign a role that has the least privilege necessary.If this capability is unavailable, make sure to secure connection strings through other measures, such asAzure Key Vault, which you can use withapp settings.
You can thendirectly reference secure strings, such as connection
strings and keys. Similar to ARM templates, where you can define environment variables at deployment time, you can define
app settings within yourlogic app workflow definition.
You can then capture dynamically generated infrastructure values, such as connection endpoints, storage strings, and more.
For more information, seeApplication types for the Microsoft identity platform.In your logic app's application configuration settings, update theAzureWebJobsStoragesetting value with the same connection string that's in theCloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU00.ConnectionStringsetting.
Share workload across multiple storage accounts.
If your workflows require high throughput, you can significantly increase throughput by distributing the workload across multiple storage accounts, rather than rely on a single storage account. You can set up your Standard logic app resource to use up to 32 storage accounts as the limit. To determine the number of storage accounts that you need, use the general guideline of aiming for ~100,000 action executions per minute, per storage account. While this estimate works well for most scenarios, you might use a lower number of action executions if your workflow actions are compute heavy, for example, a query action that processes large data arrays. Make sure that you perform load testing and tune your solution before using in production.
To enable using multiple storage accounts, follow these steps before you create your Standard logic app. Otherwise, if you change the settings after creation, you might experience data loss or not achieve the necessary scalability.
Create the storage accountsthat you want to use. Save the connection string for each storage account.
Create the storage accountsthat you want to use. Save the connection string for each storage account.
Find and open your Standard logic app, and thenedit your logic app's host settings (host.jsonfile)to include the followingextensionsobject, which contains theworkflowandsettingsobjects with theRuntime.ScaleUnitsCountsetting:"extensions": {
    "workflow": {
        "settings": {
            "Runtime.ScaleUnitsCount": "<storage-accounts-number>"
        }
    }
}The following example specifies3as the number of storage accounts:{
    "version": "2.0",
    "extensionBundle": {
        "id": "Microsoft.Azure.Functions.ExtensionBundle.Workflows",
        "version": "[1.*, 2.0.0)"
    },
    "extensions": {
        "workflow": {
            "settings": {
                "Runtime.ScaleUnitsCount": "3"
            }
        }
    }
}
Find and open your Standard logic app, and thenedit your logic app's host settings (host.jsonfile)to include the followingextensionsobject, which contains theworkflowandsettingsobjects with theRuntime.ScaleUnitsCountsetting:
extensions
workflow
settings
"extensions": {
    "workflow": {
        "settings": {
            "Runtime.ScaleUnitsCount": "<storage-accounts-number>"
        }
    }
}
"extensions": {
    "workflow": {
        "settings": {
            "Runtime.ScaleUnitsCount": "<storage-accounts-number>"
        }
    }
}
The following example specifies3as the number of storage accounts:
{
    "version": "2.0",
    "extensionBundle": {
        "id": "Microsoft.Azure.Functions.ExtensionBundle.Workflows",
        "version": "[1.*, 2.0.0)"
    },
    "extensions": {
        "workflow": {
            "settings": {
                "Runtime.ScaleUnitsCount": "3"
            }
        }
    }
}
{
    "version": "2.0",
    "extensionBundle": {
        "id": "Microsoft.Azure.Functions.ExtensionBundle.Workflows",
        "version": "[1.*, 2.0.0)"
    },
    "extensions": {
        "workflow": {
            "settings": {
                "Runtime.ScaleUnitsCount": "3"
            }
        }
    }
}
Edit your logic app's application configuration settings (local.settings.json)to add an app setting namedCloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU0<storage-account-number>.ConnectionStringand the corresponding storage account connection string using the following syntax where the first storage account number is00up to the number of storage accounts minus 1, for example:App setting nameValueCloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU00.ConnectionString<connection-string-1>CloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU01.ConnectionString<connection-string-2>CloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU02.ConnectionString<connection-string-3>ImportantWhen you have sensitive information, such as connection strings that include usernames and passwords,
make sure to use the most secure authentication flow available. For example, in Standard logic app workflows,
secure data types, such assecurestringandsecureobject, aren't supported. Microsoft recommends that you
authenticate access to Azure resources with amanaged identitywhen possible, and assign a role that has the least privilege necessary.If this capability is unavailable, make sure to secure connection strings through other measures, such asAzure Key Vault, which you can use withapp settings.
You can thendirectly reference secure strings, such as connection
strings and keys. Similar to ARM templates, where you can define environment variables at deployment time, you can define
app settings within yourlogic app workflow definition.
You can then capture dynamically generated infrastructure values, such as connection endpoints, storage strings, and more.
For more information, seeApplication types for the Microsoft identity platform.
Edit your logic app's application configuration settings (local.settings.json)to add an app setting namedCloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU0<storage-account-number>.ConnectionStringand the corresponding storage account connection string using the following syntax where the first storage account number is00up to the number of storage accounts minus 1, for example:
00
<connection-string-1>
<connection-string-2>
<connection-string-3>
Important
When you have sensitive information, such as connection strings that include usernames and passwords,
make sure to use the most secure authentication flow available. For example, in Standard logic app workflows,
secure data types, such assecurestringandsecureobject, aren't supported. Microsoft recommends that you
authenticate access to Azure resources with amanaged identitywhen possible, and assign a role that has the least privilege necessary.
securestring
secureobject
If this capability is unavailable, make sure to secure connection strings through other measures, such asAzure Key Vault, which you can use withapp settings.
You can thendirectly reference secure strings, such as connection
strings and keys. Similar to ARM templates, where you can define environment variables at deployment time, you can define
app settings within yourlogic app workflow definition.
You can then capture dynamically generated infrastructure values, such as connection endpoints, storage strings, and more.
For more information, seeApplication types for the Microsoft identity platform.
In your logic app's application configuration settings, update theAzureWebJobsStoragesetting value with the same connection string that's in theCloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU00.ConnectionStringsetting.
In your logic app's application configuration settings, update theAzureWebJobsStoragesetting value with the same connection string that's in theCloudStorageAccount.Workflows.ScaleUnitsDataStorage.CU00.ConnectionStringsetting.
A Standard logic app runs by using one of theavailable compute plans, which provide different levels of virtual CPU and memory, or by using an App Service Environment v3, which provides more compute options.
Single-tenant Azure Logic Apps dynamically scales to effectively handle increasing loads. Your logic app uses the following primary factors to determine whether to scale.
Note
For a Standard logic app in an App Service Environment v3, dynamic scaling isn't available.
You must set scaling rules on the associated App Service Plan. As a commonly used scaling rule,
you can use the CPU metric, and scale your App Service Plan to keep the virtual CPU between 50-70%.
For more information, seeGet started with autoscale in Azure.
TriggerTo determine scaling requirements, the scaler analyzes the trigger that starts each workflow in your logic app. For example, for a workflow with a Service Bus trigger, if the queue length continuously grows, the scaler takes action to add worker instances, which enable processing more messages. Likewise, for a workflow with a Request trigger, if the request latency experiences an upward trend, the scaler increases the number of worker instances to distribute the request load more efficiently. For more information about worker instances, seeAzure Logic Apps (Standard) - Runtime Deep Dive.
Trigger
To determine scaling requirements, the scaler analyzes the trigger that starts each workflow in your logic app. For example, for a workflow with a Service Bus trigger, if the queue length continuously grows, the scaler takes action to add worker instances, which enable processing more messages. Likewise, for a workflow with a Request trigger, if the request latency experiences an upward trend, the scaler increases the number of worker instances to distribute the request load more efficiently. For more information about worker instances, seeAzure Logic Apps (Standard) - Runtime Deep Dive.
Workflow job execution delayAt runtime, workflow actions are divided into individual jobs that are queued for execution. Job dispatchers regularly poll the job queue to retrieve and execute these jobs. However, if compute capacity is insufficient to pick up these jobs, they stay in the queue for a longer time, resulting in increased execution delays. The scaler monitors this situation and make scaling decisions to keep the execution delays under control. For more information about how the runtime schedules and runs jobs, seeAzure Logic Apps (Standard) - Runtime Deep Dive.The scaler also considers the minimum and maximum worker instance counter configuration to determine whether to make scaling decisions, such as adding, removing, or maintaining the current number of worker instances. Typically, the scaler makes these decisions at intervals of approximately 15-30 seconds. So, consider this ramp-up time and its impact on your logic app's scaling speed to effectively handle peak loads. For example, if your workload requires scaling your logic app from just 1 worker instance to 100 worker instances, the ramp-up alone might take 25-50 minutes. Single-tenant Azure Logic Apps scaling shares the sameAzure Functions scaling infrastructure.
Workflow job execution delay
At runtime, workflow actions are divided into individual jobs that are queued for execution. Job dispatchers regularly poll the job queue to retrieve and execute these jobs. However, if compute capacity is insufficient to pick up these jobs, they stay in the queue for a longer time, resulting in increased execution delays. The scaler monitors this situation and make scaling decisions to keep the execution delays under control. For more information about how the runtime schedules and runs jobs, seeAzure Logic Apps (Standard) - Runtime Deep Dive.
The scaler also considers the minimum and maximum worker instance counter configuration to determine whether to make scaling decisions, such as adding, removing, or maintaining the current number of worker instances. Typically, the scaler makes these decisions at intervals of approximately 15-30 seconds. So, consider this ramp-up time and its impact on your logic app's scaling speed to effectively handle peak loads. For example, if your workload requires scaling your logic app from just 1 worker instance to 100 worker instances, the ramp-up alone might take 25-50 minutes. Single-tenant Azure Logic Apps scaling shares the sameAzure Functions scaling infrastructure.
Share workload across multiple logic apps.Each logic app can scale independently, so distributing your workload across more than one logic app can significantly accelerate the scaling speed. For example, two logic apps can scale to twice the number of worker instances in the same timeframe as a single logic app. By splitting your workload across multiple apps, you can effectively multiply the scalability and achieve faster scaling results.
Share workload across multiple logic apps.
Each logic app can scale independently, so distributing your workload across more than one logic app can significantly accelerate the scaling speed. For example, two logic apps can scale to twice the number of worker instances in the same timeframe as a single logic app. By splitting your workload across multiple apps, you can effectively multiply the scalability and achieve faster scaling results.
Use prewarmed instances.If your scenario requires quicker ramp-up time, consider using prewarmed instances. If your peak load times are deterministic, you can use an automation task to adjust these prewarm instances on a schedule. For more information, seeManage Azure resources and monitor costs by creating automation tasks (preview).
Use prewarmed instances.
If your scenario requires quicker ramp-up time, consider using prewarmed instances. If your peak load times are deterministic, you can use an automation task to adjust these prewarm instances on a schedule. For more information, seeManage Azure resources and monitor costs by creating automation tasks (preview).
Multitenant Azure Logic Apps has adefault limiton the number of actions that run every 5 minutes. To raise the default value to themaximum value, you can enable high throughput mode, which is in preview. Or,distribute the workload across multiple logic apps and workflows, rather than rely on a single logic app and workflow.
In the Azure portal, on your logic app's menu, underSettings, selectWorkflow settings.
In the Azure portal, on your logic app's menu, underSettings, selectWorkflow settings.
UnderRuntime options>High throughput, change the setting toOn.
UnderRuntime options>High throughput, change the setting toOn.

To enable this setting in an ARM template for deploying your logic app, in thepropertiesobject for your logic app's resource definition, add theruntimeConfigurationobject with theoperationOptionsproperty set toOptimizedForHighThroughput:
properties
runtimeConfiguration
operationOptions
OptimizedForHighThroughput
{
   <template-properties>
   "resources": [
      // Start logic app resource definition
      {
         "properties": {
            <logic-app-resource-definition-properties>,
            <logic-app-workflow-definition>,
            <more-logic-app-resource-definition-properties>,
            "runtimeConfiguration": {
               "operationOptions": "OptimizedForHighThroughput"
            }
         },
         "name": "[parameters('LogicAppName')]",
         "type": "Microsoft.Logic/workflows",
         "location": "[parameters('LogicAppLocation')]",
         "tags": {},
         "apiVersion": "2016-06-01",
         "dependsOn": [
         ]
      }
      // End logic app resource definition
   ],
   "outputs": {}
}
{
   <template-properties>
   "resources": [
      // Start logic app resource definition
      {
         "properties": {
            <logic-app-resource-definition-properties>,
            <logic-app-workflow-definition>,
            <more-logic-app-resource-definition-properties>,
            "runtimeConfiguration": {
               "operationOptions": "OptimizedForHighThroughput"
            }
         },
         "name": "[parameters('LogicAppName')]",
         "type": "Microsoft.Logic/workflows",
         "location": "[parameters('LogicAppLocation')]",
         "tags": {},
         "apiVersion": "2016-06-01",
         "dependsOn": [
         ]
      }
      // End logic app resource definition
   ],
   "outputs": {}
}
For more information about your logic app resource definition, reviewOverview: Automate deployment for Azure Logic Apps by using Azure Resource Manager templates.

Data gateway limits
Azure Logic Apps supports write operations, including inserts and updates, through the on-premises data gateway. However, these operations havelimits on their payload size.

Retry policy limits
The following table lists the retry policy limits for a trigger or action, based on whether you have aConsumption or Standard logic app workflow.

Variables action limits
The following table lists the values for a single workflow definition:

HTTP request limits
The following tables list the values for a single inbound or outbound call:

Time-out duration
By default, the HTTP action and API connection actions follow thestandard asynchronous operation pattern, while the Response action follows thesynchronous operation pattern. Some managed connector operations make asynchronous calls or listen for webhook requests, so the time-out for these operations might be longer than the following limits. For more information, revieweach connector's technical reference pageand also theWorkflow triggers and actionsdocumentation.
Note
For a Standard logic app resource in single-tenant Azure Logic Apps, stateless workflows can only runsynchronously.

Request trigger and webhook trigger size limits

Messages
Character limits
@concat()
@base64()
@string()

Authentication limits
The following table lists the values for a workflow that starts with a Request trigger and enablesMicrosoft Entra ID Open Authentication(Microsoft Entra ID OAuth) for authorizing inbound calls to the Request trigger:

Switch action limits
The following table lists the values for a single workflow definition:

Inline Code action limits
The following table lists the values for a single workflow definition:

Custom connector limits
In multitenant Azure Logic Apps only, you can create and usecustom managed connectors, which are wrappers around an existing REST API or SOAP API. In single-tenant Azure Logic Apps, you can create and use onlycustom built-in connectors.
The following table lists the values for custom connectors:
For more information, review the following documentation:
Custom managed connectors overview
Enable built-in connector authoring - Visual Studio Code with Azure Logic Apps (Standard) extension

Managed identity limits

Integration account limits
Each Azure subscription has these integration account limits:
OneFree tierintegration account per Azure region. This tier is available only for public regions in Azure, for example, West US or Southeast Asia, but not forMicrosoft Azure operated by 21VianetorAzure Government.
OneFree tierintegration account per Azure region. This tier is available only for public regions in Azure, for example, West US or Southeast Asia, but not forMicrosoft Azure operated by 21VianetorAzure Government.
1,000 total integration accounts
1,000 total integration accounts
To learn how pricing and billing work, see theLogic Apps pricing model. For pricing rates, seeLogic Apps pricing.

Artifact limits per integration account
The following tables list the values for the number of artifacts limited to each integration account tier. For pricing rates, seeLogic Apps pricing. To learn how pricing and billing work for integration accounts, see theLogic Apps pricing model.
Note
Use the Free tier only for exploratory scenarios, not production scenarios.
This tier restricts throughput and usage, and has no service-level agreement (SLA).

Artifact capacity limits

Throughput limits

B2B protocol (AS2, X12, EDIFACT) message size
The following table lists the message size limits that apply to B2B protocols:

Firewall configuration: IP addresses and service tags
If your environment has strict network requirements and uses a firewall that limits traffic to specific IP addresses, your environment or firewall needs to permit inbound traffic sent to multitenant Azure Logic Apps from outside and outbound traffic sent from Azure Logic Apps to the outside. To set up this access, you can createAzure Firewall rulesthat allow access for theinboundandoutboundIP addresses required by Azure Logic Apps in the Azure region for your logic app resource.Alllogic apps in the same region use the same IP addresses.
Note
If you usePower Automate, some actions such asHTTPandHTTP + OpenAPIcommunicate directly through the Azure Logic Apps platform using some of the IP addresses listed here. For more information
about the IP addresses used by Power Automate, seeLimits and configuration for Power Automate.
For example, suppose you have logic apps in the West US region. To support the calls that your logic app workflows send or receive using built-in operations such as theHTTP trigger or action, your firewall must allow access for all the inbound and outbound IP addresses for the West US region.

Firewall IP configuration considerations
Before you set up your firewall with IP addresses, review these considerations:
To simplify any security rules that you create, useservice tags, rather than specific IP addresses. These tags represent a group of IP address prefixes from a specific Azure service and work across the regions where the Azure Logic Apps service is available:Service tagDescriptionLogicAppsManagementInbound IP address prefixes for the Azure Logic Apps service.LogicAppsOutbound IP address prefixes for the Azure Logic Apps service.AzureConnectorsIP address prefixes required for managed connectors that make inbound webhook callbacks to the Azure Logic Apps service and outbound calls to their respective services, such as Azure Blob Storage or Azure Event Hubs. This tag and its IP addresses also apply to any customer connector operations in your workflows.
To simplify any security rules that you create, useservice tags, rather than specific IP addresses. These tags represent a group of IP address prefixes from a specific Azure service and work across the regions where the Azure Logic Apps service is available:
For Standard logic app workflows in single-tenant Azure Logic Apps, you must allow access for any trigger or action connections in your workflows. To allow traffic, useservice tagsand the same level of restrictions or policies as Azure App Service. You must also find and use the fully qualified domain names (FQDNs) for your connections. For more information, see the corresponding sections in the following documentation:Firewall permissions for Standard workflows - Azure portalFirewall permissions for Standard workflows - Visual Studio Code
For Standard logic app workflows in single-tenant Azure Logic Apps, you must allow access for any trigger or action connections in your workflows. To allow traffic, useservice tagsand the same level of restrictions or policies as Azure App Service. You must also find and use the fully qualified domain names (FQDNs) for your connections. For more information, see the corresponding sections in the following documentation:
Firewall permissions for Standard workflows - Azure portal
Firewall permissions for Standard workflows - Visual Studio Code
If your logic app workflows have problems accessing Azure storage accounts that usefirewalls and firewall rules, you have otheroptions to enable access.For example, workflows can't directly access storage accounts that use firewall rules and exist in the same region. However, after you allow traffic through theoutbound IP addresses for managed connectors in your Azure region, your workflows can access storage accounts that exist in a different region, except when they use the Azure Table Storage or Azure Queue Storage connectors. To access Table Storage or Queue Storage, use theHTTP trigger and actions. For other options, seeAccess storage accounts behind firewalls.
If your logic app workflows have problems accessing Azure storage accounts that usefirewalls and firewall rules, you have otheroptions to enable access.
For example, workflows can't directly access storage accounts that use firewall rules and exist in the same region. However, after you allow traffic through theoutbound IP addresses for managed connectors in your Azure region, your workflows can access storage accounts that exist in a different region, except when they use the Azure Table Storage or Azure Queue Storage connectors. To access Table Storage or Queue Storage, use theHTTP trigger and actions. For other options, seeAccess storage accounts behind firewalls.

Inbound IP addresses
For Azure Logic Apps to receive communication through your firewall from external services, you have to allow traffic throughall the inbound IP addressesset aside for the Azure region where your logic app resources exists.
To reduce complexity when you create security rules, use theLogicAppsManagementservice tag, rather than specific inbound IP addresses. Service tags include static IP addresses, so if you can't use service tags, add all the IP addresses covered by the service tag instead. For more information, downloadAzure IP Ranges and Service Tags for Public Cloud.
Otherwise, see the section namedMultitenant - Inbound IP addresses. If you're using Azure Government, seeAzure Government - Inbound IP addresses.
Note
Some managed connector operations make inbound webhook callbacks to Azure Logic Apps.
If you use access control on the logic app resource, make sure that the calls from
the IP addresses for these services or systems have permissions to access your logic app.
The following connector operations make inbound webhook callbacks to Azure Logic Apps:
Adobe Creative Cloud, Adobe Sign, Adobe Sign Demo, Adobe Sign Preview, Adobe Sign Stage,
Azure Event Grid, Calendly, DocuSign, DocuSign Demo, LiveChat, Microsoft Dataverse
(Common Data Service), Microsoft Forms, Microsoft Dynamics 365 Business Central, Microsoft
Dynamics 365 for Fin & Ops, Microsoft Office 365* Outlook, Microsoft Outlook.com, Microsoft
Sentinel, Parserr, SAP*, Shifts for Microsoft Teams, Teamwork Projects, Typeform, and so on:
Office 365: The return caller is actually the Office 365 connector. You can specify the
managed connector outbound IP address for each region, or use theAzureConnectorsservice
tag for these managed connectors.
Office 365: The return caller is actually the Office 365 connector. You can specify the
managed connector outbound IP address for each region, or use theAzureConnectorsservice
tag for these managed connectors.
SAP: The return caller depends on whether the deployment environment is multitenant Azure.
In the multitenant, the on-premises data gateway makes the callback to the Azure Logic Apps service.
SAP: The return caller depends on whether the deployment environment is multitenant Azure.
In the multitenant, the on-premises data gateway makes the callback to the Azure Logic Apps service.

This section lists the inbound IP addresses that Azure Logic Apps requires for the Azure region where a logic app exists to receive communication through your firewall. Make sure that you review theInbound IP addresses introductionfor all the requirements related to allowing inbound traffic into Azure Logic Apps.


Outbound IP addresses
For Azure Logic Apps to send communication through your firewall, you have to allow traffic throughall the outbound IP addressesset aside for the Azure region where your logic app resource exists.
To reduce complexity when you create security rules, use theLogicAppsservice tag, rather than specific outbound IP addresses. If your workflow uses anymanaged connector operationsorcustom connectors, use theAzureConnectorsservice tag so that these connectors can make outbound calls to their respective services, such as Office 365 Outlook, or SQL Server. Both these tags work across the Azure regions where Azure Logic Apps is available. Service tags include static IP addresses, so if you can't use service tags, addall the outbound IP addressescovered by the service tags for your Azure region. For more information, downloadAzure IP Ranges and Service Tags for Public Cloud.
For custom connectors that access on-premises resources through theon-premises data gateway resource in Azure, you must set up the gateway installation to allow access for the correspondingmanagedconnector outbound IP addresses.
For more information about setting up communication settings on the gateway, see the following documentation:
Adjust communication settings for the on-premises data gateway
Configure proxy settings for the on-premises data gateway
Otherwise, see the following sections, which list the outbound IP addresses that you need to add:
Multitenant - Outbound IP addresses
Managed connector outbound IP addresses
If you're using Azure Government, seeAzure Government - Outbound IP addresses.

This section lists the outbound IP addresses that Azure Logic Apps requires for the Azure region where a logic app resource exists to send communication through your firewall. Make sure that you review theOutbound IP addresses introductionfor all the requirements related to allowing outbound traffic from Azure Logic Apps.

Related content
Create an example Consumption logic app workflow in multitenant Azure Logic Apps
Create an example Standard logic app workflow in single-tenant Azure Logic Apps
Feedback
Was this page helpful?
Additional resources