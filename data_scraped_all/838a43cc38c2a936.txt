Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Azure Service Bus trigger for Azure Functions
Article
2023-10-16
24 contributors
In this article
Use the Service Bus trigger to respond to messages from a Service Bus queue or topic.
Starting with extension version 3.1.0, you can trigger on a session-enabled queue or topic.
For information on setup and configuration details, see theoverview.
Service Bus scaling decisions for the Consumption and Premium plans are made based on target-based scaling. For more information, seeTarget-based scaling.
Important
This article uses tabs to support multiple versions of the Node.js programming model. The v4 model is generally available and is designed to have a more flexible and intuitive experience for JavaScript and TypeScript developers. For more details about how the v4 model works, refer to theAzure Functions Node.js developer guide. To learn more about the differences between v3 and v4, refer to themigration guide.
Azure Functions supports two programming models for Python. The way that you define your bindings depends on your chosen programming model.
v2
v1
The Python v2 programming model lets you define bindings using decorators directly in your Python function code. For more information, see thePython developer guide.
The Python v1 programming model requires you to define bindings in a separatefunction.jsonfile in the function folder. For more information, see thePython developer guide.
This article supports both programming models.
Example
A C# function can be created by using one of the following C# modes:
Isolated worker model: Compiled C# function that runs in a worker process that's isolated from the runtime. Isolated worker process is required to support C# functions running on LTS and non-LTS versions .NET and the .NET Framework. Extensions for isolated worker process functions useMicrosoft.Azure.Functions.Worker.Extensions.*namespaces.
Microsoft.Azure.Functions.Worker.Extensions.*
In-process model: Compiled C# function that runs in the same process as the Functions runtime. In a variation of this model, Functions can be run usingC# scripting, which is supported primarily for C# portal editing. Extensions for in-process functions useMicrosoft.Azure.WebJobs.Extensions.*namespaces.
Microsoft.Azure.WebJobs.Extensions.*
Important
Support will end for the in-process model on November 10, 2026. We highly recommend that youmigrate your apps to the isolated worker modelfor full support.
Isolated worker model
In-process model
This code defines and initializes theILogger:
ILogger
private readonly ILogger<ServiceBusReceivedMessageFunctions> _logger;

public ServiceBusReceivedMessageFunctions(ILogger<ServiceBusReceivedMessageFunctions> logger)
{
    _logger = logger;
}
private readonly ILogger<ServiceBusReceivedMessageFunctions> _logger;

public ServiceBusReceivedMessageFunctions(ILogger<ServiceBusReceivedMessageFunctions> logger)
{
    _logger = logger;
}
This example shows aC# functionthat receives a single Service Bus queue message and writes it to the logs:
[Function(nameof(ServiceBusReceivedMessageFunction))]
[ServiceBusOutput("outputQueue", Connection = "ServiceBusConnection")]
public string ServiceBusReceivedMessageFunction(
    [ServiceBusTrigger("queue", Connection = "ServiceBusConnection")] ServiceBusReceivedMessage message)
{
    _logger.LogInformation("Message ID: {id}", message.MessageId);
    _logger.LogInformation("Message Body: {body}", message.Body);
    _logger.LogInformation("Message Content-Type: {contentType}", message.ContentType);

    var outputMessage = $"Output message created at {DateTime.Now}";
    return outputMessage;
}
[Function(nameof(ServiceBusReceivedMessageFunction))]
[ServiceBusOutput("outputQueue", Connection = "ServiceBusConnection")]
public string ServiceBusReceivedMessageFunction(
    [ServiceBusTrigger("queue", Connection = "ServiceBusConnection")] ServiceBusReceivedMessage message)
{
    _logger.LogInformation("Message ID: {id}", message.MessageId);
    _logger.LogInformation("Message Body: {body}", message.Body);
    _logger.LogInformation("Message Content-Type: {contentType}", message.ContentType);

    var outputMessage = $"Output message created at {DateTime.Now}";
    return outputMessage;
}
This example shows aC# functionthat receives multiple Service Bus queue messages in a single batch and writes each to the logs:
[Function(nameof(ServiceBusReceivedMessageBatchFunction))]
public void ServiceBusReceivedMessageBatchFunction(
    [ServiceBusTrigger("queue", Connection = "ServiceBusConnection", IsBatched = true)] ServiceBusReceivedMessage[] messages)
{
    foreach (ServiceBusReceivedMessage message in messages)
    {
        _logger.LogInformation("Message ID: {id}", message.MessageId);
        _logger.LogInformation("Message Body: {body}", message.Body);
        _logger.LogInformation("Message Content-Type: {contentType}", message.ContentType);
    }
}
[Function(nameof(ServiceBusReceivedMessageBatchFunction))]
public void ServiceBusReceivedMessageBatchFunction(
    [ServiceBusTrigger("queue", Connection = "ServiceBusConnection", IsBatched = true)] ServiceBusReceivedMessage[] messages)
{
    foreach (ServiceBusReceivedMessage message in messages)
    {
        _logger.LogInformation("Message ID: {id}", message.MessageId);
        _logger.LogInformation("Message Body: {body}", message.Body);
        _logger.LogInformation("Message Content-Type: {contentType}", message.ContentType);
    }
}
This example shows aC# functionthat receives multiple Service Bus queue messages, writes it to the logs, and then settles the message as completed:
[Function(nameof(ServiceBusMessageActionsFunction))]
public async Task ServiceBusMessageActionsFunction(
    [ServiceBusTrigger("queue", Connection = "ServiceBusConnection", AutoCompleteMessages = false)]
    ServiceBusReceivedMessage message,
    ServiceBusMessageActions messageActions)
{
    _logger.LogInformation("Message ID: {id}", message.MessageId);
    _logger.LogInformation("Message Body: {body}", message.Body);
    _logger.LogInformation("Message Content-Type: {contentType}", message.ContentType);

    // Complete the message
    await messageActions.CompleteMessageAsync(message);
}
[Function(nameof(ServiceBusMessageActionsFunction))]
public async Task ServiceBusMessageActionsFunction(
    [ServiceBusTrigger("queue", Connection = "ServiceBusConnection", AutoCompleteMessages = false)]
    ServiceBusReceivedMessage message,
    ServiceBusMessageActions messageActions)
{
    _logger.LogInformation("Message ID: {id}", message.MessageId);
    _logger.LogInformation("Message Body: {body}", message.Body);
    _logger.LogInformation("Message Content-Type: {contentType}", message.ContentType);

    // Complete the message
    await messageActions.CompleteMessageAsync(message);
}
The following example shows aC# functionthat readsmessage metadataand
logs a Service Bus queue message:
[FunctionName("ServiceBusQueueTriggerCSharp")]                    
public static void Run(
    [ServiceBusTrigger("myqueue", Connection = "ServiceBusConnection")] 
    string myQueueItem,
    Int32 deliveryCount,
    DateTime enqueuedTimeUtc,
    string messageId,
    ILogger log)
{
    log.LogInformation($"C# ServiceBus queue trigger function processed message: {myQueueItem}");
    log.LogInformation($"EnqueuedTimeUtc={enqueuedTimeUtc}");
    log.LogInformation($"DeliveryCount={deliveryCount}");
    log.LogInformation($"MessageId={messageId}");
}
[FunctionName("ServiceBusQueueTriggerCSharp")]                    
public static void Run(
    [ServiceBusTrigger("myqueue", Connection = "ServiceBusConnection")] 
    string myQueueItem,
    Int32 deliveryCount,
    DateTime enqueuedTimeUtc,
    string messageId,
    ILogger log)
{
    log.LogInformation($"C# ServiceBus queue trigger function processed message: {myQueueItem}");
    log.LogInformation($"EnqueuedTimeUtc={enqueuedTimeUtc}");
    log.LogInformation($"DeliveryCount={deliveryCount}");
    log.LogInformation($"MessageId={messageId}");
}
The following Java function uses the@ServiceBusQueueTriggerannotation from theJava functions runtime libraryto describe the configuration for a Service Bus queue trigger. The  function grabs the message placed on the queue and adds it to the logs.
@ServiceBusQueueTrigger
@FunctionName("sbprocessor")
 public void serviceBusProcess(
    @ServiceBusQueueTrigger(name = "msg",
                             queueName = "myqueuename",
                             connection = "myconnvarname") String message,
   final ExecutionContext context
 ) {
     context.getLogger().info(message);
 }
@FunctionName("sbprocessor")
 public void serviceBusProcess(
    @ServiceBusQueueTrigger(name = "msg",
                             queueName = "myqueuename",
                             connection = "myconnvarname") String message,
   final ExecutionContext context
 ) {
     context.getLogger().info(message);
 }
Java functions can also be triggered when a message is added to a Service Bus topic. The following example uses the@ServiceBusTopicTriggerannotation to describe the trigger configuration.
@ServiceBusTopicTrigger
@FunctionName("sbtopicprocessor")
    public void run(
        @ServiceBusTopicTrigger(
            name = "message",
            topicName = "mytopicname",
            subscriptionName = "mysubscription",
            connection = "ServiceBusConnection"
        ) String message,
        final ExecutionContext context
    ) {
        context.getLogger().info(message);
    }
@FunctionName("sbtopicprocessor")
    public void run(
        @ServiceBusTopicTrigger(
            name = "message",
            topicName = "mytopicname",
            subscriptionName = "mysubscription",
            connection = "ServiceBusConnection"
        ) String message,
        final ExecutionContext context
    ) {
        context.getLogger().info(message);
    }
Model v4
Model v3
The following example shows a Service Bus triggerTypeScript function. The function readsmessage metadataand logs a Service Bus queue message.
import { app, InvocationContext } from '@azure/functions';

export async function serviceBusQueueTrigger1(message: unknown, context: InvocationContext): Promise<void> {
    context.log('Service bus queue function processed message:', message);
    context.log('EnqueuedTimeUtc =', context.triggerMetadata.enqueuedTimeUtc);
    context.log('DeliveryCount =', context.triggerMetadata.deliveryCount);
    context.log('MessageId =', context.triggerMetadata.messageId);
}

app.serviceBusQueue('serviceBusQueueTrigger1', {
    connection: 'MyServiceBusConnection',
    queueName: 'testqueue',
    handler: serviceBusQueueTrigger1,
});
import { app, InvocationContext } from '@azure/functions';

export async function serviceBusQueueTrigger1(message: unknown, context: InvocationContext): Promise<void> {
    context.log('Service bus queue function processed message:', message);
    context.log('EnqueuedTimeUtc =', context.triggerMetadata.enqueuedTimeUtc);
    context.log('DeliveryCount =', context.triggerMetadata.deliveryCount);
    context.log('MessageId =', context.triggerMetadata.messageId);
}

app.serviceBusQueue('serviceBusQueueTrigger1', {
    connection: 'MyServiceBusConnection',
    queueName: 'testqueue',
    handler: serviceBusQueueTrigger1,
});
TypeScript samples are not documented for model v3.
Model v4
Model v3
The following example shows a Service Bus triggerJavaScript function. The function readsmessage metadataand logs a Service Bus queue message.
const { app } = require('@azure/functions');

app.serviceBusQueue('serviceBusQueueTrigger1', {
    connection: 'MyServiceBusConnection',
    queueName: 'testqueue',
    handler: (message, context) => {
        context.log('Service bus queue function processed message:', message);
        context.log('EnqueuedTimeUtc =', context.triggerMetadata.enqueuedTimeUtc);
        context.log('DeliveryCount =', context.triggerMetadata.deliveryCount);
        context.log('MessageId =', context.triggerMetadata.messageId);
    },
});
const { app } = require('@azure/functions');

app.serviceBusQueue('serviceBusQueueTrigger1', {
    connection: 'MyServiceBusConnection',
    queueName: 'testqueue',
    handler: (message, context) => {
        context.log('Service bus queue function processed message:', message);
        context.log('EnqueuedTimeUtc =', context.triggerMetadata.enqueuedTimeUtc);
        context.log('DeliveryCount =', context.triggerMetadata.deliveryCount);
        context.log('MessageId =', context.triggerMetadata.messageId);
    },
});
The following example shows a Service Bus trigger binding in afunction.jsonfile and aJavaScript functionthat uses the binding. The function readsmessage metadataand logs a Service Bus queue message.
Here's the binding data in thefunction.jsonfile:
{
"bindings": [
    {
    "queueName": "testqueue",
    "connection": "MyServiceBusConnection",
    "name": "myQueueItem",
    "type": "serviceBusTrigger",
    "direction": "in"
    }
],
"disabled": false
}
{
"bindings": [
    {
    "queueName": "testqueue",
    "connection": "MyServiceBusConnection",
    "name": "myQueueItem",
    "type": "serviceBusTrigger",
    "direction": "in"
    }
],
"disabled": false
}
Here's the JavaScript script code:
module.exports = async function(context, myQueueItem) {
    context.log('Node.js ServiceBus queue trigger function processed message', myQueueItem);
    context.log('EnqueuedTimeUtc =', context.bindingData.enqueuedTimeUtc);
    context.log('DeliveryCount =', context.bindingData.deliveryCount);
    context.log('MessageId =', context.bindingData.messageId);
};
module.exports = async function(context, myQueueItem) {
    context.log('Node.js ServiceBus queue trigger function processed message', myQueueItem);
    context.log('EnqueuedTimeUtc =', context.bindingData.enqueuedTimeUtc);
    context.log('DeliveryCount =', context.bindingData.deliveryCount);
    context.log('MessageId =', context.bindingData.messageId);
};
The following example shows a Service Bus trigger binding in afunction.jsonfile and aPowerShell functionthat uses the binding.
Here's the binding data in thefunction.jsonfile:
{
  "bindings": [
    {
      "name": "mySbMsg",
      "type": "serviceBusTrigger",
      "direction": "in",
      "topicName": "mytopic",
      "subscriptionName": "mysubscription",
      "connection": "AzureServiceBusConnectionString"
    }
  ]
}
{
  "bindings": [
    {
      "name": "mySbMsg",
      "type": "serviceBusTrigger",
      "direction": "in",
      "topicName": "mytopic",
      "subscriptionName": "mysubscription",
      "connection": "AzureServiceBusConnectionString"
    }
  ]
}
Here's the function that runs when a Service Bus message is sent.
param([string] $mySbMsg, $TriggerMetadata)

Write-Host "PowerShell ServiceBus queue trigger function processed message: $mySbMsg"
param([string] $mySbMsg, $TriggerMetadata)

Write-Host "PowerShell ServiceBus queue trigger function processed message: $mySbMsg"
The following example demonstrates how to read a Service Bus queue message via a trigger. The example depends on whether you use thev1 or v2 Python programming model.
v2
v1
import logging
import azure.functions as func

app = func.FunctionApp()

@app.function_name(name="ServiceBusQueueTrigger1")
@app.service_bus_queue_trigger(arg_name="msg", 
                               queue_name="<QUEUE_NAME>", 
                               connection="<CONNECTION_SETTING>")
def test_function(msg: func.ServiceBusMessage):
    logging.info('Python ServiceBus queue trigger processed message: %s',
                 msg.get_body().decode('utf-8'))
import logging
import azure.functions as func

app = func.FunctionApp()

@app.function_name(name="ServiceBusQueueTrigger1")
@app.service_bus_queue_trigger(arg_name="msg", 
                               queue_name="<QUEUE_NAME>", 
                               connection="<CONNECTION_SETTING>")
def test_function(msg: func.ServiceBusMessage):
    logging.info('Python ServiceBus queue trigger processed message: %s',
                 msg.get_body().decode('utf-8'))
A Service Bus binding is defined infunction.jsonwheretypeis set toserviceBusTriggerand the queue is set byqueueName.
serviceBusTrigger
queueName
{
  "scriptFile": "__init__.py",
  "bindings": [
    {
      "name": "msg",
      "type": "serviceBusTrigger",
      "direction": "in",
      "queueName": "inputqueue",
      "connection": "AzureServiceBusConnectionString"
    }
  ]
}
{
  "scriptFile": "__init__.py",
  "bindings": [
    {
      "name": "msg",
      "type": "serviceBusTrigger",
      "direction": "in",
      "queueName": "inputqueue",
      "connection": "AzureServiceBusConnectionString"
    }
  ]
}
The code in_init_.pydeclares a parameter asfunc.ServiceBusMessage, which allows you to read the queue message in your function.
func.ServiceBusMessage
import azure.functions as func

import logging
import json

def main(msg: func.ServiceBusMessage):
    logging.info('Python ServiceBus queue trigger processed message.')

    result = json.dumps({
        'message_id': msg.message_id,
        'body': msg.get_body().decode('utf-8'),
        'content_type': msg.content_type,
        'expiration_time': msg.expiration_time,
        'label': msg.label,
        'partition_key': msg.partition_key,
        'reply_to': msg.reply_to,
        'reply_to_session_id': msg.reply_to_session_id,
        'scheduled_enqueue_time': msg.scheduled_enqueue_time,
        'session_id': msg.session_id,
        'time_to_live': msg.time_to_live,
        'to': msg.to,
        'user_properties': msg.user_properties,
        'metadata' : msg.metadata
    }, default=str)

    logging.info(result)
import azure.functions as func

import logging
import json

def main(msg: func.ServiceBusMessage):
    logging.info('Python ServiceBus queue trigger processed message.')

    result = json.dumps({
        'message_id': msg.message_id,
        'body': msg.get_body().decode('utf-8'),
        'content_type': msg.content_type,
        'expiration_time': msg.expiration_time,
        'label': msg.label,
        'partition_key': msg.partition_key,
        'reply_to': msg.reply_to,
        'reply_to_session_id': msg.reply_to_session_id,
        'scheduled_enqueue_time': msg.scheduled_enqueue_time,
        'session_id': msg.session_id,
        'time_to_live': msg.time_to_live,
        'to': msg.to,
        'user_properties': msg.user_properties,
        'metadata' : msg.metadata
    }, default=str)

    logging.info(result)
The following example demonstrates how to read a Service Bus queue topic via a trigger.
v2
v1
import logging
import azure.functions as func

app = func.FunctionApp()

@app.function_name(name="ServiceBusTopicTrigger1")
@app.service_bus_topic_trigger(arg_name="message", 
                               topic_name="TOPIC_NAME", 
                               connection="CONNECTION_SETTING", 
                               subscription_name="SUBSCRIPTION_NAME")
def test_function(message: func.ServiceBusMessage):
    message_body = message.get_body().decode("utf-8")
    logging.info("Python ServiceBus topic trigger processed message.")
    logging.info("Message Body: " + message_body)
import logging
import azure.functions as func

app = func.FunctionApp()

@app.function_name(name="ServiceBusTopicTrigger1")
@app.service_bus_topic_trigger(arg_name="message", 
                               topic_name="TOPIC_NAME", 
                               connection="CONNECTION_SETTING", 
                               subscription_name="SUBSCRIPTION_NAME")
def test_function(message: func.ServiceBusMessage):
    message_body = message.get_body().decode("utf-8")
    logging.info("Python ServiceBus topic trigger processed message.")
    logging.info("Message Body: " + message_body)
A Service Bus binding is defined infunction.jsonwheretypeis set toserviceBusTriggerand the topic is set bytopicName.
serviceBusTrigger
topicName
{
  "scriptFile": "__init__.py",
  "bindings": [
   {
     "type": "serviceBusTrigger",
     "direction": "in",
     "name": "msg",
     "topicName": "inputtopic",
     "connection": "AzureServiceBusConnectionString"
   }
  ]
}
{
  "scriptFile": "__init__.py",
  "bindings": [
   {
     "type": "serviceBusTrigger",
     "direction": "in",
     "name": "msg",
     "topicName": "inputtopic",
     "connection": "AzureServiceBusConnectionString"
   }
  ]
}
The code in_init_.pydeclares a parameter asfunc.ServiceBusMessage, which allows you to read the topic in your function.
func.ServiceBusMessage
import json

import azure.functions as azf


def main(msg: azf.ServiceBusMessage) -> str:
    result = json.dumps({
        'message_id': msg.message_id,
        'body': msg.get_body().decode('utf-8'),
        'content_type': msg.content_type,
        'delivery_count': msg.delivery_count,
        'expiration_time': (msg.expiration_time.isoformat() if
                            msg.expiration_time else None),
        'label': msg.label,
        'partition_key': msg.partition_key,
        'reply_to': msg.reply_to,
        'reply_to_session_id': msg.reply_to_session_id,
        'scheduled_enqueue_time': (msg.scheduled_enqueue_time.isoformat() if
                                   msg.scheduled_enqueue_time else None),
        'session_id': msg.session_id,
        'time_to_live': msg.time_to_live,
        'to': msg.to,
        'user_properties': msg.user_properties,
    })

    logging.info(result)
import json

import azure.functions as azf


def main(msg: azf.ServiceBusMessage) -> str:
    result = json.dumps({
        'message_id': msg.message_id,
        'body': msg.get_body().decode('utf-8'),
        'content_type': msg.content_type,
        'delivery_count': msg.delivery_count,
        'expiration_time': (msg.expiration_time.isoformat() if
                            msg.expiration_time else None),
        'label': msg.label,
        'partition_key': msg.partition_key,
        'reply_to': msg.reply_to,
        'reply_to_session_id': msg.reply_to_session_id,
        'scheduled_enqueue_time': (msg.scheduled_enqueue_time.isoformat() if
                                   msg.scheduled_enqueue_time else None),
        'session_id': msg.session_id,
        'time_to_live': msg.time_to_live,
        'to': msg.to,
        'user_properties': msg.user_properties,
    })

    logging.info(result)
Attributes
Bothin-processandisolated worker processC# libraries use theServiceBusTriggerAttributeattribute to define the function trigger. C# script instead uses a function.json configuration file as described in theC# scripting guide.
Isolated worker model
In-process model
The following table explains the properties you can set using this trigger attribute:
true
false
true
false
autoCompleteMessages
host.json
The following table explains the properties you can set using this trigger attribute:
manage
listen
manage
connection
accessRights
true
false
true
true
false
ServiceBusReceiver
DeliveryCount
When you're developing locally, add your application settings in thelocal.settings.json filein theValuescollection.
Values
Decorators
Applies only to the Python v2 programming model.
For Python v2 functions defined using a decorator, the following properties on theservice_bus_queue_trigger:
service_bus_queue_trigger
arg_name
queue_name
connection
For Python functions defined by usingfunction.json, see theConfigurationsection.
Annotations
TheServiceBusQueueTriggerannotation allows you to create a function that runs when a Service Bus queue message is created. Configuration options available include the following properties:
ServiceBusQueueTrigger
TheServiceBusTopicTriggerannotation allows you to designate a topic and subscription to target what data triggers the function.
ServiceBusTopicTrigger
When you're developing locally, add your application settings in thelocal.settings.json filein theValuescollection.
Values
See the triggerexamplefor more detail.
Configuration
Applies only to the Python v1 programming model.
Model v4
Model v3
The following table explains the properties that you can set on theoptionsobject passed to theapp.serviceBusQueue()orapp.serviceBusTopic()methods.
options
app.serviceBusQueue()
app.serviceBusTopic()
manage
listen
manage
connection
accessRights
true
false
true
true
abandonAsync
completeAsync
The following table explains the binding configuration properties that you set in thefunction.jsonfile.
serviceBusTrigger
manage
listen
manage
connection
accessRights
true
false
true
true
abandonAsync
completeAsync
When you're developing locally, add your application settings in thelocal.settings.json filein theValuescollection.
Values
The following table explains the binding configuration properties that you set in thefunction.jsonfile.
serviceBusTrigger
manage
listen
manage
connection
accessRights
true
false
true
true
abandonAsync
completeAsync
When you're developing locally, add your application settings in thelocal.settings.json filein theValuescollection.
Values
See theExample sectionfor complete examples.
Usage
The following parameter types are supported by all C# modalities and extension versions:
Messaging-specific parameter types contain additional message metadata. The specific types supported by the Service Bus trigger depend on the Functions runtime version, the extension package version, and the C# modality used.
Extension v5.x
Functions 2.x and higher
Functions 1.x
Extension 5.x and higher
Functions 2.x and higher
Functions 1.x
Use theServiceBusReceivedMessagetype to receive message metadata from Service Bus Queues and Subscriptions. To learn more, seeMessages, payloads, and serialization.
InC# class libraries, the attribute's constructor takes the name of the queue or the topic and subscription.
You can also use theServiceBusAccountAttributeto specify the Service Bus account to use. The constructor takes the name of an app setting that contains a Service Bus connection string. The attribute can be applied at the parameter, method, or class level. The following example shows class level and method level:
[ServiceBusAccount("ClassLevelServiceBusAppSetting")]
public static class AzureFunctions
{
    [ServiceBusAccount("MethodLevelServiceBusAppSetting")]
    [FunctionName("ServiceBusQueueTriggerCSharp")]
    public static void Run(
        [ServiceBusTrigger("myqueue", AccessRights.Manage)] 
        string myQueueItem, ILogger log)
{
    ...
}
[ServiceBusAccount("ClassLevelServiceBusAppSetting")]
public static class AzureFunctions
{
    [ServiceBusAccount("MethodLevelServiceBusAppSetting")]
    [FunctionName("ServiceBusQueueTriggerCSharp")]
    public static void Run(
        [ServiceBusTrigger("myqueue", AccessRights.Manage)] 
        string myQueueItem, ILogger log)
{
    ...
}
The Service Bus account to use is determined in the following order:
TheServiceBusTriggerattribute'sConnectionproperty.
ServiceBusTrigger
Connection
TheServiceBusAccountattribute applied to the same parameter as theServiceBusTriggerattribute.
ServiceBusAccount
ServiceBusTrigger
TheServiceBusAccountattribute applied to the function.
ServiceBusAccount
TheServiceBusAccountattribute applied to the class.
ServiceBusAccount
TheAzureWebJobsServiceBusapp setting.
AzureWebJobsServiceBus
Use theMessagetype to receive messages with metadata. To learn more, seeMessages, payloads, and serialization.
On 30 September 2026, we'll retire the Azure Service Bus SDK libraries WindowsAzure.ServiceBus, Microsoft.Azure.ServiceBus, and com.microsoft.azure.servicebus, which don't conform to Azure SDK guidelines. We'll also end support of the SBMP protocol, so you'll no longer be able to use this protocol after 30 September 2026. Migrate to the latest Azure SDK libraries, which offer critical security updates and improved capabilities, before that date.
Although the older libraries can still be used beyond 30 September 2026, they'll no longer receive official support and updates from Microsoft. For more information, see thesupport retirement announcement.
InC# class libraries, the attribute's constructor takes the name of the queue or the topic and subscription.
You can also use theServiceBusAccountAttributeto specify the Service Bus account to use. The constructor takes the name of an app setting that contains a Service Bus connection string. The attribute can be applied at the parameter, method, or class level. The following example shows class level and method level:
[ServiceBusAccount("ClassLevelServiceBusAppSetting")]
public static class AzureFunctions
{
    [ServiceBusAccount("MethodLevelServiceBusAppSetting")]
    [FunctionName("ServiceBusQueueTriggerCSharp")]
    public static void Run(
        [ServiceBusTrigger("myqueue", AccessRights.Manage)] 
        string myQueueItem, ILogger log)
{
    ...
}
[ServiceBusAccount("ClassLevelServiceBusAppSetting")]
public static class AzureFunctions
{
    [ServiceBusAccount("MethodLevelServiceBusAppSetting")]
    [FunctionName("ServiceBusQueueTriggerCSharp")]
    public static void Run(
        [ServiceBusTrigger("myqueue", AccessRights.Manage)] 
        string myQueueItem, ILogger log)
{
    ...
}
The Service Bus account to use is determined in the following order:
TheServiceBusTriggerattribute'sConnectionproperty.
ServiceBusTrigger
Connection
TheServiceBusAccountattribute applied to the same parameter as theServiceBusTriggerattribute.
ServiceBusAccount
ServiceBusTrigger
TheServiceBusAccountattribute applied to the function.
ServiceBusAccount
TheServiceBusAccountattribute applied to the class.
ServiceBusAccount
TheAzureWebJobsServiceBusapp setting.
AzureWebJobsServiceBus
The following parameter types are available for the queue or topic message:
BrokeredMessage- Gives you the deserialized message with theBrokeredMessage.GetBody<T>()method.
MessageReceiver- Used to receive and acknowledge messages from the message container, which is required whenautoCompleteis set tofalse.
autoComplete
false
On 30 September 2026, we'll retire the Azure Service Bus SDK libraries WindowsAzure.ServiceBus, Microsoft.Azure.ServiceBus, and com.microsoft.azure.servicebus, which don't conform to Azure SDK guidelines. We'll also end support of the SBMP protocol, so you'll no longer be able to use this protocol after 30 September 2026. Migrate to the latest Azure SDK libraries, which offer critical security updates and improved capabilities, before that date.
Although the older libraries can still be used beyond 30 September 2026, they'll no longer receive official support and updates from Microsoft. For more information, see thesupport retirement announcement.
InC# class libraries, the attribute's constructor takes the name of the queue or the topic and subscription. In Azure Functions version 1.x, you can also specify the connection's access rights. If you don't specify access rights, the default isManage.
Manage
You can also use theServiceBusAccountAttributeto specify the Service Bus account to use. The constructor takes the name of an app setting that contains a Service Bus connection string. The attribute can be applied at the parameter, method, or class level. The following example shows class level and method level:
[ServiceBusAccount("ClassLevelServiceBusAppSetting")]
public static class AzureFunctions
{
    [ServiceBusAccount("MethodLevelServiceBusAppSetting")]
    [FunctionName("ServiceBusQueueTriggerCSharp")]
    public static void Run(
        [ServiceBusTrigger("myqueue", AccessRights.Manage)] 
        string myQueueItem, ILogger log)
{
    ...
}
[ServiceBusAccount("ClassLevelServiceBusAppSetting")]
public static class AzureFunctions
{
    [ServiceBusAccount("MethodLevelServiceBusAppSetting")]
    [FunctionName("ServiceBusQueueTriggerCSharp")]
    public static void Run(
        [ServiceBusTrigger("myqueue", AccessRights.Manage)] 
        string myQueueItem, ILogger log)
{
    ...
}
The Service Bus account to use is determined in the following order:
TheServiceBusTriggerattribute'sConnectionproperty.
ServiceBusTrigger
Connection
TheServiceBusAccountattribute applied to the same parameter as theServiceBusTriggerattribute.
ServiceBusAccount
ServiceBusTrigger
TheServiceBusAccountattribute applied to the function.
ServiceBusAccount
TheServiceBusAccountattribute applied to the class.
ServiceBusAccount
TheAzureWebJobsServiceBusapp setting.
AzureWebJobsServiceBus
When you want the function to process a single message, the Service Bus trigger can bind to the following types:
string
byte[]
ServiceBusReceivedMessage
When you want the function to process a batch of messages, the Service Bus trigger can bind to the following types:
T[]
T
ServiceBusReceivedMessage[]
1To use these types, you need to referenceMicrosoft.Azure.Functions.Worker.Extensions.ServiceBus 5.14.1 or laterand thecommon dependencies for SDK type bindings.
2When usingServiceBusMessageActions, set theAutoCompleteMessagesproperty of the trigger attributetofalse. This prevents the runtime from attempting to complete messages after a successful function invocation.
ServiceBusMessageActions
AutoCompleteMessages
false
Earlier versions of this extension in the isolated worker process only support binding to messaging-specific types. Additional options are available toextension 5.x and higher
Functions version 1.x doesn't support isolated worker process. To use the isolated worker model,upgrade your application to Functions 4.x.
When theConnectionproperty isn't defined, Functions looks for an app setting namedAzureWebJobsServiceBus, which is the default name for the Service Bus connection string. You can also set theConnectionproperty to specify the name of an application setting that contains the Service Bus connection string to use.
Connection
AzureWebJobsServiceBus
Connection
The incoming Service Bus message is available via aServiceBusQueueMessageorServiceBusTopicMessageparameter.
ServiceBusQueueMessage
ServiceBusTopicMessage
Model v4
Model v3
Access the queue or topic message as the first argument to your function. The Service Bus message is passed into the function as either a string or JSON object.
Access the queue or topic message by usingcontext.bindings.<name from function.json>. The Service Bus message is passed into the function as either a string or JSON object.
context.bindings.<name from function.json>
The Service Bus instance is available via the parameter configured in thefunction.jsonfile's name property.
The queue message is available to the function via a parameter typed asfunc.ServiceBusMessage. The Service Bus message is passed into the function as either a string or JSON object.
func.ServiceBusMessage
For a complete example, seethe examples section.
Connections
Theconnectionproperty is a reference to environment configuration which specifies how the app should connect to Service Bus. It may specify:
connection
The name of an application setting containing aconnection string
The name of a shared prefix for multiple application settings, together defining anidentity-based connection.
If the configured value is both an exact match for a single setting and a prefix match for other settings, the exact match is used.
Connection string
To obtain a connection string, follow the steps shown atGet the management credentials. The connection string must be for a Service Bus namespace, not limited to a specific queue or topic.
This connection string should be stored in an application setting with a name matching the value specified by theconnectionproperty of the binding configuration.
connection
If the app setting name begins with "AzureWebJobs", you can specify only the remainder of the name. For example, if you setconnectionto "MyServiceBus", the Functions runtime looks for an app setting that is named "AzureWebJobsMyServiceBus". If you leaveconnectionempty, the Functions runtime uses the default Service Bus connection string in the app setting that is named "AzureWebJobsServiceBus".
connection
connection
Identity-based connections
If you are usingversion 5.x or higher of the extension, instead of using a connection string with a secret, you can have the app use anMicrosoft Entra identity. To do this, you would define settings under a common prefix which maps to theconnectionproperty in the trigger and binding configuration.
connection
In this mode, the extension requires the following properties:
<CONNECTION_NAME_PREFIX>__fullyQualifiedNamespace
Additional properties may be set to customize the connection. SeeCommon properties for identity-based connections.
Note
When usingAzure App ConfigurationorKey Vaultto provide settings for Managed Identity connections, setting names should use a valid key separator such as:or/in place of the__to ensure names are resolved correctly.
:
/
__
For example,<CONNECTION_NAME_PREFIX>:fullyQualifiedNamespace.
<CONNECTION_NAME_PREFIX>:fullyQualifiedNamespace
When hosted in the Azure Functions service, identity-based connections use amanaged identity. The system-assigned identity is used by default, although a user-assigned identity can be specified with thecredentialandclientIDproperties. Note that configuring a user-assigned identity with a resource ID isnotsupported. When run in other contexts, such as local development, your developer identity is used instead, although this can be customized. SeeLocal development with identity-based connections.
credential
clientID
Whatever identity is being used must have permissions to perform the intended actions. For most Azure services, this means you need toassign a role in Azure RBAC, using either built-in or custom roles which provide those permissions.
Important
Some permissions might be exposed by the target service that are not necessary for all contexts. Where possible, adhere to theprinciple of least privilege, granting the identity only required privileges. For example, if the app only needs to be able to read from a data source, use a role that only has permission to read. It would be inappropriate to assign a role that also allows writing to that service, as this would be excessive permission for a read operation. Similarly, you would want to ensure the role assignment is scoped only over the resources that need to be read.
You'll need to create a role assignment that provides access to your topics and queues at runtime. Management roles likeOwneraren't sufficient. The following table shows built-in roles that are recommended when using the Service Bus extension in normal operation. Your application may require additional permissions based on the code you write.
1For triggering from Service Bus topics, the role assignment needs to have effective scope over the Service Bus subscription resource. If only the topic is included, an error will occur. Some clients, such as the Azure portal, don't expose the Service Bus subscription resource as a scope for role assignment. In such cases, the Azure CLI may be used instead. To learn more, seeAzure built-in roles for Azure Service Bus.
Poison messages
Poison message handling can't be controlled or configured in Azure Functions. Service Bus handles poison messages itself.
PeekLock behavior
The Functions runtime receives a message inPeekLock mode.
By default, the runtime callsCompleteon the message if the function finishes successfully, or callsAbandonif the function fails. You can disable automatic completion through with theautoCompleteMessagesproperty inhost.json.
Complete
Abandon
autoCompleteMessages
host.json
By default, the runtime callsCompleteon the message if the function finishes successfully, or callsAbandonif the function fails. You can disable automatic completion through with theautoCompleteMessagesproperty inhost.jsonor through aproperty on the trigger attribute. You should disable automatic completion if your function code handles message settlement.
Complete
Abandon
autoCompleteMessages
host.json
If the function runs longer than thePeekLocktimeout, the lock is automatically renewed as long as the function is running. ThemaxAutoRenewDurationis configurable inhost.json, which maps toServiceBusProcessor.MaxAutoLockRenewalDuration. The default value of this setting is 5 minutes.
PeekLock
maxAutoRenewDuration
Message metadata
Messaging-specific types let you easily retrievemetadata as properties of the object. These properties depend on the Functions runtime version, the extension package version, and the C# modality used.
Extension v5.x
Functions 2.x and higher
Functions 1.x
Extension 5.x and higher
Functions 2.x and higher
Functions 1.x
These properties are members of theServiceBusReceivedMessageclass.
ApplicationProperties
ApplicationProperties
ContentType
string
CorrelationId
string
DeliveryCount
Int32
EnqueuedTime
DateTime
ScheduledEnqueueTimeUtc
DateTime
ExpiresAt
DateTime
MessageId
string
ReplyTo
string
Subject
string
Label
To
string
These properties are members of theMessageclass.
On 30 September 2026, we'll retire the Azure Service Bus SDK libraries WindowsAzure.ServiceBus, Microsoft.Azure.ServiceBus, and com.microsoft.azure.servicebus, which don't conform to Azure SDK guidelines. We'll also end support of the SBMP protocol, so you'll no longer be able to use this protocol after 30 September 2026. Migrate to the latest Azure SDK libraries, which offer critical security updates and improved capabilities, before that date.
Although the older libraries can still be used beyond 30 September 2026, they'll no longer receive official support and updates from Microsoft. For more information, see thesupport retirement announcement.
ContentType
string
CorrelationId
string
DeliveryCount
Int32
ScheduledEnqueueTimeUtc
DateTime
ExpiresAtUtc
DateTime
Label
string
MessageId
string
ReplyTo
string
To
string
UserProperties
IDictionary<string, object>
These properties are members of theBrokeredMessageandMessageReceiverclasses.
On 30 September 2026, we'll retire the Azure Service Bus SDK libraries WindowsAzure.ServiceBus, Microsoft.Azure.ServiceBus, and com.microsoft.azure.servicebus, which don't conform to Azure SDK guidelines. We'll also end support of the SBMP protocol, so you'll no longer be able to use this protocol after 30 September 2026. Migrate to the latest Azure SDK libraries, which offer critical security updates and improved capabilities, before that date.
Although the older libraries can still be used beyond 30 September 2026, they'll no longer receive official support and updates from Microsoft. For more information, see thesupport retirement announcement.
ContentType
string
CorrelationId
string
DeadLetterSource
string
DeliveryCount
Int32
EnqueuedTimeUtc
DateTime
ExpiresAtUtc
DateTime
Label
string
MessageId
string
MessageReceiver
MessageReceiver
MessageSession
MessageSession
ReplyTo
string
SequenceNumber
long
To
string
UserProperties
IDictionary<string, object>
These properties are members of theServiceBusReceivedMessageclass.
ApplicationProperties
ApplicationProperties
ContentType
string
CorrelationId
string
DeliveryCount
Int32
EnqueuedTime
DateTime
ScheduledEnqueueTimeUtc
DateTime
ExpiresAt
DateTime
MessageId
string
ReplyTo
string
Subject
string
Label
To
string
Earlier versions of this extension in the isolated worker process only support binding to messaging-specific types. Additional options are available toExtension 5.x and higher
Functions version 1.x doesn't support isolated worker process. To use the isolated worker model,upgrade your application to Functions 4.x.
Next steps
Send Azure Service Bus messages from Azure Functions (Output binding)
Feedback
Was this page helpful?
Additional resources