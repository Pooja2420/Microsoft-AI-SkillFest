Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Add a custom pipelines task extension
Article
2025-03-21
37 contributors
In this article
Azure DevOps Services | Azure DevOps Server 2022 - Azure DevOps Server 2019
This article explains how to install extensions to your organization for custom build or release tasks in Azure DevOps. For more information, seeWhat is Azure Pipelines?
Note
This article covers agent tasks in agent-based extensions. For more information on server tasks and server-based extensions, see theServer Task Authoring.
Prerequisites
An organization in Azure DevOps.Create an organization.
An organization in Azure DevOps.Create an organization.
A text editor. For many tutorials, we useVisual Studio Code, which provides intellisense and debugging support.
A text editor. For many tutorials, we useVisual Studio Code, which provides intellisense and debugging support.
The latest version ofNode.js.
The latest version ofNode.js.
npmjs.com 4.0.2 or newer. Install thelatest versionof this TypeScript compiler.
npmjs.com 4.0.2 or newer. Install thelatest versionof this TypeScript compiler.
Cross-platform CLI for Azure DevOps (tfx-cli)to package your extensions.tfx-cli can be installed usingnpm, a component of Node.js, by runningnpm i -g tfx-cli.
Cross-platform CLI for Azure DevOps (tfx-cli)to package your extensions.
tfx-cli can be installed usingnpm, a component of Node.js, by runningnpm i -g tfx-cli.
npm
npm i -g tfx-cli
Azure DevOps extension SDK. Install theazure-devops-extension-sdkpackage.
Azure DevOps extension SDK. Install theazure-devops-extension-sdkpackage.
Ahomedirectory for your project. Thehomedirectory of a build or release task extension should have the following structure after you complete the steps in this article:|--- README.md    
|--- images                        
    |--- extension-icon.png  
|--- buildandreleasetask            // where your task scripts are placed
|--- vss-extension.json             // extension's manifest
Ahomedirectory for your project. Thehomedirectory of a build or release task extension should have the following structure after you complete the steps in this article:
home
home
|--- README.md    
|--- images                        
    |--- extension-icon.png  
|--- buildandreleasetask            // where your task scripts are placed
|--- vss-extension.json             // extension's manifest
|--- README.md    
|--- images                        
    |--- extension-icon.png  
|--- buildandreleasetask            // where your task scripts are placed
|--- vss-extension.json             // extension's manifest
Important
The dev machine must run thelatest version of Nodeto ensure that the written code is compatible with the production environment on the agent and the latest non-preview version ofazure-pipelines-task-lib. Update yourtask.jsonfile as per the following command:
azure-pipelines-task-lib
task.json
"execution": {
   "Node20_1": {
     "target": "index.js"
   }
 }
"execution": {
   "Node20_1": {
     "target": "index.js"
   }
 }

1. Create a custom task
Do every part of this procedure within thebuildandreleasetaskfolder inside yourhomedirectory.
buildandreleasetask
home
Note
This example walkthrough uses Windows with PowerShell. The steps are generic for all platforms, but the syntax for getting environment variables is different. If you're using a Mac or Linux, replace any instances of$env:<var>=<val>withexport <var>=<val>.
$env:<var>=<val>
export <var>=<val>
Create task scaffolding
Create the folder structure for the task and install the required libraries and dependencies.
Create the folder structure for the task and install the required libraries and dependencies.
Open a PowerShell command window, go to yourbuildandreleasetaskfolder, and run the following command.npm init --yesnpm initcreates thepackage.jsonfile. We added the--yesparameter to accept all of the defaultnpm initoptions.TipThe agent doesn't automatically install the required modules because it's expecting your task folder to include the node modules. To mitigate, copy thenode_modulestobuildandreleasetask. As your task gets bigger, it's easy to exceed the size limit (50 MB) of a VSIX file. Before you copy the node folder, you might want to runnpm install --productionornpm prune --production, or you can write a script to build and pack everything.
Open a PowerShell command window, go to yourbuildandreleasetaskfolder, and run the following command.
buildandreleasetask
npm init --yes
npm init --yes
npm initcreates thepackage.jsonfile. We added the--yesparameter to accept all of the defaultnpm initoptions.
npm init
package.json
--yes
npm init
Tip
The agent doesn't automatically install the required modules because it's expecting your task folder to include the node modules. To mitigate, copy thenode_modulestobuildandreleasetask. As your task gets bigger, it's easy to exceed the size limit (50 MB) of a VSIX file. Before you copy the node folder, you might want to runnpm install --productionornpm prune --production, or you can write a script to build and pack everything.
node_modules
buildandreleasetask
npm install --production
npm prune --production
Addazure-pipelines-task-libto your library.npm install azure-pipelines-task-lib --save
Addazure-pipelines-task-libto your library.
azure-pipelines-task-lib
npm install azure-pipelines-task-lib --save
npm install azure-pipelines-task-lib --save
Ensure that TypeScript typings are installed for external dependencies.npm install @types/node --save-dev
npm install @types/q --save-dev
Ensure that TypeScript typings are installed for external dependencies.
npm install @types/node --save-dev
npm install @types/q --save-dev
npm install @types/node --save-dev
npm install @types/q --save-dev
Create a.gitignorefile and add node_modules to it. Your build process should do annpm installand atypings installso that node_modules are built each time and don't need to be checked in.echo node_modules > .gitignore
Create a.gitignorefile and add node_modules to it. Your build process should do annpm installand atypings installso that node_modules are built each time and don't need to be checked in.
.gitignore
npm install
typings install
echo node_modules > .gitignore
echo node_modules > .gitignore
InstallMochaas a development dependency.npm install mocha --save-dev -g
npm install sync-request --save-dev
npm install @types/mocha --save-dev
InstallMochaas a development dependency.
npm install mocha --save-dev -g
npm install sync-request --save-dev
npm install @types/mocha --save-dev
npm install mocha --save-dev -g
npm install sync-request --save-dev
npm install @types/mocha --save-dev
Choose TypeScript version 2.3.4 or 4.6.3.npm install typescript@4.6.3 -g --save-devNoteMake sure that TypeScript is installed globally withnpmin your development environment, so thetsccommand is available. If you skip this step, TypeScript version 2.3.4 gets used by default, and you still have to install the package globally to have thetsccommand available.
Choose TypeScript version 2.3.4 or 4.6.3.
npm install typescript@4.6.3 -g --save-dev
npm install typescript@4.6.3 -g --save-dev
Note
Make sure that TypeScript is installed globally withnpmin your development environment, so thetsccommand is available. If you skip this step, TypeScript version 2.3.4 gets used by default, and you still have to install the package globally to have thetsccommand available.
npm
tsc
tsc
Createtsconfig.jsoncompiler options. This file ensures that your TypeScript files are compiled to JavaScript files.tsc --init --target es2022
Createtsconfig.jsoncompiler options. This file ensures that your TypeScript files are compiled to JavaScript files.
tsconfig.json
tsc --init --target es2022
tsc --init --target es2022
Create task
Now that the scaffolding is complete, you can create your custom task.
Create atask.jsonfile in thebuildandreleasetaskfolder. Thetask.jsonfile describes the build/release task and is what the build/release system uses to render configuration options to the user and to know which scripts to execute at build/release time.
Create atask.jsonfile in thebuildandreleasetaskfolder. Thetask.jsonfile describes the build/release task and is what the build/release system uses to render configuration options to the user and to know which scripts to execute at build/release time.
task.json
buildandreleasetask
task.json
Copy the following code and replace the{{placeholders}}with your task's information. The most important placeholder is thetaskguid, and it must be unique.{
 "$schema": "https://raw.githubusercontent.com/Microsoft/azure-pipelines-task-lib/master/tasks.schema.json",
 "id": "{{taskguid}}",
 "name": "{{taskname}}",
 "friendlyName": "{{taskfriendlyname}}",
 "description": "{{taskdescription}}",
 "helpMarkDown": "",
 "category": "Utility",
 "author": "{{taskauthor}}",
 "version": {
     "Major": 0,
     "Minor": 1,
     "Patch": 0
 },
 "instanceNameFormat": "Echo $(samplestring)",
 "inputs": [
     {
         "name": "samplestring",
         "type": "string",
         "label": "Sample String",
         "defaultValue": "",
         "required": true,
         "helpMarkDown": "A sample string"
     }
 ],
 "execution": {
     "Node20_1": {
         "target": "index.js"
     }
 }
 }
Copy the following code and replace the{{placeholders}}with your task's information. The most important placeholder is thetaskguid, and it must be unique.
{{placeholders}}
taskguid
{
 "$schema": "https://raw.githubusercontent.com/Microsoft/azure-pipelines-task-lib/master/tasks.schema.json",
 "id": "{{taskguid}}",
 "name": "{{taskname}}",
 "friendlyName": "{{taskfriendlyname}}",
 "description": "{{taskdescription}}",
 "helpMarkDown": "",
 "category": "Utility",
 "author": "{{taskauthor}}",
 "version": {
     "Major": 0,
     "Minor": 1,
     "Patch": 0
 },
 "instanceNameFormat": "Echo $(samplestring)",
 "inputs": [
     {
         "name": "samplestring",
         "type": "string",
         "label": "Sample String",
         "defaultValue": "",
         "required": true,
         "helpMarkDown": "A sample string"
     }
 ],
 "execution": {
     "Node20_1": {
         "target": "index.js"
     }
 }
 }
{
 "$schema": "https://raw.githubusercontent.com/Microsoft/azure-pipelines-task-lib/master/tasks.schema.json",
 "id": "{{taskguid}}",
 "name": "{{taskname}}",
 "friendlyName": "{{taskfriendlyname}}",
 "description": "{{taskdescription}}",
 "helpMarkDown": "",
 "category": "Utility",
 "author": "{{taskauthor}}",
 "version": {
     "Major": 0,
     "Minor": 1,
     "Patch": 0
 },
 "instanceNameFormat": "Echo $(samplestring)",
 "inputs": [
     {
         "name": "samplestring",
         "type": "string",
         "label": "Sample String",
         "defaultValue": "",
         "required": true,
         "helpMarkDown": "A sample string"
     }
 ],
 "execution": {
     "Node20_1": {
         "target": "index.js"
     }
 }
 }
Create anindex.tsfile by using the following code as a reference. This code runs when the task gets called.import tl = require('azure-pipelines-task-lib/task');

 async function run() {
     try {
         const inputString: string | undefined = tl.getInput('samplestring', true);
         if (inputString == 'bad') {
             tl.setResult(tl.TaskResult.Failed, 'Bad input was given');
             return;
         }
         console.log('Hello', inputString);
     }
     catch (err:any) {
         tl.setResult(tl.TaskResult.Failed, err.message);
     }
 }

 run();
Create anindex.tsfile by using the following code as a reference. This code runs when the task gets called.
index.ts
import tl = require('azure-pipelines-task-lib/task');

 async function run() {
     try {
         const inputString: string | undefined = tl.getInput('samplestring', true);
         if (inputString == 'bad') {
             tl.setResult(tl.TaskResult.Failed, 'Bad input was given');
             return;
         }
         console.log('Hello', inputString);
     }
     catch (err:any) {
         tl.setResult(tl.TaskResult.Failed, err.message);
     }
 }

 run();
import tl = require('azure-pipelines-task-lib/task');

 async function run() {
     try {
         const inputString: string | undefined = tl.getInput('samplestring', true);
         if (inputString == 'bad') {
             tl.setResult(tl.TaskResult.Failed, 'Bad input was given');
             return;
         }
         console.log('Hello', inputString);
     }
     catch (err:any) {
         tl.setResult(tl.TaskResult.Failed, err.message);
     }
 }

 run();
To compile anindex.jsfile fromindex.ts, entertscfrom thebuildandreleasetaskfolder.
To compile anindex.jsfile fromindex.ts, entertscfrom thebuildandreleasetaskfolder.
index.js
index.ts
tsc
buildandreleasetask
See the following descriptions of some of the components of thetask.jsonfile.
task.json
id
name
friendlyName
description
author
instanceNameFormat
groups
inputs
execution
Node
PowerShell
PowerShell3
Process
restrictions
Note
Create anidwith the following command in PowerShell:
id
(New-Guid).Guid
(New-Guid).Guid
For more information, see theBuild/release task reference.
Run the task
Run the task by usingnode index.jsfrom PowerShell.
node index.js
In the following example, the task fails because inputs weren't supplied (samplestringis a required input).
samplestring
node index.js
 ##vso[task.debug]agent.workFolder=undefined
 ##vso[task.debug]loading inputs and endpoints
 ##vso[task.debug]loaded 0
 ##vso[task.debug]task result: Failed
 ##vso[task.issue type=error;]Input required: samplestring
 ##vso[task.complete result=Failed;]Input required: samplestring
node index.js
 ##vso[task.debug]agent.workFolder=undefined
 ##vso[task.debug]loading inputs and endpoints
 ##vso[task.debug]loaded 0
 ##vso[task.debug]task result: Failed
 ##vso[task.issue type=error;]Input required: samplestring
 ##vso[task.complete result=Failed;]Input required: samplestring
As a fix, set thesamplestringinput and run the task again.
samplestring
$env:INPUT_SAMPLESTRING="Human"
node index.js
##vso[task.debug]agent.workFolder=undefined
##vso[task.debug]loading inputs and endpoints
##vso[task.debug]loading INPUT_SAMPLESTRING
##vso[task.debug]loaded 1
##vso[task.debug]Agent.ProxyUrl=undefined
##vso[task.debug]Agent.CAInfo=undefined
##vso[task.debug]Agent.ClientCert=undefined
##vso[task.debug]Agent.SkipCertValidation=undefined
##vso[task.debug]samplestring=Human
Hello Human
$env:INPUT_SAMPLESTRING="Human"
node index.js
##vso[task.debug]agent.workFolder=undefined
##vso[task.debug]loading inputs and endpoints
##vso[task.debug]loading INPUT_SAMPLESTRING
##vso[task.debug]loaded 1
##vso[task.debug]Agent.ProxyUrl=undefined
##vso[task.debug]Agent.CAInfo=undefined
##vso[task.debug]Agent.ClientCert=undefined
##vso[task.debug]Agent.SkipCertValidation=undefined
##vso[task.debug]samplestring=Human
Hello Human
This time, the task succeeds becausesamplestringwas supplied, and it correctly outputsHello Human!
samplestring
Tip
For information about various task runners and how to include the latest node version in thetask.json, seeNode runner update guidance for Azure Pipelines task authors.
task.json

2. Unit test your task scripts
Do unit tests to quickly test the task script, and not the external tools that it calls. Test all aspects of both success and failure paths.
Install test tools. We useMochaas the test driver in this procedure.npm install mocha --save-dev -g
npm install sync-request --save-dev
npm install @types/mocha --save-dev
Install test tools. We useMochaas the test driver in this procedure.
npm install mocha --save-dev -g
npm install sync-request --save-dev
npm install @types/mocha --save-dev
npm install mocha --save-dev -g
npm install sync-request --save-dev
npm install @types/mocha --save-dev
Create atestsfolder containing a_suite.tsfile with the following contents:import * as path from 'path';
import * as assert from 'assert';
import * as ttm from 'azure-pipelines-task-lib/mock-test';

describe('Sample task tests', function () {

    before( function() {

    });

    after(() => {

    });

    it('should succeed with simple inputs', function(done: Mocha.Done) {
        // Add success test here
    });

    it('it should fail if tool returns 1', function(done: Mocha.Done) {
        // Add failure test here
    });    
});TipYour test folder should be located in thebuildandreleasetaskfolder. If you get a sync-request error, you can work around it by adding sync-request to thebuildandreleasetaskfolder with the commandnpm i --save-dev sync-request.
Create atestsfolder containing a_suite.tsfile with the following contents:
tests
_suite.ts
import * as path from 'path';
import * as assert from 'assert';
import * as ttm from 'azure-pipelines-task-lib/mock-test';

describe('Sample task tests', function () {

    before( function() {

    });

    after(() => {

    });

    it('should succeed with simple inputs', function(done: Mocha.Done) {
        // Add success test here
    });

    it('it should fail if tool returns 1', function(done: Mocha.Done) {
        // Add failure test here
    });    
});
import * as path from 'path';
import * as assert from 'assert';
import * as ttm from 'azure-pipelines-task-lib/mock-test';

describe('Sample task tests', function () {

    before( function() {

    });

    after(() => {

    });

    it('should succeed with simple inputs', function(done: Mocha.Done) {
        // Add success test here
    });

    it('it should fail if tool returns 1', function(done: Mocha.Done) {
        // Add failure test here
    });    
});
Tip
Your test folder should be located in thebuildandreleasetaskfolder. If you get a sync-request error, you can work around it by adding sync-request to thebuildandreleasetaskfolder with the commandnpm i --save-dev sync-request.
buildandreleasetask
buildandreleasetask
npm i --save-dev sync-request
Create asuccess.tsfile in your test directory with the following contents. This file creation simulates running the task and mocks all calls to outside methods.import ma = require('azure-pipelines-task-lib/mock-answer');
import tmrm = require('azure-pipelines-task-lib/mock-run');
import path = require('path');

let taskPath = path.join(__dirname, '..', 'index.js');
let tmr: tmrm.TaskMockRunner = new tmrm.TaskMockRunner(taskPath);

tmr.setInput('samplestring', 'human');

tmr.run();The success test validates that, with the appropriate inputs, it succeeds with no errors or warnings and returns the correct output.
Create asuccess.tsfile in your test directory with the following contents. This file creation simulates running the task and mocks all calls to outside methods.
success.ts
import ma = require('azure-pipelines-task-lib/mock-answer');
import tmrm = require('azure-pipelines-task-lib/mock-run');
import path = require('path');

let taskPath = path.join(__dirname, '..', 'index.js');
let tmr: tmrm.TaskMockRunner = new tmrm.TaskMockRunner(taskPath);

tmr.setInput('samplestring', 'human');

tmr.run();
import ma = require('azure-pipelines-task-lib/mock-answer');
import tmrm = require('azure-pipelines-task-lib/mock-run');
import path = require('path');

let taskPath = path.join(__dirname, '..', 'index.js');
let tmr: tmrm.TaskMockRunner = new tmrm.TaskMockRunner(taskPath);

tmr.setInput('samplestring', 'human');

tmr.run();
The success test validates that, with the appropriate inputs, it succeeds with no errors or warnings and returns the correct output.
To run the task mock runner, add the following example success test to your_suite.tsfile.it('should succeed with simple inputs', function(done: Mocha.Done) {
     this.timeout(1000);

     let tp: string = path.join(__dirname, 'success.js');
     let tr: ttm.MockTestRunner = new ttm.MockTestRunner(tp);

     // tr.run(); //current, old function.
     tr.runAsync().then(() => {
         console.log(tr.succeeded);
         assert.equal(tr.succeeded, true, 'should have succeeded');
         assert.equal(tr.warningIssues.length, 0, "should have no warnings");
         assert.equal(tr.errorIssues.length, 0, "should have no errors");
         console.log(tr.stdout);
         assert.equal(tr.stdout.indexOf('Hello human') >= 0, true, "should display Hello human");
         done();
     }).catch((error) => {
         done(error); // Ensure the test case fails if there's an error
     });
 });
To run the task mock runner, add the following example success test to your_suite.tsfile.
_suite.ts
it('should succeed with simple inputs', function(done: Mocha.Done) {
     this.timeout(1000);

     let tp: string = path.join(__dirname, 'success.js');
     let tr: ttm.MockTestRunner = new ttm.MockTestRunner(tp);

     // tr.run(); //current, old function.
     tr.runAsync().then(() => {
         console.log(tr.succeeded);
         assert.equal(tr.succeeded, true, 'should have succeeded');
         assert.equal(tr.warningIssues.length, 0, "should have no warnings");
         assert.equal(tr.errorIssues.length, 0, "should have no errors");
         console.log(tr.stdout);
         assert.equal(tr.stdout.indexOf('Hello human') >= 0, true, "should display Hello human");
         done();
     }).catch((error) => {
         done(error); // Ensure the test case fails if there's an error
     });
 });
it('should succeed with simple inputs', function(done: Mocha.Done) {
     this.timeout(1000);

     let tp: string = path.join(__dirname, 'success.js');
     let tr: ttm.MockTestRunner = new ttm.MockTestRunner(tp);

     // tr.run(); //current, old function.
     tr.runAsync().then(() => {
         console.log(tr.succeeded);
         assert.equal(tr.succeeded, true, 'should have succeeded');
         assert.equal(tr.warningIssues.length, 0, "should have no warnings");
         assert.equal(tr.errorIssues.length, 0, "should have no errors");
         console.log(tr.stdout);
         assert.equal(tr.stdout.indexOf('Hello human') >= 0, true, "should display Hello human");
         done();
     }).catch((error) => {
         done(error); // Ensure the test case fails if there's an error
     });
 });
Create afailure.tsfile in your test directory as your task mock runner with the following contents:import ma = require('azure-pipelines-task-lib/mock-answer');
import tmrm = require('azure-pipelines-task-lib/mock-run');
import path = require('path');

let taskPath = path.join(__dirname, '..', 'index.js');
let tmr: tmrm.TaskMockRunner = new tmrm.TaskMockRunner(taskPath);

tmr.setInput('samplestring', 'bad');

tmr.run();The failure test validates that, when the tool gets bad or incomplete input, it fails in the expected way with helpful output.
Create afailure.tsfile in your test directory as your task mock runner with the following contents:
failure.ts
import ma = require('azure-pipelines-task-lib/mock-answer');
import tmrm = require('azure-pipelines-task-lib/mock-run');
import path = require('path');

let taskPath = path.join(__dirname, '..', 'index.js');
let tmr: tmrm.TaskMockRunner = new tmrm.TaskMockRunner(taskPath);

tmr.setInput('samplestring', 'bad');

tmr.run();
import ma = require('azure-pipelines-task-lib/mock-answer');
import tmrm = require('azure-pipelines-task-lib/mock-run');
import path = require('path');

let taskPath = path.join(__dirname, '..', 'index.js');
let tmr: tmrm.TaskMockRunner = new tmrm.TaskMockRunner(taskPath);

tmr.setInput('samplestring', 'bad');

tmr.run();
The failure test validates that, when the tool gets bad or incomplete input, it fails in the expected way with helpful output.
To run the task mock runner, add the following code to your_suite.tsfile.it('should fail if tool returns 1', function(done: Mocha.Done) {
    this.timeout(1000);

    const tp = path.join(__dirname, 'failure.js');
    const tr: ttm.MockTestRunner = new ttm.MockTestRunner(tp);

    tr.runAsync().then(() => {
        console.log(tr.succeeded);
        assert.equal(tr.succeeded, false, 'should have failed');
        assert.equal(tr.warningIssues.length, 0, 'should have no warnings');
        assert.equal(tr.errorIssues.length, 1, 'should have 1 error issue');
        assert.equal(tr.errorIssues[0], 'Bad input was given', 'error issue output');
        assert.equal(tr.stdout.indexOf('Hello bad'), -1, 'Should not display Hello bad');
        done();
    });
});
To run the task mock runner, add the following code to your_suite.tsfile.
_suite.ts
it('should fail if tool returns 1', function(done: Mocha.Done) {
    this.timeout(1000);

    const tp = path.join(__dirname, 'failure.js');
    const tr: ttm.MockTestRunner = new ttm.MockTestRunner(tp);

    tr.runAsync().then(() => {
        console.log(tr.succeeded);
        assert.equal(tr.succeeded, false, 'should have failed');
        assert.equal(tr.warningIssues.length, 0, 'should have no warnings');
        assert.equal(tr.errorIssues.length, 1, 'should have 1 error issue');
        assert.equal(tr.errorIssues[0], 'Bad input was given', 'error issue output');
        assert.equal(tr.stdout.indexOf('Hello bad'), -1, 'Should not display Hello bad');
        done();
    });
});
it('should fail if tool returns 1', function(done: Mocha.Done) {
    this.timeout(1000);

    const tp = path.join(__dirname, 'failure.js');
    const tr: ttm.MockTestRunner = new ttm.MockTestRunner(tp);

    tr.runAsync().then(() => {
        console.log(tr.succeeded);
        assert.equal(tr.succeeded, false, 'should have failed');
        assert.equal(tr.warningIssues.length, 0, 'should have no warnings');
        assert.equal(tr.errorIssues.length, 1, 'should have 1 error issue');
        assert.equal(tr.errorIssues[0], 'Bad input was given', 'error issue output');
        assert.equal(tr.stdout.indexOf('Hello bad'), -1, 'Should not display Hello bad');
        done();
    });
});
Run the tests.tsc
mocha tests/_suite.jsBoth tests should pass. If you want to run the tests with more verbose output (what you'd see in the build console), set the environment variable:TASK_TEST_TRACE=1.$env:TASK_TEST_TRACE=1
Run the tests.
tsc
mocha tests/_suite.js
tsc
mocha tests/_suite.js
Both tests should pass. If you want to run the tests with more verbose output (what you'd see in the build console), set the environment variable:TASK_TEST_TRACE=1.
TASK_TEST_TRACE=1
$env:TASK_TEST_TRACE=1
$env:TASK_TEST_TRACE=1

3. Create the extension manifest file
The extension manifest contains all of the information about your extension. It includes links to your files, including your task folders and images folders. Ensure you created an images folder withextension-icon.png. The following example is an extension manifest that contains the build or release task.
extension-icon.png
Copy the following .json code and save it as yourvss-extension.jsonfile in yourhomedirectory.
vss-extension.json
home
Don't create this file in the buildandreleasetask folder.
{
    "manifestVersion": 1,
    "id": "build-release-task",
    "name": "Fabrikam Build and Release Tools",
    "version": "0.0.1",
    "publisher": "fabrikam",
    "targets": [
        {
            "id": "Microsoft.VisualStudio.Services"
        }
    ],    
    "description": "Tools for building/releasing with Fabrikam. Includes one build/release task.",
    "categories": [
        "Azure Pipelines"
    ],
    "icons": {
        "default": "images/extension-icon.png"        
    },
    "files": [
        {
            "path": "buildandreleasetask"
        }
    ],
    "contributions": [
        {
            "id": "custom-build-release-task",
            "type": "ms.vss-distributed-task.task",
            "targets": [
                "ms.vss-distributed-task.tasks"
            ],
            "properties": {
                "name": "buildandreleasetask"
            }
        }
    ]
}
{
    "manifestVersion": 1,
    "id": "build-release-task",
    "name": "Fabrikam Build and Release Tools",
    "version": "0.0.1",
    "publisher": "fabrikam",
    "targets": [
        {
            "id": "Microsoft.VisualStudio.Services"
        }
    ],    
    "description": "Tools for building/releasing with Fabrikam. Includes one build/release task.",
    "categories": [
        "Azure Pipelines"
    ],
    "icons": {
        "default": "images/extension-icon.png"        
    },
    "files": [
        {
            "path": "buildandreleasetask"
        }
    ],
    "contributions": [
        {
            "id": "custom-build-release-task",
            "type": "ms.vss-distributed-task.task",
            "targets": [
                "ms.vss-distributed-task.tasks"
            ],
            "properties": {
                "name": "buildandreleasetask"
            }
        }
    ]
}
Note
Change thepublisherto your publisher name. For more information, seeCreate a publisher.
Contributions
id
type
ms.vss-distributed-task.task
targets
ms.vss-distributed-task.tasks
properties.name
Files
path
home
For more information about the extension manifest file, such as its properties and what they do, see theextension manifest reference.

4. Package your extension
Package all of your files together to get your extension into the Visual Studio Marketplace. All extensions are packaged as VSIX 2.0-compatible .vsix files. Microsoft provides a cross-platform command-line interface (CLI) to package your extension.
Once you have thetfx-cli, go to your extension's home directory, and run the following command:
tfx extension create --manifest-globs vss-extension.json
tfx extension create --manifest-globs vss-extension.json
Note
An extension or integration's version must be incremented on every update.
When you're updating an existing extension, either update the version in the manifest or pass the--rev-versioncommand line switch. This  increments thepatchversion number of your extension and saves the new version to your manifest.
You must rev both the task version and extension version for an update to occur.tfx extension create --manifest-globs vss-extension.json --rev-versiononly updates the extension version and not the task version. For more information, seeBuild Task in GitHub.
--rev-version
tfx extension create --manifest-globs vss-extension.json --rev-version
Once your packaged extension is in a .vsix file, you're ready to publish your extension to the Marketplace.

5. Publish your extension
To publish your extension, firstcreate your publisher, thenupload your extension, and finallyshare it.
Create your publisher
All extensions, including extensions from Microsoft, are identified as being provided by a publisher.
If you aren't already a member of an existing publisher, you create one.
Sign in to theVisual Studio Marketplace Publishing Portal.
Sign in to theVisual Studio Marketplace Publishing Portal.
If you aren't already a member of an existing publisher, you're prompted to create a publisher. If you're not prompted to create a publisher, scroll down to the bottom of the page and selectPublish extensionsunderRelated Sites.Specify an identifier for your publisher, for example:mycompany-myteam.This identifier is used as the value for thepublisherattribute in your extensions' manifest file.Specify a display name for your publisher, for example:My Team.
If you aren't already a member of an existing publisher, you're prompted to create a publisher. If you're not prompted to create a publisher, scroll down to the bottom of the page and selectPublish extensionsunderRelated Sites.
Specify an identifier for your publisher, for example:mycompany-myteam.This identifier is used as the value for thepublisherattribute in your extensions' manifest file.
mycompany-myteam
This identifier is used as the value for thepublisherattribute in your extensions' manifest file.
publisher
Specify a display name for your publisher, for example:My Team.
My Team
Review theMarketplace Publisher Agreementand selectCreate.
Review theMarketplace Publisher Agreementand selectCreate.
Your publisher is defined. In a future release, you can grant permissions to view and manage your publisher's extensions.
It's easier and more secure to publish extensions under a common publisher, without the need to share a set of credentials across users.
Upload your extension
Find theUpload new extensionbutton, go to your packaged .vsix file, and selectUpload.
You can also upload your extension via the command-line interface (CLI) by using thetfx extension publishcommand instead oftfx extension createto package and publish your extension in one step. You can optionally use--share-withto share your extension with one or more accounts after it gets published.tfx extension publish --manifest-globs your-manifest.json --share-with yourOrganization
You can also upload your extension via the command-line interface (CLI) by using thetfx extension publishcommand instead oftfx extension createto package and publish your extension in one step. You can optionally use--share-withto share your extension with one or more accounts after it gets published.
tfx extension publish
tfx extension create
--share-with
tfx extension publish --manifest-globs your-manifest.json --share-with yourOrganization
tfx extension publish --manifest-globs your-manifest.json --share-with yourOrganization
Create a personal access token (PAT).Select theMarketplace (publish)scope. This scope limits the token to only being able to publish extensions to the Marketplace.
Create a personal access token (PAT).
Select theMarketplace (publish)scope. This scope limits the token to only being able to publish extensions to the Marketplace.
Share your extension
Now that you uploaded your extension, it's in the Marketplace, but no one can see it.
Share it with your organization so that you can install and test it.
Right-select your extension and selectShare, and enter your organization information. You can share it with other accounts that you want to have access to your extension, too.
Important
Publishers must be verified to share extensions publicly. For more information, seePackage/Publish/Install.
After your extension is shared in the Marketplace, anyone who wants to use it must install it.

6. Create a build and release pipeline to publish the extension to Marketplace
To maintain the custom task on the Marketplace, create a build and release pipeline on Azure DevOps.
Prerequisites to publish
An Azure DevOps project.Create a project.
An Azure DevOps project.Create a project.
Azure DevOps Extension Tasks extension.Install it for freein your organization.
Azure DevOps Extension Tasks extension.Install it for freein your organization.
Pipeline library variable group. Create a pipeline library variable group to hold the variables used by the pipeline. For more information, seeAdd and use variable groups. You can make variable groups from the Azure DevOps Library tab or through the CLI.Use the variableswithin this group in your pipeline. Also, declare the following variables in the variable group:publisherId: ID of your marketplace publisherextensionId: ID of your extension, as declared in the vss-extension.json fileextensionName: Name of your extension, as declared in the vss-extension.json fileartifactName: Name of the artifact being created for the VSIX file
Pipeline library variable group. Create a pipeline library variable group to hold the variables used by the pipeline. For more information, seeAdd and use variable groups. You can make variable groups from the Azure DevOps Library tab or through the CLI.Use the variableswithin this group in your pipeline. Also, declare the following variables in the variable group:
publisherId: ID of your marketplace publisher
publisherId
extensionId: ID of your extension, as declared in the vss-extension.json file
extensionId
extensionName: Name of your extension, as declared in the vss-extension.json file
extensionName
artifactName: Name of the artifact being created for the VSIX file
artifactName
Service connection. Create a new Marketplace service connection and grant access permissions for all pipelines.
Service connection. Create a new Marketplace service connection and grant access permissions for all pipelines.
YAML pipeline. Use the following example to create a new pipeline with YAML. For more information, seeCreate your first pipelineandYAML schema.trigger: 
    - main
    pool:
      vmImage: "ubuntu-latest"
    variables:
      - group: variable-group # Rename to whatever you named your variable group in the prerequisite stage of step 6
    stages:
      - stage: Run_and_publish_unit_tests
        jobs:
          - job:
            steps:
              - task: TfxInstaller@4
                inputs:
                  version: "v0.x"
              - task: Npm@1
                inputs:
                  command: 'install'
                  workingDir: '/TaskDirectory' # Update to the name of the directory of your task
              - task: Bash@3
                displayName: Compile Javascript
                inputs:
                  targetType: "inline"
                  script: |
                    cd TaskDirectory # Update to the name of the directory of your task
                    tsc
              - task: Npm@1
                inputs:
                  command: 'custom'
                  workingDir: '/TestsDirectory' # Update to the name of the directory of your task's tests
                  customCommand: 'testScript' # See the definition in the explanation section below - it may be called test
              - task: PublishTestResults@2
                inputs:
                  testResultsFormat: 'JUnit'
                  testResultsFiles: '**/ResultsFile.xml'
      - stage: Package_extension_and_publish_build_artifacts
        jobs:
          - job:
            steps:
              - task: TfxInstaller@4
                inputs:
                  version: "0.x"
              - task: Npm@1
                inputs:
                  command: 'install'
                  workingDir: '/TaskDirectory' # Update to the name of the directory of your task
              - task: Bash@3
                displayName: Compile Javascript
                inputs:
                  targetType: "inline"
                  script: |
                    cd TaskDirectory # Update to the name of the directory of your task
                    tsc
              - task: QueryAzureDevOpsExtensionVersion@4
                name: QueryVersion
                inputs:
                  connectTo: 'VsTeam'
                  connectedServiceName: 'ServiceConnection' # Change to whatever you named the service connection
                  publisherId: '$(PublisherID)'
                  extensionId: '$(ExtensionID)'
                  versionAction: 'Patch'
              - task: PackageAzureDevOpsExtension@4
                inputs:
                  rootFolder: '$(System.DefaultWorkingDirectory)'
                  publisherId: '$(PublisherID)'
                  extensionId: '$(ExtensionID)'
                  extensionName: '$(ExtensionName)'
                  extensionVersion: '$(QueryVersion.Extension.Version)'
                  updateTasksVersion: true
                  updateTasksVersionType: 'patch'
                  extensionVisibility: 'private' # Change to public if you're publishing to the marketplace
                  extensionPricing: 'free'
              - task: CopyFiles@2
                displayName: "Copy Files to: $(Build.ArtifactStagingDirectory)"
                inputs:
                  Contents: "**/*.vsix"
                  TargetFolder: "$(Build.ArtifactStagingDirectory)"
              - task: PublishBuildArtifacts@1
                inputs:
                  PathtoPublish: '$(Build.ArtifactStagingDirectory)'
                  ArtifactName: '$(ArtifactName)'
                  publishLocation: 'Container'
      - stage: Download_build_artifacts_and_publish_the_extension
        jobs:
          - job:
            steps:
              - task: TfxInstaller@4
                inputs:
                  version: "v0.x"
              - task: DownloadBuildArtifacts@0
                inputs:
                  buildType: "current"
                  downloadType: "single"
                  artifactName: "$(ArtifactName)"
                  downloadPath: "$(System.DefaultWorkingDirectory)"
              - task: PublishAzureDevOpsExtension@4
                inputs:
                  connectTo: 'VsTeam'
                  connectedServiceName: 'ServiceConnection' # Change to whatever you named the service connection
                  fileType: 'vsix'
                  vsixFile: '$(PublisherID).$(ExtensionName)/$(PublisherID)..vsix'
                  publisherId: '$(PublisherID)'
                  extensionId: '$(ExtensionID)'
                  extensionName: '$(ExtensionName)'
                  updateTasksVersion: false
                  extensionVisibility: 'private' # Change to public if you're publishing to the marketplace
                  extensionPricing: 'free'
YAML pipeline. Use the following example to create a new pipeline with YAML. For more information, seeCreate your first pipelineandYAML schema.
trigger: 
    - main
    pool:
      vmImage: "ubuntu-latest"
    variables:
      - group: variable-group # Rename to whatever you named your variable group in the prerequisite stage of step 6
    stages:
      - stage: Run_and_publish_unit_tests
        jobs:
          - job:
            steps:
              - task: TfxInstaller@4
                inputs:
                  version: "v0.x"
              - task: Npm@1
                inputs:
                  command: 'install'
                  workingDir: '/TaskDirectory' # Update to the name of the directory of your task
              - task: Bash@3
                displayName: Compile Javascript
                inputs:
                  targetType: "inline"
                  script: |
                    cd TaskDirectory # Update to the name of the directory of your task
                    tsc
              - task: Npm@1
                inputs:
                  command: 'custom'
                  workingDir: '/TestsDirectory' # Update to the name of the directory of your task's tests
                  customCommand: 'testScript' # See the definition in the explanation section below - it may be called test
              - task: PublishTestResults@2
                inputs:
                  testResultsFormat: 'JUnit'
                  testResultsFiles: '**/ResultsFile.xml'
      - stage: Package_extension_and_publish_build_artifacts
        jobs:
          - job:
            steps:
              - task: TfxInstaller@4
                inputs:
                  version: "0.x"
              - task: Npm@1
                inputs:
                  command: 'install'
                  workingDir: '/TaskDirectory' # Update to the name of the directory of your task
              - task: Bash@3
                displayName: Compile Javascript
                inputs:
                  targetType: "inline"
                  script: |
                    cd TaskDirectory # Update to the name of the directory of your task
                    tsc
              - task: QueryAzureDevOpsExtensionVersion@4
                name: QueryVersion
                inputs:
                  connectTo: 'VsTeam'
                  connectedServiceName: 'ServiceConnection' # Change to whatever you named the service connection
                  publisherId: '$(PublisherID)'
                  extensionId: '$(ExtensionID)'
                  versionAction: 'Patch'
              - task: PackageAzureDevOpsExtension@4
                inputs:
                  rootFolder: '$(System.DefaultWorkingDirectory)'
                  publisherId: '$(PublisherID)'
                  extensionId: '$(ExtensionID)'
                  extensionName: '$(ExtensionName)'
                  extensionVersion: '$(QueryVersion.Extension.Version)'
                  updateTasksVersion: true
                  updateTasksVersionType: 'patch'
                  extensionVisibility: 'private' # Change to public if you're publishing to the marketplace
                  extensionPricing: 'free'
              - task: CopyFiles@2
                displayName: "Copy Files to: $(Build.ArtifactStagingDirectory)"
                inputs:
                  Contents: "**/*.vsix"
                  TargetFolder: "$(Build.ArtifactStagingDirectory)"
              - task: PublishBuildArtifacts@1
                inputs:
                  PathtoPublish: '$(Build.ArtifactStagingDirectory)'
                  ArtifactName: '$(ArtifactName)'
                  publishLocation: 'Container'
      - stage: Download_build_artifacts_and_publish_the_extension
        jobs:
          - job:
            steps:
              - task: TfxInstaller@4
                inputs:
                  version: "v0.x"
              - task: DownloadBuildArtifacts@0
                inputs:
                  buildType: "current"
                  downloadType: "single"
                  artifactName: "$(ArtifactName)"
                  downloadPath: "$(System.DefaultWorkingDirectory)"
              - task: PublishAzureDevOpsExtension@4
                inputs:
                  connectTo: 'VsTeam'
                  connectedServiceName: 'ServiceConnection' # Change to whatever you named the service connection
                  fileType: 'vsix'
                  vsixFile: '$(PublisherID).$(ExtensionName)/$(PublisherID)..vsix'
                  publisherId: '$(PublisherID)'
                  extensionId: '$(ExtensionID)'
                  extensionName: '$(ExtensionName)'
                  updateTasksVersion: false
                  extensionVisibility: 'private' # Change to public if you're publishing to the marketplace
                  extensionPricing: 'free'
trigger: 
    - main
    pool:
      vmImage: "ubuntu-latest"
    variables:
      - group: variable-group # Rename to whatever you named your variable group in the prerequisite stage of step 6
    stages:
      - stage: Run_and_publish_unit_tests
        jobs:
          - job:
            steps:
              - task: TfxInstaller@4
                inputs:
                  version: "v0.x"
              - task: Npm@1
                inputs:
                  command: 'install'
                  workingDir: '/TaskDirectory' # Update to the name of the directory of your task
              - task: Bash@3
                displayName: Compile Javascript
                inputs:
                  targetType: "inline"
                  script: |
                    cd TaskDirectory # Update to the name of the directory of your task
                    tsc
              - task: Npm@1
                inputs:
                  command: 'custom'
                  workingDir: '/TestsDirectory' # Update to the name of the directory of your task's tests
                  customCommand: 'testScript' # See the definition in the explanation section below - it may be called test
              - task: PublishTestResults@2
                inputs:
                  testResultsFormat: 'JUnit'
                  testResultsFiles: '**/ResultsFile.xml'
      - stage: Package_extension_and_publish_build_artifacts
        jobs:
          - job:
            steps:
              - task: TfxInstaller@4
                inputs:
                  version: "0.x"
              - task: Npm@1
                inputs:
                  command: 'install'
                  workingDir: '/TaskDirectory' # Update to the name of the directory of your task
              - task: Bash@3
                displayName: Compile Javascript
                inputs:
                  targetType: "inline"
                  script: |
                    cd TaskDirectory # Update to the name of the directory of your task
                    tsc
              - task: QueryAzureDevOpsExtensionVersion@4
                name: QueryVersion
                inputs:
                  connectTo: 'VsTeam'
                  connectedServiceName: 'ServiceConnection' # Change to whatever you named the service connection
                  publisherId: '$(PublisherID)'
                  extensionId: '$(ExtensionID)'
                  versionAction: 'Patch'
              - task: PackageAzureDevOpsExtension@4
                inputs:
                  rootFolder: '$(System.DefaultWorkingDirectory)'
                  publisherId: '$(PublisherID)'
                  extensionId: '$(ExtensionID)'
                  extensionName: '$(ExtensionName)'
                  extensionVersion: '$(QueryVersion.Extension.Version)'
                  updateTasksVersion: true
                  updateTasksVersionType: 'patch'
                  extensionVisibility: 'private' # Change to public if you're publishing to the marketplace
                  extensionPricing: 'free'
              - task: CopyFiles@2
                displayName: "Copy Files to: $(Build.ArtifactStagingDirectory)"
                inputs:
                  Contents: "**/*.vsix"
                  TargetFolder: "$(Build.ArtifactStagingDirectory)"
              - task: PublishBuildArtifacts@1
                inputs:
                  PathtoPublish: '$(Build.ArtifactStagingDirectory)'
                  ArtifactName: '$(ArtifactName)'
                  publishLocation: 'Container'
      - stage: Download_build_artifacts_and_publish_the_extension
        jobs:
          - job:
            steps:
              - task: TfxInstaller@4
                inputs:
                  version: "v0.x"
              - task: DownloadBuildArtifacts@0
                inputs:
                  buildType: "current"
                  downloadType: "single"
                  artifactName: "$(ArtifactName)"
                  downloadPath: "$(System.DefaultWorkingDirectory)"
              - task: PublishAzureDevOpsExtension@4
                inputs:
                  connectTo: 'VsTeam'
                  connectedServiceName: 'ServiceConnection' # Change to whatever you named the service connection
                  fileType: 'vsix'
                  vsixFile: '$(PublisherID).$(ExtensionName)/$(PublisherID)..vsix'
                  publisherId: '$(PublisherID)'
                  extensionId: '$(ExtensionID)'
                  extensionName: '$(ExtensionName)'
                  updateTasksVersion: false
                  extensionVisibility: 'private' # Change to public if you're publishing to the marketplace
                  extensionPricing: 'free'
For more information, seeSpecify events that trigger pipelines.
Note
Each job uses a new user agent and requires dependencies to be installed.
Pipeline stages
The following section helps you understand how the pipeline stages work.
This stage runs unit tests and publishes test results to Azure DevOps.
To run unit tests, add a custom script to thepackage.jsonfile like the following example.
package.json
"scripts": {
    "testScript": "mocha ./TestFile --reporter xunit --reporter-option output=ResultsFile.xml"
},
"scripts": {
    "testScript": "mocha ./TestFile --reporter xunit --reporter-option output=ResultsFile.xml"
},
AddUse Node CLI for Azure DevOps (tfx-cli)to install the tfx-cli onto your build agent.
AddUse Node CLI for Azure DevOps (tfx-cli)to install the tfx-cli onto your build agent.
Add thenpmtask with theinstallcommand and target the folder with thepackage.jsonfile.
Add thenpmtask with theinstallcommand and target the folder with thepackage.jsonfile.
npm
install
package.json
Add theBashtask to compile the TypeScript into JavaScript.
Add theBashtask to compile the TypeScript into JavaScript.
Bash
Add thenpmtask with thecustomcommand, target the folder that contains the unit tests, and inputtestScriptas the command. Use the following inputs:Command:customWorking folder that contains package.json:/TestsDirectoryCommand and arguments:testScript
Add thenpmtask with thecustomcommand, target the folder that contains the unit tests, and inputtestScriptas the command. Use the following inputs:
npm
custom
testScript
Command:custom
custom
Working folder that contains package.json:/TestsDirectory
/TestsDirectory
Command and arguments:testScript
testScript
Add thePublish Test Resultstask. If you're using the Mocha XUnit reporter, ensure that the result format isJUnitand notXUnit. Set the search folder to the root directory. Use the following inputs:Test result format:JUnitTest results files:**/ResultsFile.xmlSearch folder:$(System.DefaultWorkingDirectory)After the test results get published, the output under the tests tab should look like the following example.
Add thePublish Test Resultstask. If you're using the Mocha XUnit reporter, ensure that the result format isJUnitand notXUnit. Set the search folder to the root directory. Use the following inputs:
JUnit
XUnit
Test result format:JUnit
JUnit
Test results files:**/ResultsFile.xml
**/ResultsFile.xml
Search folder:$(System.DefaultWorkingDirectory)
$(System.DefaultWorkingDirectory)
After the test results get published, the output under the tests tab should look like the following example.

AddUse Node CLI for Azure DevOps (tfx-cli)to install the tfx-cli onto your build agent.
AddUse Node CLI for Azure DevOps (tfx-cli)to install the tfx-cli onto your build agent.
Add thenpmtask with theinstallcommand and target the folder with thepackage.jsonfile.
Add thenpmtask with theinstallcommand and target the folder with thepackage.jsonfile.
npm
install
package.json
Add theBashtask to compile the TypeScript into JavaScript.
Add theBashtask to compile the TypeScript into JavaScript.
Bash
To query the existing version, add theQuery Extension Versiontask using the following inputs:Connect to: Visual Studio MarketplaceVisual Studio Marketplace (Service connection): Service ConnectionPublisher ID: ID of your Visual Studio Marketplace publisherExtension ID: ID of your extension in thevss-extension.jsonfileIncrease version: PatchOutput Variable:Task.Extension.Version
To query the existing version, add theQuery Extension Versiontask using the following inputs:
Connect to: Visual Studio Marketplace
Visual Studio Marketplace (Service connection): Service Connection
Publisher ID: ID of your Visual Studio Marketplace publisher
Extension ID: ID of your extension in thevss-extension.jsonfile
vss-extension.json
Increase version: Patch
Output Variable:Task.Extension.Version
Task.Extension.Version
To package the extensions based on manifest Json, add thePackage Extensiontask using the following inputs:Root manifests folder: Points to root directory that contains manifest file. For example,$(System.DefaultWorkingDirectory)is the root directoryManifest file:vss-extension.jsonPublisher ID: ID of your Visual Studio Marketplace publisherExtension ID: ID of your extension in thevss-extension.jsonfileExtension Name: Name of your extension in thevss-extension.jsonfileExtension Version:$(Task.Extension.Version)Override tasks version: checked (true)Override Type: Replace Only Patch (1.0.r)Extension Visibility: If the extension is still in development, set the value toprivate. To release the extension to the public, set the value topublic.
To package the extensions based on manifest Json, add thePackage Extensiontask using the following inputs:
Root manifests folder: Points to root directory that contains manifest file. For example,$(System.DefaultWorkingDirectory)is the root directory
$(System.DefaultWorkingDirectory)
Manifest file:vss-extension.json
vss-extension.json
Publisher ID: ID of your Visual Studio Marketplace publisher
Extension ID: ID of your extension in thevss-extension.jsonfile
vss-extension.json
Extension Name: Name of your extension in thevss-extension.jsonfile
vss-extension.json
Extension Version:$(Task.Extension.Version)
$(Task.Extension.Version)
Override tasks version: checked (true)
Override Type: Replace Only Patch (1.0.r)
Extension Visibility: If the extension is still in development, set the value toprivate. To release the extension to the public, set the value topublic.
To copy to published files, add theCopy filestask using the following inputs:Contents: All of the files to be copied for publishing them as an artifactTarget folder: The folder that the files get copied toFor example:$(Build.ArtifactStagingDirectory)
To copy to published files, add theCopy filestask using the following inputs:
Contents: All of the files to be copied for publishing them as an artifact
Target folder: The folder that the files get copied toFor example:$(Build.ArtifactStagingDirectory)
For example:$(Build.ArtifactStagingDirectory)
$(Build.ArtifactStagingDirectory)
AddPublish build artifactsto publish the artifacts for use in other jobs or pipelines. Use the following inputs:Path to publish: The path to the folder that contains the files that are being publishedFor example:$(Build.ArtifactStagingDirectory)Artifact name: The name given to the artifactArtifacts publish location: ChooseAzure Pipelinesto use the artifact in future jobs
AddPublish build artifactsto publish the artifacts for use in other jobs or pipelines. Use the following inputs:
Path to publish: The path to the folder that contains the files that are being publishedFor example:$(Build.ArtifactStagingDirectory)
For example:$(Build.ArtifactStagingDirectory)
$(Build.ArtifactStagingDirectory)
Artifact name: The name given to the artifact
Artifacts publish location: ChooseAzure Pipelinesto use the artifact in future jobs
To install the tfx-cli onto your build agent, addUse Node CLI for Azure DevOps (tfx-cli).
To install the tfx-cli onto your build agent, addUse Node CLI for Azure DevOps (tfx-cli).
To download the artifacts onto a new job, add theDownload build artifactstask using the following inputs:Download artifacts produced by: If you're downloading the artifact on a new job from the same pipeline, selectCurrent build. If you're downloading on a new pipeline, selectSpecific buildDownload type: ChooseSpecific artifactto download all files that were published.Artifact name: The published artifact's nameDestination directory: The folder where the files should be downloaded
To download the artifacts onto a new job, add theDownload build artifactstask using the following inputs:
Download artifacts produced by: If you're downloading the artifact on a new job from the same pipeline, selectCurrent build. If you're downloading on a new pipeline, selectSpecific build
Download type: ChooseSpecific artifactto download all files that were published.
Artifact name: The published artifact's name
Destination directory: The folder where the files should be downloaded
To get thePublish Extensiontask, use the following inputs:Connect to: Visual Studio MarketplaceVisual Studio Marketplace connection: ServiceConnectionInput file type: VSIX fileVSIX file:/Publisher.*.vsixPublisher ID: ID of your Visual Studio Marketplace publisherExtension ID: ID of your extension in thevss-extension.jsonfileExtension Name: Name of your extension in thevss-extension.jsonfileExtension visibility: Either private or public
To get thePublish Extensiontask, use the following inputs:
Connect to: Visual Studio Marketplace
Visual Studio Marketplace connection: ServiceConnection
Input file type: VSIX file
VSIX file:/Publisher.*.vsix
/Publisher.*.vsix
Publisher ID: ID of your Visual Studio Marketplace publisher
Extension ID: ID of your extension in thevss-extension.jsonfile
vss-extension.json
Extension Name: Name of your extension in thevss-extension.jsonfile
vss-extension.json
Extension visibility: Either private or public

Optional: Install and test your extension
Install an extension that's shared with you in just a few steps:
From your organization control panel (https://dev.azure.com/{organization}/_admin), go to the project collection administration page.
https://dev.azure.com/{organization}/_admin
In theExtensionstab, find your extension in theExtensions Shared With Megroup and select the extension link.
Install the extension.
If you can't see theExtensionstab, make sure you're in the control panel (the administration page at the project collection level,https://dev.azure.com/{organization}/_admin) and not the administration page for a project.
https://dev.azure.com/{organization}/_admin
If you don't see theExtensionstab, then extensions aren't enabled for your organization. You can get early access to the extensions feature by joining the Visual Studio Partner Program.
To package and publish Azure DevOps Extensions to the Visual Studio Marketplace, you can downloadAzure DevOps Extension Tasks.
FAQ
See the following frequently asked questions about adding custom build or release tasks in extensions for Azure DevOps.
Q: How can I restrict Azure Pipelines commands usage for task?
You can restrict Azure Pipelines commands usage and variables, which get set by task.
This action could be useful to prevent unrestricted access to variables or vso commands for custom scripts which task executes. We recommend that you set it up for new tasks.
To apply, you might need to add the following statement to yourtask.jsonfile:
task.json
"restrictions": {
  "commands": {
    "mode": "restricted"
  },
  "settableVariables": {
    "allowed": ["variable1", "test*"]
  }
}
"restrictions": {
  "commands": {
    "mode": "restricted"
  },
  "settableVariables": {
    "allowed": ["variable1", "test*"]
  }
}
Ifrestrictedvalue is specified formode, you can only execute the following commands by the task:
restricted
mode
logdetail
logdetail
logissue
logissue
complete
complete
setprogress
setprogress
setsecret
setsecret
setvariable
setvariable
debug
debug
settaskvariable
settaskvariable
prependpath
prependpath
publish
publish
ThesettableVariablesrestrictions allow you to pass in an allowlist of variables, which get set bysetvariableorprependpathcommands. It also allows basic regular expressions. For example, if your allowlist was:['abc', 'test*'], settingabc,test, ortest1as variables with any value or prepending them to the path would succeed, but if you try to set a variable proxy it would warn. Empty list means that no variables get changed by task.
settableVariables
setvariable
prependpath
['abc', 'test*']
abc
test
test1
If either thesettableVariablesorcommandskey is omitted, relevant restriction isn't applied.
settableVariables
commands
The restriction feature is available fromagent version 2.182.1.
Q: How is the cancellation signal handled by a task?
The pipeline agent sendsSIGINTandSIGTERMsignals to the relevant child process. There are no explicit means in thetask libraryto process. For more information, seeAgent jobs cancellation.
SIGINT
SIGTERM
Q: How can I remove the task from project collection?
We don't support the automatic deletion of tasks. Automatic deletion isn't safe and breaks existing pipelines that already use such tasks. But, you can mark tasks as deprecated. To do so,bump the task versionandmark the task as deprecated.
Q: How can I upgrade my custom task to the latest Node?
We recommend upgrading tothe latest Node version. For example information, seeUpgrading tasks to Node 20.
Microsoft Hosted agents and various Azure DevOps Server versions have different life cycles, leading to different Node runner versions being installed depending on where a task is running. To ensure compatibility across agents with different Node runner versions, thetask.jsonfile can include multiple execution sections. In the following example, Azure Pipeline agents with the Node 20 runner use it by default, while agents without it fall back to the Node 10 implementation.
task.json
"execution": {
  "Node10": {
    "target": "bash.js",
    "argumentFormat": ""
  },
  "Node20_1": {
    "target": "bash.js",
    "argumentFormat": ""
  }
}
"execution": {
  "Node10": {
    "target": "bash.js",
    "argumentFormat": ""
  },
  "Node20_1": {
    "target": "bash.js",
    "argumentFormat": ""
  }
}
To upgrade your tasks:
To ensure your code behaves as expected, test your tasks on the various Node runner versions.
To ensure your code behaves as expected, test your tasks on the various Node runner versions.
In your task's execution section, update fromNodeorNode10toNode16orNode20.
In your task's execution section, update fromNodeorNode10toNode16orNode20.
Node
Node10
Node16
Node20
To support older server versions, you should leave theNode/Node10target. Older Azure DevOps Server versions might not have the latest Node runner version included.
To support older server versions, you should leave theNode/Node10target. Older Azure DevOps Server versions might not have the latest Node runner version included.
Node
Node10
You can choose to share the entry point defined in the target or have targets optimized to the Node version used."execution": {
   "Node10": {
     "target": "bash10.js",
     "argumentFormat": ""
   },
   "Node16": {
     "target": "bash16.js",
     "argumentFormat": ""
   },
   "Node20_1": {
     "target": "bash20.js",
     "argumentFormat": ""
   }
}
You can choose to share the entry point defined in the target or have targets optimized to the Node version used.
"execution": {
   "Node10": {
     "target": "bash10.js",
     "argumentFormat": ""
   },
   "Node16": {
     "target": "bash16.js",
     "argumentFormat": ""
   },
   "Node20_1": {
     "target": "bash20.js",
     "argumentFormat": ""
   }
}
"execution": {
   "Node10": {
     "target": "bash10.js",
     "argumentFormat": ""
   },
   "Node16": {
     "target": "bash16.js",
     "argumentFormat": ""
   },
   "Node20_1": {
     "target": "bash20.js",
     "argumentFormat": ""
   }
}
Important
If you don't add support for the Node 20 runner to your custom tasks, they fail on agents installed from thepipelines-agent-*release feed.
pipelines-agent-*
Related content
Extension manifest reference
Integrate custom build pipeline tasks with extensions
Build/Release task examples
Feedback
Was this page helpful?
Additional resources