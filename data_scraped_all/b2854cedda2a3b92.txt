Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Develop Azure Functions locally using Core Tools
Article
2025-02-23
65 contributors
In this article
Azure Functions Core Tools lets you develop and test your functions on your local computer. When you're ready, you can also use Core Tools to deploy your code project to Azure and work with application settings.
You're viewing the C# version of this article. Make sure to select your preferred Functions programming language at the top of the article.
If you want to get started right away, complete theCore Tools quickstart article.
You're viewing the Java version of this article. Make sure to select your preferred Functions programming language at the top of the article.
If you want to get started right away, complete theCore Tools quickstart article.
You're viewing the JavaScript version of this article. Make sure to select your preferred Functions programming language at the top of the article.
If you want to get started right away, complete theCore Tools quickstart article.
You're viewing the PowerShell version of this article. Make sure to select your preferred Functions programming language at the top of the article.
If you want to get started right away, complete theCore Tools quickstart article.
You're viewing the Python version of this article. Make sure to select your preferred Functions programming language at the top of the article.
If you want to get started right away, complete theCore Tools quickstart article.
You're viewing the TypeScript version of this article. Make sure to select your preferred Functions programming language at the top of the article.
If you want to get started right away, complete theCore Tools quickstart article.
Install the Azure Functions Core Tools
The recommended way to install Core Tools depends on the operating system of your local development computer.
Windows
macOS
Linux
The following steps use a Windows installer (MSI) to install Core Tools v4.x. For more information about other package-based installers, see theCore Tools readme.
Download and run the Core Tools installer, based on your version of Windows:
v4.x - Windows 64-bit(Recommended.Visual Studio Code debuggingrequires 64-bit.)
v4.x - Windows 32-bit
If you previously used Windows installer (MSI) to install Core Tools on Windows, you should uninstall the old version from Add Remove Programs before installing the latest version.
The following steps use Homebrew to install the Core Tools on macOS.
InstallHomebrew, if it's not already installed.
InstallHomebrew, if it's not already installed.
Install the Core Tools package:brew tap azure/functions
brew install azure-functions-core-tools@4
# if upgrading on a machine that has 2.x or 3.x installed:
brew link --overwrite azure-functions-core-tools@4
Install the Core Tools package:
brew tap azure/functions
brew install azure-functions-core-tools@4
# if upgrading on a machine that has 2.x or 3.x installed:
brew link --overwrite azure-functions-core-tools@4
brew tap azure/functions
brew install azure-functions-core-tools@4
# if upgrading on a machine that has 2.x or 3.x installed:
brew link --overwrite azure-functions-core-tools@4
The following steps useAPTto install Core Tools on your Ubuntu/Debian Linux distribution. For other Linux distributions, see theCore Tools readme.
Install the Microsoft package repository GPG key, to validate package integrity:curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > microsoft.gpg
sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg
Install the Microsoft package repository GPG key, to validate package integrity:
curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > microsoft.gpg
sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg
curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > microsoft.gpg
sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg
Set up the APT source list before doing an APT update.Ubuntusudo sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/repos/microsoft-ubuntu-$(lsb_release -cs 2>/dev/null)-prod $(lsb_release -cs 2>/dev/null) main" > /etc/apt/sources.list.d/dotnetdev.list'Debiansudo sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/debian/$(lsb_release -rs 2>/dev/null | cut -d'.' -f 1)/prod $(lsb_release -cs 2>/dev/null) main" > /etc/apt/sources.list.d/dotnetdev.list'
Set up the APT source list before doing an APT update.
sudo sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/repos/microsoft-ubuntu-$(lsb_release -cs 2>/dev/null)-prod $(lsb_release -cs 2>/dev/null) main" > /etc/apt/sources.list.d/dotnetdev.list'
sudo sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/repos/microsoft-ubuntu-$(lsb_release -cs 2>/dev/null)-prod $(lsb_release -cs 2>/dev/null) main" > /etc/apt/sources.list.d/dotnetdev.list'
sudo sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/debian/$(lsb_release -rs 2>/dev/null | cut -d'.' -f 1)/prod $(lsb_release -cs 2>/dev/null) main" > /etc/apt/sources.list.d/dotnetdev.list'
sudo sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/debian/$(lsb_release -rs 2>/dev/null | cut -d'.' -f 1)/prod $(lsb_release -cs 2>/dev/null) main" > /etc/apt/sources.list.d/dotnetdev.list'
Check the/etc/apt/sources.list.d/dotnetdev.listfile for one of the appropriate Linux version strings in the following table:Linux distributionVersionDebian 12bookwormDebian 11bullseyeDebian 10busterDebian 9stretchUbuntu 24.04nobleUbuntu 22.04jammyUbuntu 20.04focalUbuntu 19.04discoUbuntu 18.10cosmicUbuntu 18.04bionicUbuntu 17.04zestyUbuntu 16.04/Linux Mint 18xenial
Check the/etc/apt/sources.list.d/dotnetdev.listfile for one of the appropriate Linux version strings in the following table:
/etc/apt/sources.list.d/dotnetdev.list
bookworm
bullseye
buster
stretch
noble
jammy
focal
disco
cosmic
bionic
zesty
xenial
Start the APT source update:sudo apt-get update
Start the APT source update:
sudo apt-get update
sudo apt-get update
Install the Core Tools package:sudo apt-get install azure-functions-core-tools-4
Install the Core Tools package:
sudo apt-get install azure-functions-core-tools-4
sudo apt-get install azure-functions-core-tools-4
For help with version-related issues, seeCore Tools versions.
Create your local project
Important
For Python, you must run Core Tools commands in a virtual environment. For more information, seeQuickstart: Create a Python function in Azure from the command line.
In the terminal window or from a command prompt, run the following command to create a project in theMyProjFolderfolder:
MyProjFolder
Isolated worker model
In-process model
func init MyProjFolder --worker-runtime dotnet-isolated
func init MyProjFolder --worker-runtime dotnet-isolated
By default this command creates a project that runs in-process with the Functions host on the currentLong-Term Support (LTS) version of .NET Core. You can use the--target-frameworkoption to target a specific supported version of .NET, including .NET Framework. For more information, see thefunc initreference.
--target-framework
func init
func init MyProjFolder --worker-runtime dotnet
func init MyProjFolder --worker-runtime dotnet
This command creates a project that runs on the currentLong-Term Support (LTS) version of .NET Core. For other .NET version, create an app that runs in an isolated worker process from the Functions host.
For a comparison between the two .NET process models, see theprocess mode comparison article.
Java uses a Maven archetype to create the local project, along with your first HTTP triggered function. Rather than usingfunc initandfunc new, you should instead follow the steps in theCommand line quickstart.
func init
func new
v4
v3
func init MyProjFolder --worker-runtime javascript --model V4
func init MyProjFolder --worker-runtime javascript --model V4
func init MyProjFolder --worker-runtime javascript --model V3
func init MyProjFolder --worker-runtime javascript --model V3
This command creates a JavaScript project that uses the desiredprogramming model version.
v4
v3
func init MyProjFolder --worker-runtime typescript --model V4
func init MyProjFolder --worker-runtime typescript --model V4
func init MyProjFolder --worker-runtime typescript --model V3
func init MyProjFolder --worker-runtime typescript --model V3
This command creates a TypeScript project that uses the desiredprogramming model version.
func init MyProjFolder --worker-runtime powershell
func init MyProjFolder --worker-runtime powershell
v2
v1
func init MyProjFolder --worker-runtime python --model V2
func init MyProjFolder --worker-runtime python --model V2
func init MyProjFolder --worker-runtime python
func init MyProjFolder --worker-runtime python
This command creates a Python project that uses the desiredprogramming model version.
When you runfunc initwithout the--worker-runtimeoption, you're prompted to choose your project language. To learn more about the available options for thefunc initcommand, see thefunc initreference.
func init
--worker-runtime
func init
func init
Create a function
To add a function to your project, run thefunc newcommand using the--templateoption to select your trigger template. The following example creates an HTTP trigger namedMyHttpTrigger:
func new
--template
MyHttpTrigger
func new --template "Http Trigger" --name MyHttpTrigger
func new --template "Http Trigger" --name MyHttpTrigger
This example creates a Queue Storage trigger namedMyQueueTrigger:
MyQueueTrigger
func new --template "Azure Queue Storage Trigger" --name MyQueueTrigger
func new --template "Azure Queue Storage Trigger" --name MyQueueTrigger
The following considerations apply when adding functions:
When you runfunc newwithout the--templateoption, you're prompted to choose a template.
When you runfunc newwithout the--templateoption, you're prompted to choose a template.
func new
--template
Use thefunc templates listcommand to see the complete list of available templates for your language.
Use thefunc templates listcommand to see the complete list of available templates for your language.
func templates list
When you add a trigger that connects to a service, you'll also need to add an application setting that references a connection string or a managed identity to the local.settings.json file. Using app settings in this way prevents you from having to embed credentials in your code. For more information, seeWork with app settings locally.
When you add a trigger that connects to a service, you'll also need to add an application setting that references a connection string or a managed identity to the local.settings.json file. Using app settings in this way prevents you from having to embed credentials in your code. For more information, seeWork with app settings locally.
Core Tools also adds a reference to the specific binding extension to your C# project.
To learn more about the available options for thefunc newcommand, see thefunc newreference.
func new
func new
Add a binding to your function
Functions provides a set of service-specific input and output bindings, which make it easier for your function to connection to other Azure services without having to use the service-specific client SDKs. For more information, seeAzure Functions triggers and bindings concepts.
To add an input or output binding to an existing function, you must manually update the function definition.
The following example shows the function definition after adding aQueue Storage output bindingto anHTTP triggered function:
Isolated process
In-process
Because an HTTP triggered function also returns an HTTP response, the function returns aMultiResponseobject, which represents both the HTTP and queue output.
MultiResponse
[Function("HttpExample")]
public static MultiResponse Run([HttpTrigger(AuthorizationLevel.Function, "get", "post")] HttpRequest req,
    FunctionContext executionContext)
{
[Function("HttpExample")]
public static MultiResponse Run([HttpTrigger(AuthorizationLevel.Function, "get", "post")] HttpRequest req,
    FunctionContext executionContext)
{
This example is the definition of theMultiResponseobject that includes the output binding:
MultiResponse
public class MultiResponse
{
    [QueueOutput("outqueue",Connection = "AzureWebJobsStorage")]
    public string[] Messages { get; set; }
    public IActionResult HttpResponse { get; set; }
}
public class MultiResponse
{
    [QueueOutput("outqueue",Connection = "AzureWebJobsStorage")]
    public string[] Messages { get; set; }
    public IActionResult HttpResponse { get; set; }
}
When applying that example to your own project, you might need to changeHttpRequesttoHttpRequestDataandIActionResulttoHttpResponseData, depending on if you are usingASP.NET Core integrationor not.
HttpRequest
HttpRequestData
IActionResult
HttpResponseData
[FunctionName("HttpExample")]
public static async Task<IActionResult> Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req, 
    [Queue("outqueue"),StorageAccount("AzureWebJobsStorage")] ICollector<string> msg, 
    ILogger log)
[FunctionName("HttpExample")]
public static async Task<IActionResult> Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req, 
    [Queue("outqueue"),StorageAccount("AzureWebJobsStorage")] ICollector<string> msg, 
    ILogger log)
Messages are sent to the queue when the function completes. The way you define the output binding depends on your process model. For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
@FunctionName("HttpExample")
public HttpResponseMessage run(
        @HttpTrigger(name = "req", methods = {HttpMethod.GET, HttpMethod.POST}, authLevel = AuthorizationLevel.ANONYMOUS) 
        HttpRequestMessage<Optional<String>> request, 
        @QueueOutput(name = "msg", queueName = "outqueue", 
        connection = "AzureWebJobsStorage") OutputBinding<String> msg, 
        final ExecutionContext context) {
@FunctionName("HttpExample")
public HttpResponseMessage run(
        @HttpTrigger(name = "req", methods = {HttpMethod.GET, HttpMethod.POST}, authLevel = AuthorizationLevel.ANONYMOUS) 
        HttpRequestMessage<Optional<String>> request, 
        @QueueOutput(name = "msg", queueName = "outqueue", 
        connection = "AzureWebJobsStorage") OutputBinding<String> msg, 
        final ExecutionContext context) {
For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
v4
v3
Example binding for Node.js model v4 not yet available.
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "queue",
      "direction": "out",
      "name": "msg",
      "queueName": "outqueue",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "queue",
      "direction": "out",
      "name": "msg",
      "queueName": "outqueue",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
The way you define the output binding depends on the version of your Node.js model. For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
$outputMsg = $name
Push-OutputBinding -name msg -Value $outputMsg
$outputMsg = $name
Push-OutputBinding -name msg -Value $outputMsg
For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
v2
v1
@app.route(route="HttpExample")
@app.queue_output(arg_name="msg", queue_name="outqueue", connection="AzureWebJobsStorage")
def HttpExample(req: func.HttpRequest, msg: func.Out [func.QueueMessage]) -> func.HttpResponse:
    logging.info('Python HTTP trigger function processed a request.')
@app.route(route="HttpExample")
@app.queue_output(arg_name="msg", queue_name="outqueue", connection="AzureWebJobsStorage")
def HttpExample(req: func.HttpRequest, msg: func.Out [func.QueueMessage]) -> func.HttpResponse:
    logging.info('Python HTTP trigger function processed a request.')
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "queue",
      "direction": "out",
      "name": "msg",
      "queueName": "outqueue",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "queue",
      "direction": "out",
      "name": "msg",
      "queueName": "outqueue",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
The way you define the output binding depends on the version of your Python model. For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
v4
v3
Example binding for Node.js model v4 not yet available.
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "queue",
      "direction": "out",
      "name": "msg",
      "queueName": "outqueue",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "queue",
      "direction": "out",
      "name": "msg",
      "queueName": "outqueue",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
The way you define the output binding depends on the version of your Node.js model. For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
The following considerations apply when adding bindings to a function:
For languages that define functions using thefunction.jsonconfiguration file, Visual Studio Code simplifies the process of  adding bindings to an existing function definition. For more information, seeConnect functions to Azure services using bindings.
When you add bindings that connect to a service, you must also add an application setting that references a connection string or managed identity to the local.settings.json file. For more information, seeWork with app settings locally.
When you add a supported binding, the extension should already be installed when your app uses extension bundle. For more information, seeextension bundles.
When you add a binding that requires a new binding extension, you must also add a reference to that specific binding extension in your C# project.
For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
For more information, including links to example binding code that you can refer to, seeAdd bindings to a function.
Start the Functions runtime
Before you can run or debug the functions in your project, you need to start the Functions host from the root directory of your project. The host enables triggers for all functions in the project. Use this command to start the local runtime:
mvn clean package 
mvn azure-functions:run
mvn clean package 
mvn azure-functions:run
Isolated worker model
In-process model
func start
func start
func start
func start
Important
Starting with version 4.0.6517 of the Core Tools, in-process model projects must referenceversion 4.5.0 or later ofMicrosoft.NET.Sdk.Functions. If an earlier version is used, thefunc startcommand will error.
Microsoft.NET.Sdk.Functions
func start
func start
func start
npm install
npm start
npm install
npm start
This command must berun in a virtual environment.
When the Functions host starts, it outputs a list of functions in the project, including the URLs of any HTTP-triggered functions, like in this example:
Found the following functions:
Host.Functions.MyHttpTrigger

Job host started
Http Function MyHttpTrigger: http://localhost:7071/api/MyHttpTrigger
How your functions are loaded depends on your project configuration. To learn more, seeRegistering a function.
Keep in mind the following considerations when running your functions locally:
By default, authorization isn't enforced locally for HTTP endpoints. This means that all local HTTP requests are handled asauthLevel = "anonymous". For more information, seeAuthorization level. You can use the--enableAuthoption to require authorization when running locally. For more information, seefunc start
By default, authorization isn't enforced locally for HTTP endpoints. This means that all local HTTP requests are handled asauthLevel = "anonymous". For more information, seeAuthorization level. You can use the--enableAuthoption to require authorization when running locally. For more information, seefunc start
authLevel = "anonymous"
--enableAuth
func start
You can use the local Azurite emulator when locally running functions that require access to Azure Storage services (Queue Storage, Blob Storage, and Table Storage) without having to connect to these services in Azure. When using local emulation, make sure to start Azurite before starting the local host (func.exe). For more information, seeLocal storage emulation.
You can use the local Azurite emulator when locally running functions that require access to Azure Storage services (Queue Storage, Blob Storage, and Table Storage) without having to connect to these services in Azure. When using local emulation, make sure to start Azurite before starting the local host (func.exe). For more information, seeLocal storage emulation.
You can use local Azurite emulation to meet the storage requirement of the Python v2 worker.
You can trigger non-HTTP functions locally without connecting to a live service. For more information, seeRun a local function.
You can trigger non-HTTP functions locally without connecting to a live service. For more information, seeRun a local function.
When you include your Application Insights connection information in the local.settings.json file, local log data is written to the specific Application Insights instance. To keep local telemetry data separate from production data, consider using a separate Application Insights instance for development and testing.
When you include your Application Insights connection information in the local.settings.json file, local log data is written to the specific Application Insights instance. To keep local telemetry data separate from production data, consider using a separate Application Insights instance for development and testing.
When using version 1.x of the Core Tools, instead use thefunc host startcommand to start the local runtime.
func host start
Run a local function
With your local Functions host (func.exe) running, you can now trigger individual functions to run and debug your function code. The way in which you execute an individual function depends on its trigger type.
Note
Examples in this topic use the cURL tool to send HTTP requests from the terminal or a command prompt. You can use a tool of your choice to send HTTP requests to the local server. The cURL tool is available by default on Linux-based systems and Windows 10 build 17063 and later. On older Windows, you must first download and install thecURL tool.
HTTP trigger
Non-HTTP trigger
Event Grid trigger
HTTP triggers are started by sending an HTTP request to the local endpoint and port as displayed in the func.exe output, which has this general format:
http://localhost:<PORT>/api/<FUNCTION_NAME>
http://localhost:<PORT>/api/<FUNCTION_NAME>
In this URL template,<FUNCTION_NAME>is the name of the function or route and<PORT>is the local port on which func.exe is listening.
<FUNCTION_NAME>
<PORT>
For example, this cURL command triggers theMyHttpTriggerquickstart function from a GET request with thenameparameter passed in the query string:
MyHttpTrigger
curl --get http://localhost:7071/api/MyHttpTrigger?name=Azure%20Rocks
curl --get http://localhost:7071/api/MyHttpTrigger?name=Azure%20Rocks
This example is the same function called from a POST request passingnamein the request body, shown for both Bash shell and Windows command line:
curl --request POST http://localhost:7071/api/MyHttpTrigger --data '{"name":"Azure Rocks"}'
curl --request POST http://localhost:7071/api/MyHttpTrigger --data '{"name":"Azure Rocks"}'
curl --request POST http://localhost:7071/api/MyHttpTrigger --data "{'name':'Azure Rocks'}"
curl --request POST http://localhost:7071/api/MyHttpTrigger --data "{'name':'Azure Rocks'}"
The following considerations apply when calling HTTP endpoints locally:
You can make GET requests from a browser passing data in the query string. For all other HTTP methods, you must use an HTTP testing tool that also keeps your data secure. For more information, seeHTTP test tools.
You can make GET requests from a browser passing data in the query string. For all other HTTP methods, you must use an HTTP testing tool that also keeps your data secure. For more information, seeHTTP test tools.
Make sure to use the same server name and port that the Functions host is listening on. You see an endpoint like this in the output generated when starting the Function host. You can call this URL using any HTTP method supported by the trigger.
Make sure to use the same server name and port that the Functions host is listening on. You see an endpoint like this in the output generated when starting the Function host. You can call this URL using any HTTP method supported by the trigger.
There are two ways to execute non-HTTP triggers locally. First, you can connect to live Azure services, such as Azure Storage and Azure Service Bus. This directly mirrors the behavior of your function when running in Azure. When using live services, make sure to include the required named connection strings in thelocal settings file. You may consider using a different service connection during development than you do in production by using a different connection string in the local.settings.json file than you use in the function app settings in Azure.
Event Grid triggers require extra configuration to run locally.
You can also run a non-HTTP function locally using REST by calling a special endpoint called anadministrator endpoint. Use this format to call theadminendpoint and trigger a specific non-HTTP function:
admin
http://localhost:<PORT>/admin/functions/<FUNCTION_NAME>
http://localhost:<PORT>/admin/functions/<FUNCTION_NAME>
In this URL template,<FUNCTION_NAME>is the name of the function or route and<PORT>is the local port on which func.exe is listening.
<FUNCTION_NAME>
<PORT>
You can optionally pass test data to the execution in the body of the POST request. To pass test data, you must supply the data in the body of a POST request message, which has this JSON format:
{
    "input": "<TRIGGER_INPUT>"
}
{
    "input": "<TRIGGER_INPUT>"
}
The<TRIGGER_INPUT>value contains data in a format expected by the function. This cURL example is shown for both Bash shell and Windows command line:
<TRIGGER_INPUT>
curl --request POST -H "Content-Type:application/json" --data '{"input":"sample queue data"}' http://localhost:7071/admin/functions/QueueTrigger
curl --request POST -H "Content-Type:application/json" --data '{"input":"sample queue data"}' http://localhost:7071/admin/functions/QueueTrigger
curl --request POST -H "Content-Type:application/json" --data "{'input':'sample queue data'}" http://localhost:7071/admin/functions/QueueTrigger
curl --request POST -H "Content-Type:application/json" --data "{'input':'sample queue data'}" http://localhost:7071/admin/functions/QueueTrigger
The previous examples generate a POST request that passes a stringsample queue datato a function namedQueueTriggerfunction, which simulates data arriving in the queue and triggering the function
sample queue data
QueueTrigger
The following considerations apply when using the administrator endpoint for local testing:
You can call thefunctionsadministrator endpoint (http://localhost:{port}/admin/functions/) to return a list of administrator URLs for all available functions, both HTTP triggered and non-HTTP triggered.
You can call thefunctionsadministrator endpoint (http://localhost:{port}/admin/functions/) to return a list of administrator URLs for all available functions, both HTTP triggered and non-HTTP triggered.
functions
http://localhost:{port}/admin/functions/
Authentication and authorization are bypassed when running locally. The same APIs exist in Azure, but when you try to call the same administrator endpoints in Azure, you must provide an access key. To learn more, seeWork with access keys.
Authentication and authorization are bypassed when running locally. The same APIs exist in Azure, but when you try to call the same administrator endpoints in Azure, you must provide an access key. To learn more, seeWork with access keys.
Access keys are valuable shared secrets. When used locally, they must be securely stored outside of source control. Because authentication and authorization aren't required by Functions when running locally, you should avoid using and storing access keys unless your scenarios require it.
Access keys are valuable shared secrets. When used locally, they must be securely stored outside of source control. Because authentication and authorization aren't required by Functions when running locally, you should avoid using and storing access keys unless your scenarios require it.
Calling an administrator endpoint and passing test data is similar to using theTesttab in the Azure portal.
Calling an administrator endpoint and passing test data is similar to using theTesttab in the Azure portal.
Event Grid triggers have specific requirements to enable local testing. For more information, seeLocal testing with viewer web app.
Publish to Azure
The Azure Functions Core Tools supports three types of deployment:
func azure functionapp publish
func azurecontainerapps deploy
func kubernetes deploy
You must have either theAzure CLIorAzure PowerShellinstalled locally to be able to publish to Azure from Core Tools. By default, Core Tools uses these tools to authenticate with your Azure account.
If you don't have these tools installed, you need to insteadget a valid access tokento use during deployment. You can present an access token using the--access-tokenoption in the deployment commands.
--access-token
Deploy project files
To publish your local code to a function app in Azure, use thefunc azure functionapp publishcommand, as in the following example:
func azure functionapp publish
func azure functionapp publish <FunctionAppName>
func azure functionapp publish <FunctionAppName>
This command publishes project files from the current directory to the<FunctionAppName>as a .zip deployment package. If the project requires compilation, it's done remotely during deployment.
<FunctionAppName>
Java uses Maven to publish your local project to Azure instead of Core Tools. Use the following Maven command to publish your project to Azure:
mvn azure-functions:deploy
mvn azure-functions:deploy
When you run this command, Azure resources are created during the initial deployment based on the settings in yourpom.xmlfile. For more information, seeDeploy the function project to Azure.
The following considerations apply to this kind of deployment:
Publishing overwrites existing files in the remote function app deployment.
Publishing overwrites existing files in the remote function app deployment.
You must have alreadycreated a function app in your Azure subscription. Core Tools deploys your project code to this function app resource. To learn how to create a function app from the command prompt or terminal window using the Azure CLI or Azure PowerShell, seeCreate a Function App for serverless execution. You can alsocreate these resources in the Azure portal. You get an error when you try to publish to a<FunctionAppName>that doesn't exist in your subscription.
You must have alreadycreated a function app in your Azure subscription. Core Tools deploys your project code to this function app resource. To learn how to create a function app from the command prompt or terminal window using the Azure CLI or Azure PowerShell, seeCreate a Function App for serverless execution. You can alsocreate these resources in the Azure portal. You get an error when you try to publish to a<FunctionAppName>that doesn't exist in your subscription.
<FunctionAppName>
A project folder may contain language-specific files and directories that shouldn't be published. Excluded items are listed in a .funcignore file in the root project folder.
A project folder may contain language-specific files and directories that shouldn't be published. Excluded items are listed in a .funcignore file in the root project folder.
By default, your project is deployed so that itruns from the deployment package. To disable this recommended deployment mode, use the--nozipoption.
By default, your project is deployed so that itruns from the deployment package. To disable this recommended deployment mode, use the--nozipoption.
--nozip
Aremote buildis performed on compiled projects. This can be controlled by using the--no-buildoption.
Aremote buildis performed on compiled projects. This can be controlled by using the--no-buildoption.
--no-build
Use the--publish-local-settingsoption to automatically create app settings in your function app based on values in the local.settings.json file.
Use the--publish-local-settingsoption to automatically create app settings in your function app based on values in the local.settings.json file.
--publish-local-settings
To publish to a specific named slot in your function app, use the--slotoption.
To publish to a specific named slot in your function app, use the--slotoption.
--slot
Deploy containers
Core Tools lets you deploy yourcontainerized function appto both managed Azure Container Apps environments and Kubernetes clusters that you manage.
Container Apps
Kubernetes cluster
Use the followingfunc azurecontainerapps deploycommand to deploy an existing container image to a Container Apps environment:
func azurecontainerapps deploy
func azurecontainerapps deploy --name <APP_NAME> --environment <ENVIRONMENT_NAME> --storage-account <STORAGE_CONNECTION> --resource-group <RESOURCE_GROUP> --image-name <IMAGE_NAME> [--registry-password] [--registry-server] [--registry-username]
func azurecontainerapps deploy --name <APP_NAME> --environment <ENVIRONMENT_NAME> --storage-account <STORAGE_CONNECTION> --resource-group <RESOURCE_GROUP> --image-name <IMAGE_NAME> [--registry-password] [--registry-server] [--registry-username]
When you deploy to an Azure Container Apps environment, the following considerations apply:
The environment and storage account must already exist. The storage account connection string you provide is used by the deployed function app.
The environment and storage account must already exist. The storage account connection string you provide is used by the deployed function app.
You don't need to create a separate function app resource when deploying to Container Apps.
You don't need to create a separate function app resource when deploying to Container Apps.
Storage connection strings and other service credentials are important secrets. Make sure to securely store any script files usingfunc azurecontainerapps deployand don't store them in any publicly accessible source control systems. You canencrypt the local.settings.json filefor added security.
Storage connection strings and other service credentials are important secrets. Make sure to securely store any script files usingfunc azurecontainerapps deployand don't store them in any publicly accessible source control systems. You canencrypt the local.settings.json filefor added security.
func azurecontainerapps deploy
For more information, seeAzure Container Apps hosting of Azure Functions.
The followingfunc kubernetes deploycommand uses the Dockerfile to generate a container in the specified registry and deploy it to the default Kubernetes cluster.
func kubernetes deploy
func kubernetes deploy --name <DEPLOYMENT_NAME> --registry <REGISTRY_USERNAME>
func kubernetes deploy --name <DEPLOYMENT_NAME> --registry <REGISTRY_USERNAME>
Azure Functions on Kubernetes using KEDA is an open-source effort that you can use free of cost. Best-effort support is provided by contributors and from the community. To learn more, seeDeploying a function app to Kubernetes.
Work with app settings locally
When running in a function app in Azure, settings required by your functions arestored securely in app settings. During local development, these settings are instead added to theValuescollection in thelocal.settings.jsonfile. The local.settings.json file also stores settings used by local development tools.
Values
Items in theValuescollection in your project'slocal.settings.jsonfile are intended to mirror items in your function app'sapplication settingsin Azure.
Values
The following considerations apply when working with the local settings file:
Because the local.settings.json may contain secrets, such as connection strings, you should never store it in a remote repository. Core Tools helps you encrypt this local settings file for improved security. For more information, seeLocal settings file. You can alsoencrypt the local.settings.json filefor added security.
Because the local.settings.json may contain secrets, such as connection strings, you should never store it in a remote repository. Core Tools helps you encrypt this local settings file for improved security. For more information, seeLocal settings file. You can alsoencrypt the local.settings.json filefor added security.
By default, local settings aren't migrated automatically when the project is published to Azure. Use the--publish-local-settingsoption when you publish your project files to make sure these settings are added to the function app in Azure. Values in theConnectionStringssection are never published. You can alsoupload settings from the local.settings.json fileat any time.
By default, local settings aren't migrated automatically when the project is published to Azure. Use the--publish-local-settingsoption when you publish your project files to make sure these settings are added to the function app in Azure. Values in theConnectionStringssection are never published. You can alsoupload settings from the local.settings.json fileat any time.
--publish-local-settings
ConnectionStrings
You can download and overwrite settings in your local.settings.json file with settings from your function app in Azure. For more information, seeDownload application settings.
You can download and overwrite settings in your local.settings.json file with settings from your function app in Azure. For more information, seeDownload application settings.
The function app settings values can also be read in your code as environment variables. For more information, seeEnvironment variables.
The function app settings values can also be read in your code as environment variables. For more information, seeEnvironment variables.
The function app settings values can also be read in your code as environment variables. For more information, seeEnvironment variables.
The function app settings values can also be read in your code as environment variables. For more information, seeEnvironment variables.
The function app settings values can also be read in your code as environment variables. For more information, seeEnvironment variables.
When no valid storage connection string is set forAzureWebJobsStorageand a local storage emulator isn't being used, an error is shown. You can use Core Tools todownload a specific connection stringfrom any of your Azure Storage accounts.
AzureWebJobsStorage
Download application settings
From the project root, use the following command to download all application settings from themyfunctionapp12345app in Azure:
myfunctionapp12345
func azure functionapp fetch-app-settings myfunctionapp12345
func azure functionapp fetch-app-settings myfunctionapp12345
This command overwrites any existing settings in the local.settings.json file with values from Azure. When not already present, new items are added to the collection. For more information, see thefunc azure functionapp fetch-app-settingscommand.
func azure functionapp fetch-app-settings
Download a storage connection string
Core Tools also make it easy to get the connection string of any storage account to which you have access. From the project root, use the following command to download the connection string from a storage account namedmystorage12345.
mystorage12345
func azure storage fetch-connection-string mystorage12345
func azure storage fetch-connection-string mystorage12345
This command adds a setting namedmystorage12345_STORAGEto the local.settings.json file, which contains the connection string for themystorage12345account. For more information, see thefunc azure storage fetch-connection-stringcommand.
mystorage12345_STORAGE
mystorage12345
func azure storage fetch-connection-string
For improved security during development, considerencrypting the local.settings.json file.
Upload local settings to Azure
When you publish your project files to Azure without using the--publish-local-settingsoption, settings in the local.settings.json file aren't set in your function app. You can always rerun thefunc azure functionapp publishwith the--publish-settings-onlyoption to upload just the settings without republishing the project files.
--publish-local-settings
func azure functionapp publish
--publish-settings-only
The following example uploads just settings from theValuescollection in the local.settings.json file to the function app in Azure namedmyfunctionapp12345:
Values
myfunctionapp12345
func azure functionapp publish myfunctionapp12345 --publish-settings-only
func azure functionapp publish myfunctionapp12345 --publish-settings-only
Encrypt the local settings file
To improve security of connection strings and other valuable data in your local settings, Core Tools lets you encrypt the local.settings.json file. When this file is encrypted, the runtime automatically decrypts the settings when needed the same way it does with application setting in Azure. You can also decrypt a locally encrypted file to work with the settings.
Use the following command to encrypt the local settings file for the project:
func settings encrypt
func settings encrypt
Use the following command to decrypt an encrypted local setting, so that you can work with it:
func settings decrypt
func settings decrypt
When the settings file is encrypted and decrypted, the file'sIsEncryptedsetting also gets updated.
IsEncrypted
Configure binding extensions
Functions triggers and bindingsare implemented as .NET extension (NuGet) packages. To be able to use a specific binding extension, that extension must be installed in the project.
This section doesn't apply to version 1.x of the Functions runtime. In version 1.x, supported bindings were included in the core product extension.
For C# class library projects, add references to the specific NuGet packages for the binding extensions required by your functions. C# script (.csx) project must useextension bundles.
Functions providesextension bundlesto make is easy to work with binding extensions in your project. Extension bundles, which are versioned and defined in the host.json file, install a complete set of compatible binding extension packages for your app. Your host.json should already have extension bundles enabled. If for some reason you need to add or update the extension bundle in the host.json file, seeExtension bundles.
If you must use a binding extension or an extension version not in a supported bundle, you need to manually install extensions. For such rare scenarios, see thefunc extensions installcommand.
func extensions install
Core Tools versions
Major versions of Azure Functions Core Tools are linked to specific major versions of the Azure Functions runtime. For example, version 4.x of Core Tools supports version 4.x of the Functions runtime. This version is the recommended major version of both the Functions runtime and Core Tools. You can determine the latest release version of Core Tools in theAzure Functions Core Tools repository.
Starting with version 4.0.6517 of the Core Tools, in-process model projects must referenceversion 4.5.0 or later ofMicrosoft.NET.Sdk.Functions. If an earlier version is used, thefunc startcommand will error.
Microsoft.NET.Sdk.Functions
func start
Run the following command to determine the version of your current Core Tools installation:
func --version
func --version
Unless otherwise noted, the examples in this article are for version 4.x.
The following considerations apply to Core Tools installations:
You can only install one version of Core Tools on a given computer.
You can only install one version of Core Tools on a given computer.
When upgrading to the latest version of Core Tools, you should use the same method that you used for original installation to perform the upgrade. For example, if you used an MSI on Windows, uninstall the current MSI and install the latest one. Or if you used npm, rerun thenpm  install command.
When upgrading to the latest version of Core Tools, you should use the same method that you used for original installation to perform the upgrade. For example, if you used an MSI on Windows, uninstall the current MSI and install the latest one. Or if you used npm, rerun thenpm  install command.
npm  install command
Version 2.x and 3.x of Core Tools were used with versions 2.x and 3.x of the Functions runtime, which have reached their end of support. For more information, seeAzure Functions runtime versions overview.
Version 2.x and 3.x of Core Tools were used with versions 2.x and 3.x of the Functions runtime, which have reached their end of support. For more information, seeAzure Functions runtime versions overview.
Version 1.x of Core Tools is required when using version 1.x of the Functions Runtime, which is still supported. This version of Core Tools can only be run locally on Windows computers. If you're currently running on version 1.x, you should considermigrating your app to version 4.xtoday.
Next steps
Learn how todevelop, test, and publish Azure functions by using Azure Functions core tools. Azure Functions Core Tools isopen source and hosted on GitHub. To file a bug or feature request,open a GitHub issue.
Feedback
Was this page helpful?
Additional resources