Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Migrate C# apps from the in-process model to the isolated worker model
Article
2025-04-04
7 contributors
In this article
Important
Support for the in-process model ends on November 10, 2026. We highly recommend that you migrate your apps to the isolated worker model by following the instructions in this article.
This article walks you through the process of safely migrating your .NET function app from thein-process modelto theisolated worker model. To learn about the high-level differences between these models, see theexecution mode comparison.
This guide assumes that your app is running on version 4.x of the Functions runtime. If not, you should use the following guides to upgrade your host version. These host-version migration guides also help you migrate to the isolated worker model as you work through them.
Migrate apps from Azure Functions version 2.x and 3.x to version 4.x
Migrate apps from Azure Functions version 1.x to version 4.x
When supported, this article takes advantage ofASP.NET Core integrationin the isolated worker model, which improves performance and provides a familiar programming model when your app uses HTTP triggers.
Identify function apps to migrate
Use the following Azure PowerShell script to generate a list of function apps in your subscription that currently use the in-process model.
The script uses the subscription that Azure PowerShell is currently configured to use. You can change the subscription by first runningSet-AzContext -Subscription '<YOUR SUBSCRIPTION ID>'and replacing<YOUR SUBSCRIPTION ID>with the ID of the subscription you would like to evaluate.
Set-AzContext -Subscription '<YOUR SUBSCRIPTION ID>'
<YOUR SUBSCRIPTION ID>
$FunctionApps = Get-AzFunctionApp

$AppInfo = @{}

foreach ($App in $FunctionApps)
{
     if ($App.Runtime -eq 'dotnet')
     {
          $AppInfo.Add($App.Name, $App.Runtime)
     }
}

$AppInfo
$FunctionApps = Get-AzFunctionApp

$AppInfo = @{}

foreach ($App in $FunctionApps)
{
     if ($App.Runtime -eq 'dotnet')
     {
          $AppInfo.Add($App.Name, $App.Runtime)
     }
}

$AppInfo
Choose your target .NET version
On version 4.x of the Functions runtime, your .NET function app targets .NET 6 or .NET 8 when using the in-process model.
When you migrate your function app, you have the opportunity to choose the target version of .NET. You can update your C# project to one of the following versions of .NET that are supported by Functions version 4.x:
1Theisolated worker modelsupports Long Term Support (LTS) and Standard Term Support (STS) versions of .NET, as well as .NET Framework. Thein-process modelonly supports LTS releases of .NET, ending with .NET 8. For a full feature and functionality comparison between the two models, seeDifferences between in-process and isolate worker process .NET Azure Functions.
2Support ends for the in-process model on November 10, 2026. For more information, seethis support announcement. For continued full support, you shouldmigrate your apps to the isolated worker model.
Tip
We recommend upgrading to .NET 8 on the isolated worker model.This provides a quick migration path to the fully released version with the longest support window from .NET.
This guide doesn't present specific examples for .NET 9. If you need to target that version, you can adapt the .NET 8 examples.
Prepare for migration
Before you migrate an app to the isolated worker model, you should thoroughly review the contents of this guide. You should also familiarize yourself with the features of theisolated worker modeland thedifferences between the two models.
To migrate the application:
Migrate your local project to the isolated worker model by following the steps inMigrate your local project.
After migrating your project, fully test the app locally using version 4.x of theAzure Functions Core Tools.
Update your function app in Azureto the isolated model.
Migrate your local project
The section outlines the various changes that you need to make to your local project to move it to the isolated worker model. Some of the steps change based on your target version of .NET. Use the tabs to select the instructions that match your desired version.
Tip
If you're moving to an LTS or STS version of .NET, the.NET Upgrade Assistantcan be used to automatically make many of the changes mentioned in the following sections.
First, convert the project file and update your dependencies. As you do, you see build errors for the project. In subsequent steps, you'll make the corresponding changes to remove these errors.
Project file
The following example is a.csprojproject file that uses .NET 8 on version 4.x:
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <AzureFunctionsVersion>v4</AzureFunctionsVersion>
    <RootNamespace>My.Namespace</RootNamespace>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Sdk.Functions" Version="4.1.1" />
  </ItemGroup>
  <ItemGroup>
    <None Update="host.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Update="local.settings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <CopyToPublishDirectory>Never</CopyToPublishDirectory>
    </None>
  </ItemGroup>
</Project>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <AzureFunctionsVersion>v4</AzureFunctionsVersion>
    <RootNamespace>My.Namespace</RootNamespace>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Sdk.Functions" Version="4.1.1" />
  </ItemGroup>
  <ItemGroup>
    <None Update="host.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Update="local.settings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <CopyToPublishDirectory>Never</CopyToPublishDirectory>
    </None>
  </ItemGroup>
</Project>
Use one of the following procedures to update this XML file to run in the isolated worker model:
.NET 8
.NET Framework 4.8
These steps assume a local C# project; if your app instead uses C# script (.csxfiles), you shouldconvert to the project modelbefore continuing.
The following changes are required in the.csprojXML project file:
Set the value ofPropertyGroup.TargetFrameworktonet8.0.
Set the value ofPropertyGroup.TargetFrameworktonet8.0.
PropertyGroup
TargetFramework
net8.0
Set the value ofPropertyGroup.AzureFunctionsVersiontov4.
Set the value ofPropertyGroup.AzureFunctionsVersiontov4.
PropertyGroup
AzureFunctionsVersion
v4
Add the followingOutputTypeelement to thePropertyGroup:<OutputType>Exe</OutputType>
Add the followingOutputTypeelement to thePropertyGroup:
OutputType
PropertyGroup
<OutputType>Exe</OutputType>
<OutputType>Exe</OutputType>
In theItemGroup.PackageReferencelist, replace the package reference toMicrosoft.NET.Sdk.Functionswith the following references:<FrameworkReference Include="Microsoft.AspNetCore.App" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker" Version="1.21.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="1.17.2" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore" Version="1.2.1" />
  <PackageReference Include="Microsoft.ApplicationInsights.WorkerService" Version="2.22.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.ApplicationInsights" Version="1.2.0" />Make note of any references to other packages in theMicrosoft.Azure.WebJobs.*namespaces. You'll replace these packages in a later step.
In theItemGroup.PackageReferencelist, replace the package reference toMicrosoft.NET.Sdk.Functionswith the following references:
ItemGroup
PackageReference
Microsoft.NET.Sdk.Functions
<FrameworkReference Include="Microsoft.AspNetCore.App" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker" Version="1.21.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="1.17.2" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore" Version="1.2.1" />
  <PackageReference Include="Microsoft.ApplicationInsights.WorkerService" Version="2.22.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.ApplicationInsights" Version="1.2.0" />
<FrameworkReference Include="Microsoft.AspNetCore.App" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker" Version="1.21.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="1.17.2" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore" Version="1.2.1" />
  <PackageReference Include="Microsoft.ApplicationInsights.WorkerService" Version="2.22.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.ApplicationInsights" Version="1.2.0" />
Make note of any references to other packages in theMicrosoft.Azure.WebJobs.*namespaces. You'll replace these packages in a later step.
Microsoft.Azure.WebJobs.*
Add the following newItemGroup:<ItemGroup>
  <Using Include="System.Threading.ExecutionContext" Alias="ExecutionContext"/>
</ItemGroup>
Add the following newItemGroup:
ItemGroup
<ItemGroup>
  <Using Include="System.Threading.ExecutionContext" Alias="ExecutionContext"/>
</ItemGroup>
<ItemGroup>
  <Using Include="System.Threading.ExecutionContext" Alias="ExecutionContext"/>
</ItemGroup>
After you make these changes, your updated project should look like the following example:
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <AzureFunctionsVersion>v4</AzureFunctionsVersion>
    <RootNamespace>My.Namespace</RootNamespace>
    <OutputType>Exe</OutputType>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
    <PackageReference Include="Microsoft.Azure.Functions.Worker" Version="1.21.0" />
    <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="1.17.2" />
    <PackageReference Include="Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore" Version="1.2.1" />
    <PackageReference Include="Microsoft.ApplicationInsights.WorkerService" Version="2.22.0" />
    <PackageReference Include="Microsoft.Azure.Functions.Worker.ApplicationInsights" Version="1.2.0" />
    <!-- Other packages may also be in this list -->
  </ItemGroup>
  <ItemGroup>
    <None Update="host.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Update="local.settings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <CopyToPublishDirectory>Never</CopyToPublishDirectory>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Using Include="System.Threading.ExecutionContext" Alias="ExecutionContext"/>
  </ItemGroup>
</Project>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <AzureFunctionsVersion>v4</AzureFunctionsVersion>
    <RootNamespace>My.Namespace</RootNamespace>
    <OutputType>Exe</OutputType>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
    <PackageReference Include="Microsoft.Azure.Functions.Worker" Version="1.21.0" />
    <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="1.17.2" />
    <PackageReference Include="Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore" Version="1.2.1" />
    <PackageReference Include="Microsoft.ApplicationInsights.WorkerService" Version="2.22.0" />
    <PackageReference Include="Microsoft.Azure.Functions.Worker.ApplicationInsights" Version="1.2.0" />
    <!-- Other packages may also be in this list -->
  </ItemGroup>
  <ItemGroup>
    <None Update="host.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Update="local.settings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <CopyToPublishDirectory>Never</CopyToPublishDirectory>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Using Include="System.Threading.ExecutionContext" Alias="ExecutionContext"/>
  </ItemGroup>
</Project>
These steps assume a local C# project; if your app instead uses C# script (.csxfiles), you shouldconvert to the project modelbefore continuing.
The following changes are required in the.csprojXML project file:
Set the value ofPropertyGroup.TargetFrameworktonet48.
Set the value ofPropertyGroup.TargetFrameworktonet48.
PropertyGroup
TargetFramework
net48
Set the value ofPropertyGroup.AzureFunctionsVersiontov4.
Set the value ofPropertyGroup.AzureFunctionsVersiontov4.
PropertyGroup
AzureFunctionsVersion
v4
Add the followingOutputTypeelement to thePropertyGroup:<OutputType>Exe</OutputType>
Add the followingOutputTypeelement to thePropertyGroup:
OutputType
PropertyGroup
<OutputType>Exe</OutputType>
<OutputType>Exe</OutputType>
In theItemGroup.PackageReferencelist, replace the package reference toMicrosoft.NET.Sdk.Functionswith the following references:<PackageReference Include="Microsoft.Azure.Functions.Worker" Version="1.21.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="1.16.4" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Extensions.Http" Version="3.1.0" />
  <PackageReference Include="Microsoft.ApplicationInsights.WorkerService" Version="2.22.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.ApplicationInsights" Version="1.2.0" />Make note of any references to other packages in theMicrosoft.Azure.WebJobs.*namespaces. You'll replace these packages in a later step.
In theItemGroup.PackageReferencelist, replace the package reference toMicrosoft.NET.Sdk.Functionswith the following references:
ItemGroup
PackageReference
Microsoft.NET.Sdk.Functions
<PackageReference Include="Microsoft.Azure.Functions.Worker" Version="1.21.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="1.16.4" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Extensions.Http" Version="3.1.0" />
  <PackageReference Include="Microsoft.ApplicationInsights.WorkerService" Version="2.22.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.ApplicationInsights" Version="1.2.0" />
<PackageReference Include="Microsoft.Azure.Functions.Worker" Version="1.21.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="1.16.4" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.Extensions.Http" Version="3.1.0" />
  <PackageReference Include="Microsoft.ApplicationInsights.WorkerService" Version="2.22.0" />
  <PackageReference Include="Microsoft.Azure.Functions.Worker.ApplicationInsights" Version="1.2.0" />
Make note of any references to other packages in theMicrosoft.Azure.WebJobs.*namespaces. You'll replace these packages in a later step.
Microsoft.Azure.WebJobs.*
Add the following newItemGroup:<ItemGroup>
  <Folder Include="Properties\" />
</ItemGroup>
Add the following newItemGroup:
ItemGroup
<ItemGroup>
  <Folder Include="Properties\" />
</ItemGroup>
<ItemGroup>
  <Folder Include="Properties\" />
</ItemGroup>
After you make these changes, your updated project should look like the following example:
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net48</TargetFramework>
    <AzureFunctionsVersion>v4</AzureFunctionsVersion>
    <RootNamespace>My.Namespace</RootNamespace>
    <OutputType>Exe</OutputType>
  </PropertyGroup>
  <ItemGroup>
      <PackageReference Include="Microsoft.Azure.Functions.Worker" Version="1.21.0" />
      <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="1.16.4" />
      <PackageReference Include="Microsoft.Azure.Functions.Worker.Extensions.Http" Version="3.1.0" />
      <PackageReference Include="Microsoft.ApplicationInsights.WorkerService" Version="2.22.0" />
      <PackageReference Include="Microsoft.Azure.Functions.Worker.ApplicationInsights" Version="1.2.0" />
    <!-- Other packages may also be in this list -->
  </ItemGroup>
  <ItemGroup>
    <None Update="host.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Update="local.settings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <CopyToPublishDirectory>Never</CopyToPublishDirectory>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Folder Include="Properties\" />
  </ItemGroup>
</Project>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net48</TargetFramework>
    <AzureFunctionsVersion>v4</AzureFunctionsVersion>
    <RootNamespace>My.Namespace</RootNamespace>
    <OutputType>Exe</OutputType>
  </PropertyGroup>
  <ItemGroup>
      <PackageReference Include="Microsoft.Azure.Functions.Worker" Version="1.21.0" />
      <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="1.16.4" />
      <PackageReference Include="Microsoft.Azure.Functions.Worker.Extensions.Http" Version="3.1.0" />
      <PackageReference Include="Microsoft.ApplicationInsights.WorkerService" Version="2.22.0" />
      <PackageReference Include="Microsoft.Azure.Functions.Worker.ApplicationInsights" Version="1.2.0" />
    <!-- Other packages may also be in this list -->
  </ItemGroup>
  <ItemGroup>
    <None Update="host.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Update="local.settings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <CopyToPublishDirectory>Never</CopyToPublishDirectory>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Folder Include="Properties\" />
  </ItemGroup>
</Project>
Changing your project's target framework might also require changes to parts of your toolchain, outside of project code. For example, in VS Code, you might need to update theazureFunctions.deploySubpathextension setting through user settings or your project's.vscode/settings.jsonfile. Check for any dependencies on the framework version that might exist outside of your project code, as part of build steps or a CI/CD pipeline.
azureFunctions.deploySubpath
Package references
When migrating to the isolated worker model, you need to change the packages your application references.
If you haven't already, update your project to reference the latest stable versions of:
Microsoft.Azure.Functions.Worker
Microsoft.Azure.Functions.Worker.Sdk
Depending on the triggers and bindings your app uses, your app might need to reference a different set of packages. The following table shows the replacements for some of the most commonly used extensions:
Microsoft.Azure.WebJobs.Extensions.Storage
Microsoft.Azure.WebJobs.Extensions.Storage.Blobs
Microsoft.Azure.WebJobs.Extensions.Storage.Queues
Microsoft.Azure.WebJobs.Extensions.Tables
Microsoft.Azure.WebJobs.Extensions.CosmosDB
Microsoft.Azure.WebJobs.Extensions.DocumentDB
Microsoft.Azure.WebJobs.Extensions.ServiceBus
Microsoft.Azure.WebJobs.Extensions.EventHubs
Microsoft.Azure.WebJobs.Extensions.EventGrid
Microsoft.Azure.WebJobs.Extensions.SignalRService
Microsoft.Azure.WebJobs.Extensions.DurableTask
Microsoft.DurableTask.SqlServer.AzureFunctions
Microsoft.Azure.DurableTask.Netherite.AzureFunctions
Microsoft.Azure.WebJobs.Extensions.SendGrid
Microsoft.Azure.WebJobs.Extensions.Kafka
Microsoft.Azure.WebJobs.Extensions.RabbitMQ
Microsoft.Azure.Functions.Extensions
SeeSupported bindingsfor a complete list of extensions to consider, and consult each extension's documentation for full installation instructions for the isolated process model. Be sure to install the latest stable version of any packages you are targeting.
Tip
Any changes to extension versions during this process might require you to update yourhost.jsonfile as well. Be sure to read the documentation of each extension that you use.
For example, the Service Bus extension has breaking changes in the structure between versions 4.x and 5.x. For more information, seeAzure Service Bus bindings for Azure Functions.
host.json
Your isolated worker model application should not reference any packages in theMicrosoft.Azure.WebJobs.*namespaces orMicrosoft.Azure.Functions.Extensions.If you have any remaining references to these, they should be removed.
Microsoft.Azure.WebJobs.*
Microsoft.Azure.Functions.Extensions
Tip
Your app might also depend on Azure SDK types, either as part of your triggers and bindings or as a standalone dependency. You should take this opportunity to update these as well. The latest versions of the Functions extensions work with the latest versions of theAzure SDK for .NET, almost all of the packages for which are the formAzure.*.
Azure.*
Program.cs file
When migrating to run in an isolated worker process, you must add aProgram.csfile to your project with the following contents:
.NET 8
.NET Framework 4.8
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

var host = new HostBuilder()
    .ConfigureFunctionsWebApplication()
    .ConfigureServices(services => {
        services.AddApplicationInsightsTelemetryWorkerService();
        services.ConfigureFunctionsApplicationInsights();
    })
    .Build();

host.Run();
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

var host = new HostBuilder()
    .ConfigureFunctionsWebApplication()
    .ConfigureServices(services => {
        services.AddApplicationInsightsTelemetryWorkerService();
        services.ConfigureFunctionsApplicationInsights();
    })
    .Build();

host.Run();
This example includesASP.NET Core integrationto improve performance and provide a familiar programming model when your app uses HTTP triggers. If you don't intend to use HTTP triggers, you can replace the call toConfigureFunctionsWebApplicationwith a call toConfigureFunctionsWorkerDefaults. If you do so, you can remove the reference toMicrosoft.Azure.Functions.Worker.Extensions.Http.AspNetCorefrom your project file. However, for the best performance, even for functions with other trigger types, you should keep theFrameworkReferenceto ASP.NET Core.
ConfigureFunctionsWebApplication
ConfigureFunctionsWorkerDefaults
Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore
FrameworkReference
using Microsoft.Extensions.Hosting;
using Microsoft.Azure.Functions.Worker;

namespace Company.FunctionApp
{
    internal class Program
    {
        static void Main(string[] args)
        {
            FunctionsDebugger.Enable();

            var host = new HostBuilder()
                .ConfigureFunctionsWorkerDefaults()
                .ConfigureServices(services => {
                    services.AddApplicationInsightsTelemetryWorkerService();
                    services.ConfigureFunctionsApplicationInsights();
                })
                .Build();
            host.Run();
        }
    }
}
using Microsoft.Extensions.Hosting;
using Microsoft.Azure.Functions.Worker;

namespace Company.FunctionApp
{
    internal class Program
    {
        static void Main(string[] args)
        {
            FunctionsDebugger.Enable();

            var host = new HostBuilder()
                .ConfigureFunctionsWorkerDefaults()
                .ConfigureServices(services => {
                    services.AddApplicationInsightsTelemetryWorkerService();
                    services.ConfigureFunctionsApplicationInsights();
                })
                .Build();
            host.Run();
        }
    }
}
TheProgram.csfile replaces any file that has theFunctionsStartupattribute, which is typically aStartup.csfile. In places where yourFunctionsStartupcode would referenceIFunctionsHostBuilder.Services, you can instead add statements within the.ConfigureServices()method of theHostBuilderin yourProgram.cs. To learn more about working withProgram.cs, seeStart-up and configurationin the isolated worker model guide.
FunctionsStartup
FunctionsStartup
IFunctionsHostBuilder.Services
.ConfigureServices()
HostBuilder
The defaultProgram.csexamples previously described include setup ofApplication Insights. In yourProgram.cs, you must also configure any log filtering that should apply to logs coming from code in your project. In the isolated worker model, thehost.jsonfile only controls events emitted by the Functions host runtime. If you don't configure filtering rules inProgram.cs, you might see differences in the log levels present for various categories in your telemetry.
Although you can register custom configuration sources as part of theHostBuilder, these similarly apply only to code in your project. The platform also needs trigger and binding configuration, and this should be provided through theapplication settings,Key Vault references, orApp Configuration referencesfeatures.
HostBuilder
After you move everything from any existingFunctionsStartupto theProgram.csfile, you can delete theFunctionsStartupattribute and the class it was applied to.
FunctionsStartup
FunctionsStartup
Function signature changes
Some key types change between the in-process model and the isolated worker model. Many of these relate to the attributes, parameters, and return types that make up the function signature. For each of your functions, you must make changes to:
The function attribute, which also sets the function's name
How the function obtains anILogger/ILogger<T>
ILogger
ILogger<T>
Trigger and binding attributes and parameters
The rest of this section walks you through each of these steps.
TheFunctionattribute in the isolated worker model replaces theFunctionNameattribute. The new attribute has the same signature, and the only difference is in the name. You can therefore just perform a string replacement across your project.
Function
FunctionName
In the in-process model, you could include an optionalILoggerparameter for your function, or you could use dependency injection to get anILogger<T>. If your app already used dependency injection, the same mechanisms work in the isolated worker model.
ILogger
ILogger<T>
However, for any Functions that relied on theILoggermethod parameter, you need to make a change. We recommended that you use dependency injection to obtain anILogger<T>. Use the following steps to migrate the function's logging mechanism:
ILogger
ILogger<T>
In your function class, add aprivate readonly ILogger<MyFunction> _logger;property, replacingMyFunctionwith the name of your function class.
In your function class, add aprivate readonly ILogger<MyFunction> _logger;property, replacingMyFunctionwith the name of your function class.
private readonly ILogger<MyFunction> _logger;
MyFunction
Create a constructor for your function class that takes in theILogger<T>as a parameter:public MyFunction(ILogger<MyFunction> logger) {
    _logger = logger;
}Replace both instances ofMyFunctionin the preceding code snippet with the name of your function class.
Create a constructor for your function class that takes in theILogger<T>as a parameter:
ILogger<T>
public MyFunction(ILogger<MyFunction> logger) {
    _logger = logger;
}
public MyFunction(ILogger<MyFunction> logger) {
    _logger = logger;
}
Replace both instances ofMyFunctionin the preceding code snippet with the name of your function class.
MyFunction
For logging operations in your function code, replace references to theILoggerparameter with_logger.
For logging operations in your function code, replace references to theILoggerparameter with_logger.
ILogger
_logger
Remove theILoggerparameter from your function signature.
Remove theILoggerparameter from your function signature.
ILogger
To learn more, seeLogging in the isolated worker model.
When youchanged your package references in a previous step, you introduced errors for your triggers and bindings that you can now fix:
Remove anyusing Microsoft.Azure.WebJobs;statements.
Remove anyusing Microsoft.Azure.WebJobs;statements.
using Microsoft.Azure.WebJobs;
Add ausing Microsoft.Azure.Functions.Worker;statement.
Add ausing Microsoft.Azure.Functions.Worker;statement.
using Microsoft.Azure.Functions.Worker;
For each binding attribute, change the attribute's name as specified in its reference documentation, which you can find in theSupported bindingsindex. In general, the attribute names change as follows:Triggers typically remain named the same way.For example,QueueTriggeris the attribute name for both models.Input bindings typically needInputadded to their name.For example, if you used theCosmosDBinput binding attribute in the in-process model, the attribute would now beCosmosDBInput.Output bindings typically needOutputadded to their name.For example, if you used theQueueoutput binding attribute in the in-process model, this attribute would now beQueueOutput.
For each binding attribute, change the attribute's name as specified in its reference documentation, which you can find in theSupported bindingsindex. In general, the attribute names change as follows:
Triggers typically remain named the same way.For example,QueueTriggeris the attribute name for both models.
QueueTrigger
Input bindings typically needInputadded to their name.For example, if you used theCosmosDBinput binding attribute in the in-process model, the attribute would now beCosmosDBInput.
Input
CosmosDB
CosmosDBInput
Output bindings typically needOutputadded to their name.For example, if you used theQueueoutput binding attribute in the in-process model, this attribute would now beQueueOutput.
Output
Queue
QueueOutput
Update the attribute parameters to reflect the isolated worker model version, as specified in the binding's reference documentation.For example, in the in-process model, a blob output binding is represented by a[Blob(...)]attribute that includes anAccessproperty. In the isolated worker model, the blob output attribute would be[BlobOutput(...)]. The binding no longer requires theAccessproperty, so that parameter can be removed. So[Blob("sample-images-sm/{fileName}", FileAccess.Write, Connection = "MyStorageConnection")]would become[BlobOutput("sample-images-sm/{fileName}", Connection = "MyStorageConnection")].
Update the attribute parameters to reflect the isolated worker model version, as specified in the binding's reference documentation.
For example, in the in-process model, a blob output binding is represented by a[Blob(...)]attribute that includes anAccessproperty. In the isolated worker model, the blob output attribute would be[BlobOutput(...)]. The binding no longer requires theAccessproperty, so that parameter can be removed. So[Blob("sample-images-sm/{fileName}", FileAccess.Write, Connection = "MyStorageConnection")]would become[BlobOutput("sample-images-sm/{fileName}", Connection = "MyStorageConnection")].
[Blob(...)]
Access
[BlobOutput(...)]
Access
[Blob("sample-images-sm/{fileName}", FileAccess.Write, Connection = "MyStorageConnection")]
[BlobOutput("sample-images-sm/{fileName}", Connection = "MyStorageConnection")]
Move output bindings out of the function parameter list. If you have just one output binding, you can apply this to the return type of the function. If you have multiple outputs, create a new class with properties for each output, and apply the attributes to those properties. To learn more, seeMultiple output bindings.
Move output bindings out of the function parameter list. If you have just one output binding, you can apply this to the return type of the function. If you have multiple outputs, create a new class with properties for each output, and apply the attributes to those properties. To learn more, seeMultiple output bindings.
Consult each binding's reference documentation for the types it allows you to bind to. In some cases, you might need to change the type. For output bindings, if the in-process model version used anIAsyncCollector<T>, you can replace this with binding to an array of the target type:T[]. You can also consider replacing the output binding with a client object for the service it represents, either as the binding type for an input binding if available, or byinjecting a client yourself.
Consult each binding's reference documentation for the types it allows you to bind to. In some cases, you might need to change the type. For output bindings, if the in-process model version used anIAsyncCollector<T>, you can replace this with binding to an array of the target type:T[]. You can also consider replacing the output binding with a client object for the service it represents, either as the binding type for an input binding if available, or byinjecting a client yourself.
IAsyncCollector<T>
T[]
If your function includes anIBinderparameter, remove it. Replace the functionality with a client object for the service it represents, either as the binding type for an input binding if available, or byinjecting a client yourself.
If your function includes anIBinderparameter, remove it. Replace the functionality with a client object for the service it represents, either as the binding type for an input binding if available, or byinjecting a client yourself.
IBinder
Update the function code to work with any new types.
Update the function code to work with any new types.
local.settings.json file
Thelocal.settings.jsonfile is only used when running locally. For information, seeLocal settings file.
When migrating from running in-process to running in an isolated worker process, you need to change theFUNCTIONS_WORKER_RUNTIMEvalue todotnet-isolated. Make sure that yourlocal.settings.jsonfile has at least the following elements:
FUNCTIONS_WORKER_RUNTIME
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet-isolated"
    }
}
{
    "IsEncrypted": false,
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet-isolated"
    }
}
The value you have forAzureWebJobsStoragemight be different. You don't need to change its value as part of the migration.
AzureWebJobsStorage
host.json file
No changes are required to yourhost.jsonfile. However, if your Application Insights configuration is in this file from your in-process model project, you might want to make additional changes in yourProgram.csfile. Thehost.jsonfile only controls logging from the Functions host runtime, and in the isolated worker model, some of these logs come from your application directly, giving you more control. SeeManaging log levels in the isolated worker modelfor details on how to filter these logs.
Other code changes
This section highlights other code changes to consider as you work through the migration. These changes aren't needed by all applications, but you should evaluate if any are relevant to your scenarios.
By default, the isolated worker model usesSystem.Text.Jsonfor JSON serialization. To customize serializer options or switch to JSON.NET (Newtonsoft.Json), seeCustomizing JSON serialization.
Logs can be sent to Application Insights from both the Functions host runtime and code in your project. Thehost.jsonallows you to configure rules for host logging, but to control logs coming from your code, you need to configure filtering rules as part of yourProgram.cs. SeeManaging log levels in the isolated worker modelfor details on how to filter these logs.
Example function migrations
An HTTP trigger for the in-process model might look like the following example:
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.Extensions.Logging;

namespace Company.Function
{
    public static class HttpTriggerCSharp
    {
        [FunctionName("HttpTriggerCSharp")]
        public static IActionResult Run(
            [HttpTrigger(AuthorizationLevel.Function, "get", Route = null)] HttpRequest req,
            ILogger log)
        {
            log.LogInformation("C# HTTP trigger function processed a request.");

            return new OkObjectResult($"Welcome to Azure Functions, {req.Query["name"]}!");
        }
    }
}
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.Extensions.Logging;

namespace Company.Function
{
    public static class HttpTriggerCSharp
    {
        [FunctionName("HttpTriggerCSharp")]
        public static IActionResult Run(
            [HttpTrigger(AuthorizationLevel.Function, "get", Route = null)] HttpRequest req,
            ILogger log)
        {
            log.LogInformation("C# HTTP trigger function processed a request.");

            return new OkObjectResult($"Welcome to Azure Functions, {req.Query["name"]}!");
        }
    }
}
An HTTP trigger for the migrated version might look like the following example:
.NET 8
.NET Framework 4.8
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;

namespace Company.Function
{
    public class HttpTriggerCSharp
    {
        private readonly ILogger<HttpTriggerCSharp> _logger;

        public HttpTriggerCSharp(ILogger<HttpTriggerCSharp> logger)
        {
            _logger = logger;
        }

        [Function("HttpTriggerCSharp")]
        public IActionResult Run(
            [HttpTrigger(AuthorizationLevel.Function, "get")] HttpRequest req)
        {
            _logger.LogInformation("C# HTTP trigger function processed a request.");

            return new OkObjectResult($"Welcome to Azure Functions, {req.Query["name"]}!");
        }
    }
}
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;

namespace Company.Function
{
    public class HttpTriggerCSharp
    {
        private readonly ILogger<HttpTriggerCSharp> _logger;

        public HttpTriggerCSharp(ILogger<HttpTriggerCSharp> logger)
        {
            _logger = logger;
        }

        [Function("HttpTriggerCSharp")]
        public IActionResult Run(
            [HttpTrigger(AuthorizationLevel.Function, "get")] HttpRequest req)
        {
            _logger.LogInformation("C# HTTP trigger function processed a request.");

            return new OkObjectResult($"Welcome to Azure Functions, {req.Query["name"]}!");
        }
    }
}
using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Http;
using Microsoft.Extensions.Logging;
using System.Net;

namespace Company.Function
{
    public class HttpTriggerCSharp
    {
        private readonly ILogger<HttpTriggerCSharp> _logger;

        public HttpTriggerCSharp(ILogger<HttpTriggerCSharp> logger)
        {
            _logger = logger;
        }

        [Function("HttpTriggerCSharp")]
        public HttpResponseData Run([HttpTrigger(AuthorizationLevel.Function, "get")] HttpRequestData req)
        {
            _logger.LogInformation("C# HTTP trigger function processed a request.");

            var response = req.CreateResponse(HttpStatusCode.OK);
            response.Headers.Add("Content-Type", "text/plain; charset=utf-8");

            response.WriteString($"Welcome to Azure Functions, {req.Query["name"]}!");

            return response;
        }
    }
}
using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Http;
using Microsoft.Extensions.Logging;
using System.Net;

namespace Company.Function
{
    public class HttpTriggerCSharp
    {
        private readonly ILogger<HttpTriggerCSharp> _logger;

        public HttpTriggerCSharp(ILogger<HttpTriggerCSharp> logger)
        {
            _logger = logger;
        }

        [Function("HttpTriggerCSharp")]
        public HttpResponseData Run([HttpTrigger(AuthorizationLevel.Function, "get")] HttpRequestData req)
        {
            _logger.LogInformation("C# HTTP trigger function processed a request.");

            var response = req.CreateResponse(HttpStatusCode.OK);
            response.Headers.Add("Content-Type", "text/plain; charset=utf-8");

            response.WriteString($"Welcome to Azure Functions, {req.Query["name"]}!");

            return response;
        }
    }
}
Update your function app in Azure
Updating your function app to the isolated model involves two changes that should be completed together, because if you only complete one, the app is in an error state. Both of these changes also cause the app process to restart. For these reasons, you should perform the update using astaging slot. Staging slots help minimize downtime for your app and allow you to test and verify your migrated code with your updated configuration in Azure. You can then deploy your fully migrated app to the production slot through a swap operation.
Important
When an app's deployed payload doesn't match the configured runtime, it's inan error state. During the migration process, you put the app into this state, ideally only temporarily. Deployment slots help mitigate the effect of this, because the error state will be resolved in your staging (nonproduction) environment before the changes are applied as single update to your production environment. Slots also defend against any mistakes and allow you to detect any other issues before reaching production.
During the process, you might still see errors in logs coming from your staging (nonproduction) slot. This is expected, though these should go away as you proceed through the steps. Before you perform the slot swap operation, you should confirm that these errors stop being raised and that your application is working as expected.
Use the following steps to use deployment slots to update your function app to the isolated worker model:
Create a deployment slotif you haven't already. You might also want to familiarize yourself with the slot swap process and ensure that you can make updates to the existing application with minimal disruption.
Create a deployment slotif you haven't already. You might also want to familiarize yourself with the slot swap process and ensure that you can make updates to the existing application with minimal disruption.
Change the configuration of the staging (nonproduction) slot to use the isolated worker model by setting theFUNCTIONS_WORKER_RUNTIMEapplication setting todotnet-isolated.FUNCTIONS_WORKER_RUNTIMEshouldnotbe marked as aslot setting.If you're also targeting a different version of .NET as part of your update, you should also change the stack configuration. To do so, seeUpdate the stack configuration. You can use the same instructions for any future .NET version updates you make.If you have any automated infrastructure provisioning such as a CI/CD pipeline, make sure that the automations are also updated to keepFUNCTIONS_WORKER_RUNTIMEset todotnet-isolatedand to target the correct .NET version.
Change the configuration of the staging (nonproduction) slot to use the isolated worker model by setting theFUNCTIONS_WORKER_RUNTIMEapplication setting todotnet-isolated.FUNCTIONS_WORKER_RUNTIMEshouldnotbe marked as aslot setting.
FUNCTIONS_WORKER_RUNTIME
dotnet-isolated
FUNCTIONS_WORKER_RUNTIME
If you're also targeting a different version of .NET as part of your update, you should also change the stack configuration. To do so, seeUpdate the stack configuration. You can use the same instructions for any future .NET version updates you make.
If you have any automated infrastructure provisioning such as a CI/CD pipeline, make sure that the automations are also updated to keepFUNCTIONS_WORKER_RUNTIMEset todotnet-isolatedand to target the correct .NET version.
FUNCTIONS_WORKER_RUNTIME
dotnet-isolated
Publish your migrated project to the staging (nonproduction) slot of your function app.If you use Visual Studio to publish an isolated worker model project to an existing app or slot that uses the in-process model, it can also complete the previous step for you at the same time. If you didn't complete the previous step, Visual Studio prompts you to update the function app during deployment. Visual Studio presents this as a single operation, but these are still two separate operations. You might still see errors in your logs from the staging (nonproduction) slot during the interim state.
Publish your migrated project to the staging (nonproduction) slot of your function app.
If you use Visual Studio to publish an isolated worker model project to an existing app or slot that uses the in-process model, it can also complete the previous step for you at the same time. If you didn't complete the previous step, Visual Studio prompts you to update the function app during deployment. Visual Studio presents this as a single operation, but these are still two separate operations. You might still see errors in your logs from the staging (nonproduction) slot during the interim state.
Confirm that your application is working as expected within the staging (nonproduction) slot.
Confirm that your application is working as expected within the staging (nonproduction) slot.
Perform aslot swap operationto apply the changes you made in your staging (nonproduction) slot to the production slot. A slot swap happens as a single update, which avoids introducing the interim error state in your production environment.
Perform aslot swap operationto apply the changes you made in your staging (nonproduction) slot to the production slot. A slot swap happens as a single update, which avoids introducing the interim error state in your production environment.
Confirm that your application is working as expected within the production slot.
Confirm that your application is working as expected within the production slot.
Once you complete these steps, the migration is complete, and your app runs on the isolated model. Congratulations! Repeat the steps from this guide as necessary forany other apps that need migration.
Next step
Learn more about the isolated worker model
Feedback
Was this page helpful?
Additional resources