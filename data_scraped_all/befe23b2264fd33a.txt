Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Schema reference guide for trigger and action types in Azure Logic Apps
Article
2025-03-27
20 contributors
In this article
This reference describes the general types used for identifying triggers and actions in your logic app's underlying workflow definition, which is described and validated by theWorkflow Definition Language. To find specific connector triggers and actions that you can use in your logic apps, see the list under theConnectors overview.

Triggers overview
Every workflow includes a trigger, which defines the calls that instantiate and start the workflow. Here are the general trigger categories:
Apollingtrigger, which checks a service's endpoint at regular intervals
Apollingtrigger, which checks a service's endpoint at regular intervals
Apushtrigger, which creates a subscription to an endpoint and provides acallback URLso the endpoint can notify the trigger when the specified event happens or data is available. The trigger then waits for the endpoint's response before firing.
Apushtrigger, which creates a subscription to an endpoint and provides acallback URLso the endpoint can notify the trigger when the specified event happens or data is available. The trigger then waits for the endpoint's response before firing.
Triggers have these top-level elements, although some are optional:
"<trigger-name>": {
   "type": "<trigger-type>",
   "inputs": { "<trigger-inputs>" },
   "recurrence": { 
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "conditions": [ "<array-with-conditions>" ],
   "runtimeConfiguration": { "<runtime-config-options>" },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
},
"<trigger-name>": {
   "type": "<trigger-type>",
   "inputs": { "<trigger-inputs>" },
   "recurrence": { 
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "conditions": [ "<array-with-conditions>" ],
   "runtimeConfiguration": { "<runtime-config-options>" },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
},
Required
Optional
runtimeConfiguration
operationOptions
Trigger types list
Each trigger type has a different interface and inputs that define the trigger's behavior.
Built-in triggers
202
Managed API triggers
Triggers - Detailed reference

APIConnection trigger
This trigger checks orpollsan endpoint by usingMicrosoft-managed APIs or "connectors"so the parameters for this trigger can differ based on the endpoint. Many sections in this trigger definition are optional. The trigger's behavior depends on whether or not sections are included.
"<APIConnection_trigger_name>": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<connection-name>']['connectionId']"
         }
      },
      "method": "<method-type>",
      "path": "/<api-operation>",
      "retryPolicy": { "<retry-behavior>" },
      "queries": { "<query-parameters>" }
   },
   "recurrence": { 
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
}
"<APIConnection_trigger_name>": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<connection-name>']['connectionId']"
         }
      },
      "method": "<method-type>",
      "path": "/<api-operation>",
      "retryPolicy": { "<retry-behavior>" },
      "queries": { "<query-parameters>" }
   },
   "recurrence": { 
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
}
Required
Optional
"queries": { "api-version": "2018-01-01" }
?api-version=2018-01-01
@triggerbody()?['value']
operationOptions
Outputs
Example
This trigger definition checks for email every day inside the inbox for a work or school account:
"When_a_new_email_arrives": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "get",
      "path": "/Mail/OnNewEmail",
      "queries": {
          "fetchOnlyWithAttachment": false,
          "folderPath": "Inbox",
          "importance": "Any",
          "includeAttachments": false
      }
   },
   "recurrence": {
      "frequency": "Day",
      "interval": 1
   }
}
"When_a_new_email_arrives": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "get",
      "path": "/Mail/OnNewEmail",
      "queries": {
          "fetchOnlyWithAttachment": false,
          "folderPath": "Inbox",
          "importance": "Any",
          "includeAttachments": false
      }
   },
   "recurrence": {
      "frequency": "Day",
      "interval": 1
   }
}

ApiConnectionWebhook trigger
This trigger sends a subscription request to an endpoint by using aMicrosoft-managed API, provides acallback URLto where the endpoint can send a response, and waits for the endpoint to respond. For more information, seeEndpoint subscriptions.
"<ApiConnectionWebhook_trigger_name>": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "body": {
          "NotificationUrl": "@{listCallbackUrl()}"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<connection-name>']['connectionId']"
         }
      },
      "retryPolicy": { "<retry-behavior>" },
      "queries": "<query-parameters>"
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-run-queue>
      }
   },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
}
"<ApiConnectionWebhook_trigger_name>": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "body": {
          "NotificationUrl": "@{listCallbackUrl()}"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<connection-name>']['connectionId']"
         }
      },
      "retryPolicy": { "<retry-behavior>" },
      "queries": "<query-parameters>"
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-run-queue>
      }
   },
   "splitOn": "<splitOn-expression>",
   "operationOptions": "<operation-option>"
}
Required
Optional
"queries": { "api-version": "2018-01-01" }
?api-version=2018-01-01
runtimeConfiguration.concurrency.runs
@triggerbody()?['value']
operationOptions
Example
This trigger definition subscribes to the Office 365 Outlook API, provides a callback URL to the API endpoint, and waits for the endpoint to respond when a new email arrives.
"When_a_new_email_arrives_(webhook)": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "body": {
         "NotificationUrl": "@{listCallbackUrl()}" 
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "path": "/MailSubscription/$subscriptions",
      "queries": {
          "folderPath": "Inbox",
          "hasAttachment": "Any",
          "importance": "Any"
      }
   },
   "splitOn": "@triggerBody()?['value']"
}
"When_a_new_email_arrives_(webhook)": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "body": {
         "NotificationUrl": "@{listCallbackUrl()}" 
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "path": "/MailSubscription/$subscriptions",
      "queries": {
          "folderPath": "Inbox",
          "hasAttachment": "Any",
          "importance": "Any"
      }
   },
   "splitOn": "@triggerBody()?['value']"
}

HTTP trigger
This trigger sends a request to the specified HTTP or HTTPS endpoint based on the specified recurrence schedule. The trigger then checks the response to determine whether the workflow runs. For more information, seeCall service endpoints over HTTP or HTTPS from Azure Logic Apps.
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "<method-type>",
      "uri": "<HTTP-or-HTTPS-endpoint-URL>",
      "headers": { "<header-content>" },
      "queries": "<query-parameters>",
      "body": "<body-content>",
      "authentication": { "<authentication-type-and-property-values>" },
      "retryPolicy": {
         "type": "<retry-behavior>"
      }
   },
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "<method-type>",
      "uri": "<HTTP-or-HTTPS-endpoint-URL>",
      "headers": { "<header-content>" },
      "queries": "<query-parameters>",
      "body": "<body-content>",
      "authentication": { "<authentication-type-and-property-values>" },
      "retryPolicy": {
         "type": "<retry-behavior>"
      }
   },
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
Required
method
uri
frequency
interval
Optional
headers
"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }
queries
"queries": { "api-version": "2018-01-01" }
?api-version=2018-01-01
body
authentication
authority
https://management.azure.com/
retryPolicy
type
runs
maximumWaitingRuns
runtimeConfiguration.concurrency.runs
operationOptions
operationOptions
Outputs
headers
body
status code
Requirements for incoming requests
To work well with your logic app, the endpoint must conform to a specific trigger pattern or contract, and recognize these response properties:
Example behaviors for different requests
retryPolicy
retryPolicy

HTTPWebhook trigger
This trigger makes your logic app callable by creating an endpoint that can register a subscription by calling the specified endpoint URL. When you create this trigger in your workflow, an outgoing request makes the call to register the subscription. That way, the trigger can start listening for events. When an operation makes this trigger invalid, an outgoing request automatically makes the call to cancel the subscription. For more information, seeEndpoint subscriptions.
You can also specifyasynchronous limitson anHTTPWebhooktrigger. The trigger's behavior depends on the sections that you use or omit.
"HTTP_Webhook": {
   "type": "HttpWebhook",
   "inputs": {
      "subscribe": {
         "method": "<method-type>",
         "uri": "<endpoint-subscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "retryPolicy": { "<retry-behavior>" }
      },
      "unsubscribe": {
         "method": "<method-type>",
         "url": "<endpoint-unsubscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" }
      }
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
"HTTP_Webhook": {
   "type": "HttpWebhook",
   "inputs": {
      "subscribe": {
         "method": "<method-type>",
         "uri": "<endpoint-subscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "retryPolicy": { "<retry-behavior>" }
      },
      "unsubscribe": {
         "method": "<method-type>",
         "url": "<endpoint-unsubscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" }
      }
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
Some values, such as <method-type>, are available for both the"subscribe"and"unsubscribe"objects.
"subscribe"
"unsubscribe"
Required
Optional
runtimeConfiguration.concurrency.runs
operationOptions
Outputs
Example
This trigger creates a subscription to the specified endpoint, provides a unique callback URL, and waits for newly published technology articles.
"HTTP_Webhook": {
   "type": "HttpWebhook",
   "inputs": {
      "subscribe": {
         "method": "POST",
         "uri": "https://pubsubhubbub.appspot.com/subscribe",
         "body": {
            "hub.callback": "@{listCallbackUrl()}",
            "hub.mode": "subscribe",
            "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
         },
      },
      "unsubscribe": {
         "method": "POST",
         "url": "https://pubsubhubbub.appspot.com/subscribe",
         "body": {
            "hub.callback": "@{workflow().endpoint}@{listCallbackUrl()}",
            "hub.mode": "unsubscribe",
            "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
         }
      }
   }
}
"HTTP_Webhook": {
   "type": "HttpWebhook",
   "inputs": {
      "subscribe": {
         "method": "POST",
         "uri": "https://pubsubhubbub.appspot.com/subscribe",
         "body": {
            "hub.callback": "@{listCallbackUrl()}",
            "hub.mode": "subscribe",
            "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
         },
      },
      "unsubscribe": {
         "method": "POST",
         "url": "https://pubsubhubbub.appspot.com/subscribe",
         "body": {
            "hub.callback": "@{workflow().endpoint}@{listCallbackUrl()}",
            "hub.mode": "unsubscribe",
            "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
         }
      }
   }
}

Recurrence trigger
This trigger runs based on the specified recurrence schedule and provides an easy way for creating a regularly running workflow.
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
      "startTime": "<start-date-time-with-format-YYYY-MM-DDThh:mm:ss>",
      "timeZone": "<time-zone>",
      "schedule": {
         // Applies only when frequency is Day or Week. Separate values with commas.
         "hours": [ <one-or-more-hour-marks> ], 
         // Applies only when frequency is Day or Week. Separate values with commas.
         "minutes": [ <one-or-more-minute-marks> ], 
         // Applies only when frequency is Week. Separate values with commas.
         "weekDays": [ "Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday" ] 
      }
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
      "startTime": "<start-date-time-with-format-YYYY-MM-DDThh:mm:ss>",
      "timeZone": "<time-zone>",
      "schedule": {
         // Applies only when frequency is Day or Week. Separate values with commas.
         "hours": [ <one-or-more-hour-marks> ], 
         // Applies only when frequency is Day or Week. Separate values with commas.
         "minutes": [ <one-or-more-minute-marks> ], 
         // Applies only when frequency is Week. Separate values with commas.
         "weekDays": [ "Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday" ] 
      }
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-runs-queue>
      }
   },
   "operationOptions": "<operation-option>"
}
Required
Optional
frequency
frequency
frequency
runtimeConfiguration.concurrency.runs
operationOptions
Example 1
This basic recurrence trigger runs daily:
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Day",
      "interval": 1
   }
}
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Day",
      "interval": 1
   }
}
Example 2
You can specify a start date and time for firing the trigger. This recurrence trigger starts on the specified date and then fires daily:
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Day",
      "interval": 1,
      "startTime": "2017-09-18T00:00:00Z"
   }
}
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Day",
      "interval": 1,
      "startTime": "2017-09-18T00:00:00Z"
   }
}
Example 3
This recurrence trigger starts on September 9, 2017 at 2:00 PM, and fires weekly every Monday at 10:30 AM, 12:30 PM, and 2:30 PM Pacific Standard Time:
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Week",
      "interval": 1,
      "schedule": {
         "hours": [ 10, 12, 14 ],
         "minutes": [ 30 ],
         "weekDays": [ "Monday" ]
      },
      "startTime": "2017-09-07T14:00:00",
      "timeZone": "Pacific Standard Time"
   }
}
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Week",
      "interval": 1,
      "schedule": {
         "hours": [ 10, 12, 14 ],
         "minutes": [ 30 ],
         "weekDays": [ "Monday" ]
      },
      "startTime": "2017-09-07T14:00:00",
      "timeZone": "Pacific Standard Time"
   }
}
For more information plus examples for this trigger, seeCreate and schedule regularly running tasks.

Request trigger
This trigger makes your logic app callable by creating an endpoint that can accept incoming requests. For this trigger, provide a JSON schema that describes and validates the payload or inputs that the trigger receives from the incoming request. The schema also makes trigger properties easier to reference from later actions in the workflow.
To call this trigger, you must use thelistCallbackUrlAPI, which is described in theWorkflow Service REST API. To learn how to use this trigger as an HTTP endpoint, seeCall, trigger, or nest workflows with HTTP endpoints.
listCallbackUrl
"manual": {
   "type": "Request",
   "kind": "Http",
   "inputs": {
      "method": "<method-type>",
      "relativePath": "<relative-path-for-accepted-parameter>",
      "schema": {
         "type": "object",
         "properties": { 
            "<property-name>": {
               "type": "<property-type>"
            }
         },
         "required": [ "<required-properties>" ]
      }
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-run-queue>
      },
   },
   "operationOptions": "<operation-option>"
}
"manual": {
   "type": "Request",
   "kind": "Http",
   "inputs": {
      "method": "<method-type>",
      "relativePath": "<relative-path-for-accepted-parameter>",
      "schema": {
         "type": "object",
         "properties": { 
            "<property-name>": {
               "type": "<property-type>"
            }
         },
         "required": [ "<required-properties>" ]
      }
   },
   "runTimeConfiguration": {
      "concurrency": {
         "runs": <max-runs>,
         "maximumWaitingRuns": <max-run-queue>
      },
   },
   "operationOptions": "<operation-option>"
}
Required
Optional
runtimeConfiguration.concurrency.runs
operationOptions
Example
This trigger specifies that an incoming request must use the HTTP POST method to call the trigger and includes a schema that validates input from the incoming request:
"manual": {
   "type": "Request",
   "kind": "Http",
   "inputs": {
      "method": "POST",
      "schema": {
         "type": "object",
         "properties": {
            "customerName": {
               "type": "String"
            },
            "customerAddress": { 
               "type": "Object",
               "properties": {
                  "streetAddress": {
                     "type": "string"
                  },
                  "city": {
                     "type": "string"
                  }
               }
            }
         }
      }
   }
}
"manual": {
   "type": "Request",
   "kind": "Http",
   "inputs": {
      "method": "POST",
      "schema": {
         "type": "object",
         "properties": {
            "customerName": {
               "type": "String"
            },
            "customerAddress": { 
               "type": "Object",
               "properties": {
                  "streetAddress": {
                     "type": "string"
                  },
                  "city": {
                     "type": "string"
                  }
               }
            }
         }
      }
   }
}

Trigger conditions
For any trigger, and only triggers, you can include an array that contains one or more expressions for conditions that determine whether the workflow should run. To add theconditionsproperty to a trigger in your workflow, open your logic app in the code view editor.
conditions
For example, you can specify that a trigger fires only when a website returns an internal server error by referencing the trigger's status code in theconditionsproperty:
conditions
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Hour",
      "interval": 1
   },
   "conditions": [ {
      "expression": "@equals(triggers().code, 'InternalServerError')"
   } ]
}
"Recurrence": {
   "type": "Recurrence",
   "recurrence": {
      "frequency": "Hour",
      "interval": 1
   },
   "conditions": [ {
      "expression": "@equals(triggers().code, 'InternalServerError')"
   } ]
}
By default, a trigger fires only after getting a "200 OK" response. When an expression references a trigger's status code, the trigger's default behavior is replaced. So, if you want the trigger to fire for more than one status code, such as the "200" and "201" status code, you must include
this expression as your condition:
@or(equals(triggers().code, 200),equals(triggers().code, 201))
@or(equals(triggers().code, 200),equals(triggers().code, 201))

Trigger multiple runs on an array
If your trigger receives an array for your workflow to process, sometimes a "for each" loop might take too long to process each array item. Instead, you can use theSplitOnproperty in your trigger todebatchthe array. Debatching splits up the array items and starts a new workflow instance that runs for each array item. This approach is useful, for example, when you want to poll an endpoint that might return multiple new items between polling intervals.
If your trigger's Swagger file describes a payload that's an array, theSplitOnproperty is automatically added to your trigger. Otherwise, add this property inside the response payload that has
the array you want to debatch.
Before you use the SplitOn capability, review the following considerations:
If trigger concurrency is enabled, theSplitOn limitis significantly reduced. If the number of items exceeds this limit, the SplitOn capability is disabled.
If trigger concurrency is enabled, theSplitOn limitis significantly reduced. If the number of items exceeds this limit, the SplitOn capability is disabled.
You can't use the SplitOn capability with a synchronous response pattern. Any workflow that uses theSplitOnproperty and includes a response action runs asynchronously and immediately sends a202 ACCEPTEDresponse.
You can't use the SplitOn capability with a synchronous response pattern. Any workflow that uses theSplitOnproperty and includes a response action runs asynchronously and immediately sends a202 ACCEPTEDresponse.
202 ACCEPTED
For the maximum number of array items thatSplitOncan process in a single workflow run, seeLimits and configuration.
For the maximum number of array items thatSplitOncan process in a single workflow run, seeLimits and configuration.
Example
Suppose you have an HTTP trigger that calls an API and receives this response:
{
   "Status": "Succeeded",
   "Rows": [ 
      { 
         "id": 938109380,
         "name": "customer-name-one"
      },
      {
         "id": 938109381,
         "name": "customer-name-two"
      }
   ]
}
{
   "Status": "Succeeded",
   "Rows": [ 
      { 
         "id": 938109380,
         "name": "customer-name-one"
      },
      {
         "id": 938109381,
         "name": "customer-name-two"
      }
   ]
}
Your workflow needs only the content from the array inRows, so you can create a trigger like this example:
Rows
"HTTP_Debatch": {
   "type": "Http",
    "inputs": {
        "uri": "https://mydomain.com/myAPI",
        "method": "GET"
    },
   "recurrence": {
      "frequency": "Second",
      "interval": 1
    },
    "splitOn": "@triggerBody()?.Rows"
}
"HTTP_Debatch": {
   "type": "Http",
    "inputs": {
        "uri": "https://mydomain.com/myAPI",
        "method": "GET"
    },
   "recurrence": {
      "frequency": "Second",
      "interval": 1
    },
    "splitOn": "@triggerBody()?.Rows"
}
Note
If you use theSplitOncommand, you can't get the properties that are outside the array.
So for this example, you can't get thestatusproperty in the response returned from the API.
SplitOn
status
To avoid a failure if theRowsproperty doesn't exist, this example uses the?operator.
Rows
?
Your workflow definition can now use@triggerBody().nameto get thenamevalues, which are"customer-name-one"from the first run and"customer-name-two"from the second run. So, your trigger outputs look like these examples:
@triggerBody().name
name
"customer-name-one"
"customer-name-two"
{
   "body": {
      "id": 938109380,
      "name": "customer-name-one"
   }
}
{
   "body": {
      "id": 938109380,
      "name": "customer-name-one"
   }
}
{
   "body": {
      "id": 938109381,
      "name": "customer-name-two"
   }
}
{
   "body": {
      "id": 938109381,
      "name": "customer-name-two"
   }
}

Actions overview
Azure Logic Apps provides various action types - each with different inputs that define an action's unique behavior. Actions have these high-level elements, though some are optional:
"<action-name>": {
   "type": "<action-type>",
   "inputs": { 
      "<input-name>": { "<input-value>" },
      "retryPolicy": "<retry-behavior>" 
   },
   "runAfter": { "<previous-trigger-or-action-status>" },
   "runtimeConfiguration": { "<runtime-config-options>" },
   "operationOptions": "<operation-option>"
},
"<action-name>": {
   "type": "<action-type>",
   "inputs": { 
      "<input-name>": { "<input-value>" },
      "retryPolicy": "<retry-behavior>" 
   },
   "runAfter": { "<previous-trigger-or-action-status>" },
   "runtimeConfiguration": { "<runtime-config-options>" },
   "operationOptions": "<operation-option>"
},
Required
Optional
runtimeConfiguration
operationOptions
Action types list
Here are some commonly used action types:
Built-in action typessuch as these examples and more:HTTPfor calling endpoints over HTTP or HTTPSResponsefor responding to requestsExecute JavaScript Codefor running JavaScript code snippetsFunctionfor calling Azure FunctionsData operation actions such asJoin,Compose,Table,Select, and others that create or transform data from various inputsWorkflowfor calling another logic app workflow
Built-in action typessuch as these examples and more:
HTTPfor calling endpoints over HTTP or HTTPS
HTTPfor calling endpoints over HTTP or HTTPS
Responsefor responding to requests
Responsefor responding to requests
Execute JavaScript Codefor running JavaScript code snippets
Execute JavaScript Codefor running JavaScript code snippets
Functionfor calling Azure Functions
Functionfor calling Azure Functions
Data operation actions such asJoin,Compose,Table,Select, and others that create or transform data from various inputs
Data operation actions such asJoin,Compose,Table,Select, and others that create or transform data from various inputs
Workflowfor calling another logic app workflow
Workflowfor calling another logic app workflow
Managed API action typessuch asApiConnectionandApiConnectionWebHookthat call various connectors and APIs managed by Microsoft, for example, Azure Service Bus, Office 365 Outlook, Power BI, Azure Blob Storage, OneDrive, GitHub, and more
Managed API action typessuch asApiConnectionandApiConnectionWebHookthat call various connectors and APIs managed by Microsoft, for example, Azure Service Bus, Office 365 Outlook, Power BI, Azure Blob Storage, OneDrive, GitHub, and more
Control workflow action typessuch asIf,Foreach,Switch,Scope, andUntil, which contain other actions and help you organize workflow execution
Control workflow action typessuch asIf,Foreach,Switch,Scope, andUntil, which contain other actions and help you organize workflow execution

Built-in actions

Managed API actions

Control workflow actions
These actions help you control workflow execution and include other actions. From outside a control workflow action, you can directly reference actions inside that control workflow action. For example, if you have anHttpaction inside a scope, you can reference the@body('Http')expression from anywhere in the workflow. However, actions that exist inside a control workflow action can only "run after" other actions that are in the same control workflow structure.
Http
@body('Http')
Actions - Detailed reference

APIConnection action
This action sends an HTTP request to aMicrosoft-managed APIand requires information about the API and parameters plus a reference to a valid connection.
"<action-name>": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<api-name>']['connectionId']"
         },
         "<other-action-specific-input-properties>"        
      },
      "method": "<method-type>",
      "path": "/<api-operation>",
      "retryPolicy": "<retry-behavior>",
      "queries": { "<query-parameters>" },
      "<other-action-specific-properties>"
    },
    "runAfter": {}
}
"<action-name>": {
   "type": "ApiConnection",
   "inputs": {
      "host": {
         "connection": {
            "name": "@parameters('$connections')['<api-name>']['connectionId']"
         },
         "<other-action-specific-input-properties>"        
      },
      "method": "<method-type>",
      "path": "/<api-operation>",
      "retryPolicy": "<retry-behavior>",
      "queries": { "<query-parameters>" },
      "<other-action-specific-properties>"
    },
    "runAfter": {}
}
Required
Optional
"queries": { "api-version": "2018-01-01" }
?api-version=2018-01-01
Example
This definition describes theSend an emailaction for Office 365 Outlook connector, which is a Microsoft-managed API:
"Send_an_email": {
   "type": "ApiConnection",
   "inputs": {
      "body": {
         "Body": "Thank you for your membership!",
         "Subject": "Hello and welcome!",
         "To": "Sophie.Owen@contoso.com"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "POST",
      "path": "/Mail"
    },
    "runAfter": {}
}
"Send_an_email": {
   "type": "ApiConnection",
   "inputs": {
      "body": {
         "Body": "Thank you for your membership!",
         "Subject": "Hello and welcome!",
         "To": "Sophie.Owen@contoso.com"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "POST",
      "path": "/Mail"
    },
    "runAfter": {}
}

APIConnectionWebhook action
This action sends a subscription request over HTTP to an endpoint by using aMicrosoft-managed API, provides acallback URLto where the endpoint can send a response,
and waits for the endpoint to respond. For more information, seeEndpoint subscriptions.
"<action-name>": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "subscribe": {
         "method": "<method-type>",
         "uri": "<api-subscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "retryPolicy": "<retry-behavior>",
         "queries": { "<query-parameters>" },
         "<other-action-specific-input-properties>"
      },
      "unsubscribe": {
         "method": "<method-type>",
         "uri": "<api-unsubscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "<other-action-specific-properties>"
      },
   },
   "runAfter": {}
}
"<action-name>": {
   "type": "ApiConnectionWebhook",
   "inputs": {
      "subscribe": {
         "method": "<method-type>",
         "uri": "<api-subscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "retryPolicy": "<retry-behavior>",
         "queries": { "<query-parameters>" },
         "<other-action-specific-input-properties>"
      },
      "unsubscribe": {
         "method": "<method-type>",
         "uri": "<api-unsubscribe-URL>",
         "headers": { "<header-content>" },
         "body": "<body-content>",
         "authentication": { "<authentication-type>" },
         "<other-action-specific-properties>"
      },
   },
   "runAfter": {}
}
Some values, such as <method-type>, are available for both the"subscribe"and"unsubscribe"objects.
"subscribe"
"unsubscribe"
Required
Optional
"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }
"queries": { "api-version": "2018-01-01" }
?api-version=2018-01-01
You can also specify limits on anApiConnectionWebhookaction in the same way asHTTP asynchronous limits.

Compose action
This action creates a single output from multiple inputs, including expressions. Both the output and inputs can have any type that Azure Logic Apps natively supports, such as arrays, JSON objects, XML, and binary. You can then use the action's output in other actions.
"Compose": {
   "type": "Compose",
   "inputs": "<inputs-to-compose>",
   "runAfter": {}
},
"Compose": {
   "type": "Compose",
   "inputs": "<inputs-to-compose>",
   "runAfter": {}
},
Required
Example 1
This action definition mergesabcdefgwith a trailing space and the value1234:
abcdefg
1234
"Compose": {
   "type": "Compose",
   "inputs": "abcdefg 1234",
   "runAfter": {}
},
"Compose": {
   "type": "Compose",
   "inputs": "abcdefg 1234",
   "runAfter": {}
},
Here's the output that this action creates:
abcdefg 1234
abcdefg 1234
Example 2
This action definition merges a string variable that containsabcdefgand an integer variable that contains1234:
abcdefg
1234
"Compose": {
   "type": "Compose",
   "inputs": "@{variables('myString')}@{variables('myInteger')}",
   "runAfter": {}
},
"Compose": {
   "type": "Compose",
   "inputs": "@{variables('myString')}@{variables('myInteger')}",
   "runAfter": {}
},
Here's the output that this action creates:
"abcdefg1234"
"abcdefg1234"

Execute JavaScript Code action
This action runs a JavaScript code snippet and returns the results through a token that subsequent actions in the workflow can reference.
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "<JavaScript-code-snippet>",
      "explicitDependencies": {
         "actions": [ <preceding-actions> ],
         "includeTrigger": true
      }
   },
   "runAfter": {}
}
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "<JavaScript-code-snippet>",
      "explicitDependencies": {
         "actions": [ <preceding-actions> ],
         "includeTrigger": true
      }
   },
   "runAfter": {}
}
Required
code
workflowContext
workflowContext
Required in some cases
TheexplicitDependenciesattribute specifies that you want to explicitly include results from the trigger, previous actions, or both as dependencies for your code snippet. For more information about adding these dependencies, seeAdd dependencies as parameters to an Inline Code action.
explicitDependencies
For theincludeTriggerattribute, you can specifytrueorfalsevalues.
includeTrigger
true
false
Example 1
This action runs code that gets your logic app workflow's name and returns the text "Hello world from <logic-app-name>" as the result. In this example, the code references the workflow's name by accessing theworkflowContext.workflow.nameproperty through the read-onlyworkflowContextobject. For more information about using theworkflowContextobject, seeReference trigger and action results in your code.
workflowContext.workflow.name
workflowContext
workflowContext
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "var text = \"Hello world from \" + workflowContext.workflow.name;\r\n\r\nreturn text;"
   },
   "runAfter": {}
}
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "var text = \"Hello world from \" + workflowContext.workflow.name;\r\n\r\nreturn text;"
   },
   "runAfter": {}
}
Example 2
This action runs code in a logic app workflow that triggers when a new email arrives in an Outlook account. The workflow also uses the Office 365 OutlookSend approval emailaction that forwards the content from the received email along with a request for approval.
The code extracts the email addresses from the email message'sBodyproperty, and returns the addresses along with theSelectedOptionproperty value from the approval action. The action explicitly includes theSend approval emailaction as a dependency in theactionsobject inside theexplicitDependenciesobject.
Body
SelectedOption
actions
explicitDependencies
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "var myResult = /(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/g;\r\n\r\nvar email = workflowContext.trigger.outputs.body.Body;\r\n\r\nvar reply = workflowContext.actions.Send_approval_email.outputs.body.SelectedOption;\r\n\r\nreturn email.match(myResult) + \" - \" + reply;\r\n;",
      "explicitDependencies": {
         "actions": [
            "Send_approval_email"
         ]
      }
   },
   "runAfter": {}
}
"Execute_JavaScript_Code": {
   "type": "JavaScriptCode",
   "inputs": {
      "code": "var myResult = /(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/g;\r\n\r\nvar email = workflowContext.trigger.outputs.body.Body;\r\n\r\nvar reply = workflowContext.actions.Send_approval_email.outputs.body.SelectedOption;\r\n\r\nreturn email.match(myResult) + \" - \" + reply;\r\n;",
      "explicitDependencies": {
         "actions": [
            "Send_approval_email"
         ]
      }
   },
   "runAfter": {}
}

Function action
This action calls a previously createdAzure function.
"<Azure-function-name>": {
   "type": "Function",
   "inputs": {
     "function": {
        "id": "<Azure-function-ID>"
      },
      "method": "<method-type>",
      "headers": { "<header-content>" },
      "body": { "<body-content>" },
      "queries": { "<query-parameters>" } 
   },
   "runAfter": {}
}
"<Azure-function-name>": {
   "type": "Function",
   "inputs": {
     "function": {
        "id": "<Azure-function-ID>"
      },
      "method": "<method-type>",
      "headers": { "<header-content>" },
      "body": { "<body-content>" },
      "queries": { "<query-parameters>" } 
   },
   "runAfter": {}
}
Required
Optional
"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }
"queries": { "api-version": "2018-01-01" }
?api-version=2018-01-01
When you save your logic app, Azure Logic Apps performs these checks on the referenced function:
Your workflow must have access to the function.
Your workflow must have access to the function.
Your workflow can use only a standard HTTP trigger or generic JSON webhook trigger.Azure Logic Apps gets and caches the trigger's URL, which is used at runtime. However, if any operation invalidates the cached URL, theFunctionaction fails at runtime. To fix this issue, save the logic app again so that the logic app gets and caches the trigger URL again.
Your workflow can use only a standard HTTP trigger or generic JSON webhook trigger.
Azure Logic Apps gets and caches the trigger's URL, which is used at runtime. However, if any operation invalidates the cached URL, theFunctionaction fails at runtime. To fix this issue, save the logic app again so that the logic app gets and caches the trigger URL again.
The function can't have any route defined.
The function can't have any route defined.
Only "function" and "anonymous" authorization levels are allowed.
Only "function" and "anonymous" authorization levels are allowed.
Example
This action definition calls the previously created "GetProductID" function:
"GetProductID": {
   "type": "Function",
   "inputs": {
     "function": {
        "id": "/subscriptions/<XXXXXXXXXXXXXXXXXXXX>/resourceGroups/myLogicAppResourceGroup/providers/Microsoft.Web/sites/InventoryChecker/functions/GetProductID"
      },
      "method": "POST",
      "headers": { 
          "x-ms-date": "@utcnow()"
       },
      "body": { 
          "Product_ID": "@variables('ProductID')"
      }
   },
   "runAfter": {}
}
"GetProductID": {
   "type": "Function",
   "inputs": {
     "function": {
        "id": "/subscriptions/<XXXXXXXXXXXXXXXXXXXX>/resourceGroups/myLogicAppResourceGroup/providers/Microsoft.Web/sites/InventoryChecker/functions/GetProductID"
      },
      "method": "POST",
      "headers": { 
          "x-ms-date": "@utcnow()"
       },
      "body": { 
          "Product_ID": "@variables('ProductID')"
      }
   },
   "runAfter": {}
}

HTTP action
This action sends a request to the specified HTTP or HTTPS endpoint and checks the response to determine whether the workflow runs. For more information, seeCall service endpoints over HTTP or HTTPS from Azure Logic Apps.
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "<method-type>",
      "uri": "<HTTP-or-HTTPS-endpoint-URL>",
      "headers": { "<header-content>" },
      "queries": { "<query-parameters>" },
      "body": "<body-content>",
      "authentication": { "<authentication-type-and-property-values>" },
      "retryPolicy": {
         "type": "<retry-behavior>"
      },
   },
   "runAfter": {}
}
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "<method-type>",
      "uri": "<HTTP-or-HTTPS-endpoint-URL>",
      "headers": { "<header-content>" },
      "queries": { "<query-parameters>" },
      "body": "<body-content>",
      "authentication": { "<authentication-type-and-property-values>" },
      "retryPolicy": {
         "type": "<retry-behavior>"
      },
   },
   "runAfter": {}
}
Required
method
uri
Optional
headers
"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }
queries
"queries": { "api-version": "2018-01-01" }
?api-version=2018-01-01
body
authentication
authority
https://management.azure.com/
retryPolicy
type
Example
This action definition gets the latest news by sending a request to the specified endpoint:
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "https://mynews.example.com/latest"
   }
}
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "https://mynews.example.com/latest"
   }
}

Join action
This action creates a string from all the items in an array and separates those items with the specified delimiter character.
"Join": {
   "type": "Join",
   "inputs": {
      "from": <array>,
      "joinWith": "<delimiter>"
   },
   "runAfter": {}
}
"Join": {
   "type": "Join",
   "inputs": {
      "from": <array>,
      "joinWith": "<delimiter>"
   },
   "runAfter": {}
}
Required
Example
Suppose you have a previously created "myIntegerArray" variable that contains this integer array:
[1,2,3,4]
[1,2,3,4]
This action definition gets the values from the variable by using thevariables()function in an expression and creates this string with those values, which are separated by a comma:"1,2,3,4"
variables()
"1,2,3,4"
"Join": {
   "type": "Join",
   "inputs": {
      "from": "@variables('myIntegerArray')",
      "joinWith": ","
   },
   "runAfter": {}
}
"Join": {
   "type": "Join",
   "inputs": {
      "from": "@variables('myIntegerArray')",
      "joinWith": ","
   },
   "runAfter": {}
}

Parse JSON action
This action creates user-friendly fields ortokensfrom the properties in JSON content. You can then access those properties in your logic app by using the tokens instead. For example, when you want to use JSON output from services such as Azure Service Bus and Azure Cosmos DB, you can include this action in your logic app so that you can more easily reference the data in that output.
"Parse_JSON": {
   "type": "ParseJson",
   "inputs": {
      "content": "<JSON-source>",
         "schema": { "<JSON-schema>" }
      },
      "runAfter": {}
},
"Parse_JSON": {
   "type": "ParseJson",
   "inputs": {
      "content": "<JSON-source>",
         "schema": { "<JSON-schema>" }
      },
      "runAfter": {}
},
Required
Example
This action definition creates these tokens that you can use in your workflow but only in actions that run following theParse JSONaction:
FirstName,LastName, andEmail
FirstName
LastName
Email
"Parse_JSON": {
   "type": "ParseJson",
   "inputs": {
      "content": {
         "Member": {
            "Email": "Sophie.Owen@contoso.com",
            "FirstName": "Sophie",
            "LastName": "Owen"
         }
      },
      "schema": {
         "type": "object",
         "properties": {
            "Member": {
               "type": "object",
               "properties": {
                  "Email": {
                     "type": "string"
                  },
                  "FirstName": {
                     "type": "string"
                  },
                  "LastName": {
                     "type": "string"
                  }
               }
            }
         }
      }
   },
   "runAfter": { }
},
"Parse_JSON": {
   "type": "ParseJson",
   "inputs": {
      "content": {
         "Member": {
            "Email": "Sophie.Owen@contoso.com",
            "FirstName": "Sophie",
            "LastName": "Owen"
         }
      },
      "schema": {
         "type": "object",
         "properties": {
            "Member": {
               "type": "object",
               "properties": {
                  "Email": {
                     "type": "string"
                  },
                  "FirstName": {
                     "type": "string"
                  },
                  "LastName": {
                     "type": "string"
                  }
               }
            }
         }
      }
   },
   "runAfter": { }
},
In this example, the "content" property specifies the JSON content for the action to parse. You can also provide this JSON content as the sample payload for generating the schema.
"content": {
   "Member": { 
      "FirstName": "Sophie",
      "LastName": "Owen",
      "Email": "Sophie.Owen@contoso.com"
   }
},
"content": {
   "Member": { 
      "FirstName": "Sophie",
      "LastName": "Owen",
      "Email": "Sophie.Owen@contoso.com"
   }
},
The "schema" property specifies the JSON schema used for describing the JSON content:
"schema": {
   "type": "object",
   "properties": {
      "Member": {
         "type": "object",
         "properties": {
            "FirstName": {
               "type": "string"
            },
            "LastName": {
               "type": "string"
            },
            "Email": {
               "type": "string"
            }
         }
      }
   }
}
"schema": {
   "type": "object",
   "properties": {
      "Member": {
         "type": "object",
         "properties": {
            "FirstName": {
               "type": "string"
            },
            "LastName": {
               "type": "string"
            },
            "Email": {
               "type": "string"
            }
         }
      }
   }
}

Query action
This action creates an array from items in another array based on a specified condition or filter.
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": <array>,
      "where": "<condition-or-filter>"
   },
   "runAfter": {}
}
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": <array>,
      "where": "<condition-or-filter>"
   },
   "runAfter": {}
}
Required
Example
This action definition creates an array that has values greater than the specified value, which is two:
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": [ 1, 3, 0, 5, 4, 2 ],
      "where": "@greater(item(), 2)"
   }
}
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": [ 1, 3, 0, 5, 4, 2 ],
      "where": "@greater(item(), 2)"
   }
}

Response action
This action creates the payload for the response to an HTTP request.
"Response" {
    "type": "Response",
    "kind": "http",
    "inputs": {
        "statusCode": 200,
        "headers": { <response-headers> },
        "body": { <response-body> }
    },
    "runAfter": {}
},
"Response" {
    "type": "Response",
    "kind": "http",
    "inputs": {
        "statusCode": 200,
        "headers": { <response-headers> },
        "body": { <response-body> }
    },
    "runAfter": {}
},
Required
Optional
Example
This action definition creates a response to an HTTP request with the specified status code, message body, and message headers:
"Response": {
   "type": "Response",
   "inputs": {
      "statusCode": 200,
      "body": {
         "ProductID": 0,
         "Description": "Organic Apples"
      },
      "headers": {
         "x-ms-date": "@utcnow()",
         "content-type": "application/json"
      }
   },
   "runAfter": {}
}
"Response": {
   "type": "Response",
   "inputs": {
      "statusCode": 200,
      "body": {
         "ProductID": 0,
         "Description": "Organic Apples"
      },
      "headers": {
         "x-ms-date": "@utcnow()",
         "content-type": "application/json"
      }
   },
   "runAfter": {}
}
Restrictions
Unlike other actions, theResponseaction has special restrictions:
Your workflow can use theResponseaction only when the workflow starts with an HTTP request trigger, meaning your workflow must be triggered by an HTTP request.
Your workflow can use theResponseaction only when the workflow starts with an HTTP request trigger, meaning your workflow must be triggered by an HTTP request.
Your workflow can use theResponseaction anywhereexceptinsideForeachloops,Untilloops, including sequential loops, and parallel branches.
Your workflow can use theResponseaction anywhereexceptinsideForeachloops,Untilloops, including sequential loops, and parallel branches.
The original request gets your workflow's response only when all actions required by theResponseaction are finished within theHTTP timeout limit.However, if your workflow calls another logic app as a nested workflow, the parent workflow waits until the nested workflow finishes, no matter how much time passes before the nested workflow finishes.
The original request gets your workflow's response only when all actions required by theResponseaction are finished within theHTTP timeout limit.
However, if your workflow calls another logic app as a nested workflow, the parent workflow waits until the nested workflow finishes, no matter how much time passes before the nested workflow finishes.
When your workflow uses theResponseaction and a synchronous response pattern, the workflow can't also use thesplitOncommand in the trigger definition because that command creates multiple runs. Check for this case when the PUT method is used, and if true, return a "bad request" response.Otherwise, if your workflow uses thesplitOncommand and aResponseaction, the workflow runs asynchronously and immediately returns a "202 ACCEPTED" response.
When your workflow uses theResponseaction and a synchronous response pattern, the workflow can't also use thesplitOncommand in the trigger definition because that command creates multiple runs. Check for this case when the PUT method is used, and if true, return a "bad request" response.
Otherwise, if your workflow uses thesplitOncommand and aResponseaction, the workflow runs asynchronously and immediately returns a "202 ACCEPTED" response.
When your workflow's execution reaches theResponseaction, but the incoming request has already received a response, theResponseaction is marked as "Failed" due to the conflict. And as a result, your logic app run is also marked with "Failed" status.
When your workflow's execution reaches theResponseaction, but the incoming request has already received a response, theResponseaction is marked as "Failed" due to the conflict. And as a result, your logic app run is also marked with "Failed" status.

Select action
This action creates an array with JSON objects by transforming items from another array based on the specified map. The output array and source array always have the same number of items. Although you can't change the number of objects in the output array, you can add or remove properties and their values across those objects. Theselectproperty specifies at least one key-value pair that define the map for transforming items in the source array. A key-value pair represents a property and its value across all the objects in the output array.
select
"Select": {
   "type": "Select",
   "inputs": {
      "from": <array>,
      "select": { 
          "<key-name>": "<expression>",
          "<key-name>": "<expression>"        
      }
   },
   "runAfter": {}
},
"Select": {
   "type": "Select",
   "inputs": {
      "from": <array>,
      "select": { 
          "<key-name>": "<expression>",
          "<key-name>": "<expression>"        
      }
   },
   "runAfter": {}
},
Required
TheSelectaction creates an array as output, so any action that wants to use this output must either accept an array, or you must convert the array into the type that the consumer action accepts. For example, to convert the output array to a string, you can pass that array to theComposeaction, and then reference the output from theComposeaction in your other actions.
Example
This action definition creates a JSON object array from an integer array. The action iterates through the source array, gets each integer value by using the@item()expression, and assigns each value to the "number" property in each JSON object:
@item()
number
"Select": {
   "type": "Select",
   "inputs": {
      "from": [ 1, 2, 3 ],
      "select": { 
         "number": "@item()" 
      }
   },
   "runAfter": {}
},
"Select": {
   "type": "Select",
   "inputs": {
      "from": [ 1, 2, 3 ],
      "select": { 
         "number": "@item()" 
      }
   },
   "runAfter": {}
},
Here's the array that this action creates:
[ { "number": 1 }, { "number": 2 }, { "number": 3 } ]
[ { "number": 1 }, { "number": 2 }, { "number": 3 } ]
To use this array output in other actions, pass this output into aComposeaction:
"Compose": {
   "type": "Compose",
   "inputs": "@body('Select')",
   "runAfter": {
      "Select": [ "Succeeded" ]
   }
},
"Compose": {
   "type": "Compose",
   "inputs": "@body('Select')",
   "runAfter": {
      "Select": [ "Succeeded" ]
   }
},
You can then use the output from theComposeaction in your other actions, for example, theOffice 365 Outlook - Send an emailaction:
"Send_an_email": {
   "type": "ApiConnection",
   "inputs": {
      "body": {
         "Body": "@{outputs('Compose')}",
         "Subject": "Output array from Select and Compose actions",
         "To": "<your-email@domain>"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "post",
      "path": "/Mail"
   },
   "runAfter": {
      "Compose": [ "Succeeded" ]
   }
},
"Send_an_email": {
   "type": "ApiConnection",
   "inputs": {
      "body": {
         "Body": "@{outputs('Compose')}",
         "Subject": "Output array from Select and Compose actions",
         "To": "<your-email@domain>"
      },
      "host": {
         "connection": {
            "name": "@parameters('$connections')['office365']['connectionId']"
         }
      },
      "method": "post",
      "path": "/Mail"
   },
   "runAfter": {
      "Compose": [ "Succeeded" ]
   }
},

Table action
This action creates a CSV or HTML table from an array. For arrays with JSON objects, this action automatically creates the column headers from the objects' property names. For arrays with other data types, you must specify the column headers and values. For example, this array includes the "ID" and "Product_Name" properties that this action can use for the column header names:
[ {"ID": 0, "Product_Name": "Apples"}, {"ID": 1, "Product_Name": "Oranges"} ]
[ {"ID": 0, "Product_Name": "Apples"}, {"ID": 1, "Product_Name": "Oranges"} ]
"Create_<CSV | HTML>_table": {
   "type": "Table",
   "inputs": {
      "format": "<CSV | HTML>",
      "from": <array>,
      "columns": [ 
         {
            "header": "<column-name>",
            "value": "<column-value>"
         },
         {
            "header": "<column-name>",
            "value": "<column-value>"
         } 
      ]
   },
   "runAfter": {}
}
"Create_<CSV | HTML>_table": {
   "type": "Table",
   "inputs": {
      "format": "<CSV | HTML>",
      "from": <array>,
      "columns": [ 
         {
            "header": "<column-name>",
            "value": "<column-value>"
         },
         {
            "header": "<column-name>",
            "value": "<column-value>"
         } 
      ]
   },
   "runAfter": {}
}
Required
Optional
To specify or customize column headers and values, use thecolumnsarray. Whenheader-valuepairs have the same header name, their values appear in the same column under that header name. Otherwise, each unique header defines a unique column.
columns
header-value
Example 1
Suppose you have a previously created "myItemArray" variable that currently contains this array:
[ {"ID": 0, "Product_Name": "Apples"}, {"ID": 1, "Product_Name": "Oranges"} ]
[ {"ID": 0, "Product_Name": "Apples"}, {"ID": 1, "Product_Name": "Oranges"} ]
This action definition creates a CSV table from the "myItemArray" variable. The expression used by thefromproperty gets the array from "myItemArray" by using thevariables()function:
from
variables()
"Create_CSV_table": {
   "type": "Table",
   "inputs": {
      "format": "CSV",
      "from": "@variables('myItemArray')"
   },
   "runAfter": {}
}
"Create_CSV_table": {
   "type": "Table",
   "inputs": {
      "format": "CSV",
      "from": "@variables('myItemArray')"
   },
   "runAfter": {}
}
Here's the CSV table that this action creates:
ID,Product_Name 
0,Apples 
1,Oranges
ID,Product_Name 
0,Apples 
1,Oranges
Example 2
This action definition creates an HTML table from the "myItemArray" variable. The expression used by thefromproperty gets the array from "myItemArray" by using thevariables()function:
from
variables()
"Create_HTML_table": {
   "type": "Table",
   "inputs": {
      "format": "HTML",
      "from": "@variables('myItemArray')"
   },
   "runAfter": {}
}
"Create_HTML_table": {
   "type": "Table",
   "inputs": {
      "format": "HTML",
      "from": "@variables('myItemArray')"
   },
   "runAfter": {}
}
Here's the HTML table that this action creates:
Example 3
This action definition creates an HTML table from the "myItemArray" variable. However, this example overrides the default column header names with "Stock_ID" and "Description", and adds the word "Organic" to the values in the "Description" column.
"Create_HTML_table": {
   "type": "Table",
   "inputs": {
      "format": "HTML",
      "from": "@variables('myItemArray')",
      "columns": [ 
         {
            "header": "Stock_ID",
            "value": "@item().ID"
         },
         {
            "header": "Description",
            "value": "@concat('Organic ', item().Product_Name)"
         }
      ]
    },
   "runAfter": {}
},
"Create_HTML_table": {
   "type": "Table",
   "inputs": {
      "format": "HTML",
      "from": "@variables('myItemArray')",
      "columns": [ 
         {
            "header": "Stock_ID",
            "value": "@item().ID"
         },
         {
            "header": "Description",
            "value": "@concat('Organic ', item().Product_Name)"
         }
      ]
    },
   "runAfter": {}
},
Here's the HTML table that this action creates:

Terminate action
This action stops the run for a workflow instance, cancels any actions in progress, skips any remaining actions, and returns the specified status. For example, you can use theTerminateaction when your logic app must exit completely from an error state. This action doesn't affect already completed actions and can't appear insideForeachandUntilloops, including sequential loops.
"Terminate": {
   "type": "Terminate",
   "inputs": {
       "runStatus": "<status>",
       "runError": {
            "code": "<error-code-or-name>",
            "message": "<error-message>"
       }
   },
   "runAfter": {}
}
"Terminate": {
   "type": "Terminate",
   "inputs": {
       "runStatus": "<status>",
       "runError": {
            "code": "<error-code-or-name>",
            "message": "<error-message>"
       }
   },
   "runAfter": {}
}
Required
Optional
The properties for the "runError" object apply only
when the "runStatus" property is set to "Failed" status.
Example
This action definition stops a workflow run, sets the run status to "Failed",
and returns the status, an error code, and an error message:
"Terminate": {
    "type": "Terminate",
    "inputs": {
        "runStatus": "Failed",
        "runError": {
            "code": "Unexpected response",
            "message": "The service received an unexpected response. Please try again."
        }
   },
   "runAfter": {}
}
"Terminate": {
    "type": "Terminate",
    "inputs": {
        "runStatus": "Failed",
        "runError": {
            "code": "Unexpected response",
            "message": "The service received an unexpected response. Please try again."
        }
   },
   "runAfter": {}
}

Wait action
This action pauses workflow execution for the specified interval or until the specified time, but not both.
Specified interval
"Delay": {
   "type": "Wait",
   "inputs": {
      "interval": {
         "count": <number-of-units>,
         "unit": "<interval>"
      }
   },
   "runAfter": {}
},
"Delay": {
   "type": "Wait",
   "inputs": {
      "interval": {
         "count": <number-of-units>,
         "unit": "<interval>"
      }
   },
   "runAfter": {}
},
Specified time
"Delay_until": {
   "type": "Wait",
   "inputs": {
      "until": {
         "timestamp": "<date-time-stamp>"
      }
   },
   "runAfter": {}
},
"Delay_until": {
   "type": "Wait",
   "inputs": {
      "until": {
         "timestamp": "<date-time-stamp>"
      }
   },
   "runAfter": {}
},
Required
Example 1
This action definition pauses the workflow for 15 minutes:
"Delay": {
   "type": "Wait",
   "inputs": {
      "interval": {
         "count": 15,
         "unit": "Minute"
      }
   },
   "runAfter": {}
},
"Delay": {
   "type": "Wait",
   "inputs": {
      "interval": {
         "count": 15,
         "unit": "Minute"
      }
   },
   "runAfter": {}
},
Example 2
This action definition pauses the workflow until the specified time:
"Delay_until": {
   "type": "Wait",
   "inputs": {
      "until": {
         "timestamp": "2017-10-01T00:00:00Z"
      }
   },
   "runAfter": {}
},
"Delay_until": {
   "type": "Wait",
   "inputs": {
      "until": {
         "timestamp": "2017-10-01T00:00:00Z"
      }
   },
   "runAfter": {}
},

Workflow action
This action calls another previously created logic app, which means you can include and reuse other logic app workflows. You can also use the outputs from the child ornestedlogic app in actions that follow the nested logic app, provided that the child logic app returns a response.
Azure Logic Apps checks access to the trigger you want to call, so make sure you can access that trigger. Also, the nested logic app must meet these criteria:
A trigger makes the nested logic app callable, such as aRequestorHTTPtrigger
A trigger makes the nested logic app callable, such as aRequestorHTTPtrigger
The same Azure subscription as your parent logic app
The same Azure subscription as your parent logic app
To use the outputs from the nested logic app in your parent logic app, the nested logic app must have aResponseaction
To use the outputs from the nested logic app in your parent logic app, the nested logic app must have aResponseaction
"<nested-logic-app-name>": {
   "type": "Workflow",
   "inputs": {
      "body": { "<body-content" },
      "headers": { "<header-content>" },
      "host": {
         "triggerName": "<trigger-name>",
         "workflow": {
            "id": "/subscriptions/<Azure-subscription-ID>/resourceGroups/<Azure-resource-group>/providers/Microsoft.Logic/<nested-logic-app-name>"
         }
      }
   },
   "runAfter": {}
}
"<nested-logic-app-name>": {
   "type": "Workflow",
   "inputs": {
      "body": { "<body-content" },
      "headers": { "<header-content>" },
      "host": {
         "triggerName": "<trigger-name>",
         "workflow": {
            "id": "/subscriptions/<Azure-subscription-ID>/resourceGroups/<Azure-resource-group>/providers/Microsoft.Logic/<nested-logic-app-name>"
         }
      }
   },
   "runAfter": {}
}
Required
Optional
Outputs
This action's outputs vary based on the nested logic app's Response action. If the nested logic app doesn't include a Response action, the outputs are empty.
Example
After the "Start_search" action finishes successfully, this workflow action definition calls another logic app named "Get_product_information", which passes in the specified inputs:
"actions": {
   "Start_search": { <action-definition> },
   "Get_product_information": {
      "type": "Workflow",
      "inputs": {
         "body": {
            "ProductID": "24601",
         },
         "host": {
            "id": "/subscriptions/XXXXXXXXXXXXXXXXXXXXXXXXXX/resourceGroups/InventoryManager-RG/providers/Microsoft.Logic/Get_product_information",
            "triggerName": "Find_product"
         },
         "headers": {
            "content-type": "application/json"
         }
      },
      "runAfter": { 
         "Start_search": [ "Succeeded" ]
      }
   }
},
"actions": {
   "Start_search": { <action-definition> },
   "Get_product_information": {
      "type": "Workflow",
      "inputs": {
         "body": {
            "ProductID": "24601",
         },
         "host": {
            "id": "/subscriptions/XXXXXXXXXXXXXXXXXXXXXXXXXX/resourceGroups/InventoryManager-RG/providers/Microsoft.Logic/Get_product_information",
            "triggerName": "Find_product"
         },
         "headers": {
            "content-type": "application/json"
         }
      },
      "runAfter": { 
         "Start_search": [ "Succeeded" ]
      }
   }
},
Control workflow action details

Foreach action
This looping action iterates through an array and performs actions on each array item. By default, the "for each" loop runs in parallel up to a maximum number of loops. For this maximum, seeLimits and config. Learnhow to create "for each" loops.
"For_each": {
   "type": "Foreach",
   "actions": { 
      "<action-1>": { "<action-definition-1>" },
      "<action-2>": { "<action-definition-2>" }
   },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": <count>
      }
    },
    "operationOptions": "<operation-option>"
}
"For_each": {
   "type": "Foreach",
   "actions": { 
      "<action-1>": { "<action-definition-1>" },
      "<action-2>": { "<action-definition-2>" }
   },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": <count>
      }
    },
    "operationOptions": "<operation-option>"
}
Required
Optional
Sequential
1
Example
This "for each" loop sends an email for each item in the array, which contains attachments from an incoming email. The loop sends an email, including the attachment, to a person who reviews the attachment.
"For_each": {
   "type": "Foreach",
   "actions": {
      "Send_an_email": {
         "type": "ApiConnection",
         "inputs": {
            "body": {
               "Body": "@base64ToString(items('For_each')?['Content'])",
               "Subject": "Review attachment",
               "To": "Sophie.Owen@contoso.com"
                },
            "host": {
               "connection": {
                  "id": "@parameters('$connections')['office365']['connectionId']"
               }
            },
            "method": "post",
            "path": "/Mail"
         },
         "runAfter": {}
      }
   },
   "foreach": "@triggerBody()?['Attachments']",
   "runAfter": {}
}
"For_each": {
   "type": "Foreach",
   "actions": {
      "Send_an_email": {
         "type": "ApiConnection",
         "inputs": {
            "body": {
               "Body": "@base64ToString(items('For_each')?['Content'])",
               "Subject": "Review attachment",
               "To": "Sophie.Owen@contoso.com"
                },
            "host": {
               "connection": {
                  "id": "@parameters('$connections')['office365']['connectionId']"
               }
            },
            "method": "post",
            "path": "/Mail"
         },
         "runAfter": {}
      }
   },
   "foreach": "@triggerBody()?['Attachments']",
   "runAfter": {}
}
To specify only an array that is passed as output from the trigger, this expression gets the <array-name> array from the trigger body. To avoid a failure if the array doesn't exist, the expression uses the?operator:
?
@triggerBody()?['<array-name>']
@triggerBody()?['<array-name>']

If action
This action, which is aconditional statement, evaluates an expression that represents a condition and runs a different branch based on whether the condition is true or false. If the condition is true, the condition is marked with "Succeeded" status. Learnhow to create conditional statements.
"Condition": {
   "type": "If",
   "expression": { "<condition>" },
   "actions": {
      "<action-1>": { "<action-definition>" }
   },
   "else": {
      "actions": {
        "<action-2>": { "<action-definition" }
      }
   },
   "runAfter": {}
}
"Condition": {
   "type": "If",
   "expression": { "<condition>" },
   "actions": {
      "<action-1>": { "<action-definition>" }
   },
   "else": {
      "actions": {
        "<action-2>": { "<action-definition" }
      }
   },
   "runAfter": {}
}
The actions in theactionsorelseobjects get these statuses:
actions
else
"Succeeded" when they run and succeed
"Failed" when they run and fail
"Skipped" when the respective branch doesn't run
Example
This condition specifies that when the integer variable has a value greater than zero, the workflow checks a website. If the variable is zero or less, the workflow checks a different website.
"Condition": {
   "type": "If",
   "expression": {
      "and": [ {
         "greater": [ "@variables('myIntegerVariable')", 0 ] 
      } ]
   },
   "actions": { 
      "HTTP - Check this website": {
         "type": "Http",
         "inputs": {
         "method": "GET",
            "uri": "http://this-url"
         },
         "runAfter": {}
      }
   },
   "else": {
      "actions": {
         "HTTP - Check this other website": {
            "type": "Http",
            "inputs": {
               "method": "GET",
               "uri": "http://this-other-url"
            },
            "runAfter": {}
         }
      }
   },
   "runAfter": {}
}
"Condition": {
   "type": "If",
   "expression": {
      "and": [ {
         "greater": [ "@variables('myIntegerVariable')", 0 ] 
      } ]
   },
   "actions": { 
      "HTTP - Check this website": {
         "type": "Http",
         "inputs": {
         "method": "GET",
            "uri": "http://this-url"
         },
         "runAfter": {}
      }
   },
   "else": {
      "actions": {
         "HTTP - Check this other website": {
            "type": "Http",
            "inputs": {
               "method": "GET",
               "uri": "http://this-other-url"
            },
            "runAfter": {}
         }
      }
   },
   "runAfter": {}
}
Here are some examples that show how you can use expressions in conditions:
empty()
equals()
errors

Scope action
This action logically groups actions intoscopes, which get their own status after the actions in that scope finish running. You can then use the scope's status to determine whether other actions run. Learnhow to create scopes.
"Scope": {
   "type": "Scope",
   "actions": {
      "<inner-action-1>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      },
      "<inner-action-2>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      }
   }
}
"Scope": {
   "type": "Scope",
   "actions": {
      "<inner-action-1>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      },
      "<inner-action-2>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      }
   }
}
Required

Switch action
This action, also known as aswitch statement, organizes other actions intocases, and assigns a value to each case, except for the default case if one exists. When your workflow runs, theSwitchaction compares the value from an expression, object, or token against the values specified for each case. If theSwitchaction finds a matching case, your workflow runs only the actions for that case. Each time theSwitchaction runs, either only one matching case exists or no matches exist. If no matches exist, theSwitchaction runs the default actions. Learnhow to create switch statements.
"Switch": {
   "type": "Switch",
   "expression": "<expression-object-or-token>",
   "cases": {
      "Case": {
         "actions": {
           "<action-name>": { "<action-definition>" }
         },
         "case": "<matching-value>"
      },
      "Case_2": {
         "actions": {
           "<action-name>": { "<action-definition>" }
         },
         "case": "<matching-value>"
      }
   },
   "default": {
      "actions": {
         "<default-action-name>": { "<default-action-definition>" }
      }
   },
   "runAfter": {}
}
"Switch": {
   "type": "Switch",
   "expression": "<expression-object-or-token>",
   "cases": {
      "Case": {
         "actions": {
           "<action-name>": { "<action-definition>" }
         },
         "case": "<matching-value>"
      },
      "Case_2": {
         "actions": {
           "<action-name>": { "<action-definition>" }
         },
         "case": "<matching-value>"
      }
   },
   "default": {
      "actions": {
         "<default-action-name>": { "<default-action-definition>" }
      }
   },
   "runAfter": {}
}
Required
Optional
Example
This action definition evaluates whether the person responding to the approval request email selected the "Approve" option or the "Reject" option. Based on this choice, theSwitchaction runs the actions for the matching case, which is to send another email to the responder but with different wording in each case.
"Switch": {
   "type": "Switch",
   "expression": "@body('Send_approval_email')?['SelectedOption']",
   "cases": {
      "Case": {
         "actions": {
            "Send_an_email": { 
               "type": "ApiConnection",
               "inputs": {
                  "Body": "Thank you for your approval.",
                  "Subject": "Response received", 
                  "To": "Sophie.Owen@contoso.com"
               },
               "host": {
                  "connection": {
                     "name": "@parameters('$connections')['office365']['connectionId']"
                  }
               },
               "method": "post",
               "path": "/Mail"
            },
            "runAfter": {}
         },
         "case": "Approve"
      },
      "Case_2": {
         "actions": {
            "Send_an_email_2": { 
               "type": "ApiConnection",
               "inputs": {
                  "Body": "Thank you for your response.",
                  "Subject": "Response received", 
                  "To": "Sophie.Owen@contoso.com"
               },
               "host": {
                  "connection": {
                     "name": "@parameters('$connections')['office365']['connectionId']"
                  }
               },
               "method": "post",
               "path": "/Mail"
            },
            "runAfter": {}     
         },
         "case": "Reject"
      }
   },
   "default": {
      "actions": { 
         "Send_an_email_3": { 
            "type": "ApiConnection",
            "inputs": {
               "Body": "Please respond with either 'Approve' or 'Reject'.",
               "Subject": "Please respond", 
               "To": "Sophie.Owen@contoso.com"
            },
            "host": {
               "connection": {
                  "name": "@parameters('$connections')['office365']['connectionId']"
               }
            },
            "method": "post",
            "path": "/Mail"
         },
         "runAfter": {} 
      }
   },
   "runAfter": {
      "Send_approval_email": [ 
         "Succeeded"
      ]
   }
}
"Switch": {
   "type": "Switch",
   "expression": "@body('Send_approval_email')?['SelectedOption']",
   "cases": {
      "Case": {
         "actions": {
            "Send_an_email": { 
               "type": "ApiConnection",
               "inputs": {
                  "Body": "Thank you for your approval.",
                  "Subject": "Response received", 
                  "To": "Sophie.Owen@contoso.com"
               },
               "host": {
                  "connection": {
                     "name": "@parameters('$connections')['office365']['connectionId']"
                  }
               },
               "method": "post",
               "path": "/Mail"
            },
            "runAfter": {}
         },
         "case": "Approve"
      },
      "Case_2": {
         "actions": {
            "Send_an_email_2": { 
               "type": "ApiConnection",
               "inputs": {
                  "Body": "Thank you for your response.",
                  "Subject": "Response received", 
                  "To": "Sophie.Owen@contoso.com"
               },
               "host": {
                  "connection": {
                     "name": "@parameters('$connections')['office365']['connectionId']"
                  }
               },
               "method": "post",
               "path": "/Mail"
            },
            "runAfter": {}     
         },
         "case": "Reject"
      }
   },
   "default": {
      "actions": { 
         "Send_an_email_3": { 
            "type": "ApiConnection",
            "inputs": {
               "Body": "Please respond with either 'Approve' or 'Reject'.",
               "Subject": "Please respond", 
               "To": "Sophie.Owen@contoso.com"
            },
            "host": {
               "connection": {
                  "name": "@parameters('$connections')['office365']['connectionId']"
               }
            },
            "method": "post",
            "path": "/Mail"
         },
         "runAfter": {} 
      }
   },
   "runAfter": {
      "Send_approval_email": [ 
         "Succeeded"
      ]
   }
}

Until action
This loop action contains actions that run until the specified condition is true. The loop checks the condition as the last step after all other actions have run. You can include more than one action in the"actions"object, and the action must define at least one limit. Learnhow to create "until" loops.
"actions"
"Until": {
   "type": "Until",
   "actions": {
      "<action-name>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      },
      "<action-name>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      }
   },
   "expression": "<condition>",
   "limit": {
      "count": <loop-count>,
      "timeout": "<loop-timeout>"
   },
   "runAfter": {}
}
"Until": {
   "type": "Until",
   "actions": {
      "<action-name>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      },
      "<action-name>": {
         "type": "<action-type>",
         "inputs": { "<action-inputs>" },
         "runAfter": {}
      }
   },
   "expression": "<condition>",
   "limit": {
      "count": <loop-count>,
      "timeout": "<loop-timeout>"
   },
   "runAfter": {}
}
timeout
PT1H
Note
If the expression depends on the output from any action within the Until loop, make sure that you account for any failure that results from that action.
Example
This loop action definition sends an HTTP request to the specified URL until one of these conditions is met:
The request gets a response with the "200 OK" status code.
The loop has run 60 times.
The loop has run for one hour.
"Run_until_loop_succeeds_or_expires": {
    "type": "Until",
    "actions": {
        "HTTP": {
            "type": "Http",
            "inputs": {
                "method": "GET",
                "uri": "http://myurl"
            },
            "runAfter": {}
        }
    },
    "expression": "@equals(outputs('HTTP')['statusCode'], 200)",
    "limit": {
        "count": 60,
        "timeout": "PT1H"
    },
    "runAfter": {}
}
"Run_until_loop_succeeds_or_expires": {
    "type": "Until",
    "actions": {
        "HTTP": {
            "type": "Http",
            "inputs": {
                "method": "GET",
                "uri": "http://myurl"
            },
            "runAfter": {}
        }
    },
    "expression": "@equals(outputs('HTTP')['statusCode'], 200)",
    "limit": {
        "count": 60,
        "timeout": "PT1H"
    },
    "runAfter": {}
}

Webhooks and subscriptions
Webhook-based triggers and actions don't regularly check endpoints, but wait for specific events or data at those endpoints instead. These triggers and actionssubscribeto the endpoints by providing acallback URLwhere the endpoint can send responses.
Thesubscribecall happens when the workflow changes in any way, for example, when credentials are renewed, or when the input parameters change for  a trigger or action. This call uses the same parameters as standard HTTP actions.
subscribe
Theunsubscribecall automatically happens when an operation makes the trigger or action invalid, for example:
unsubscribe
Deleting or disabling the trigger.
Deleting or disabling the workflow.
Deleting or disabling the subscription.
To support these calls, the@listCallbackUrl()expression returns a unique "callback URL" for the trigger or action. This URL represents a unique identifier for the endpoints that use the service's REST API. The parameters for this function are the same as the webhook trigger or action.
@listCallbackUrl()

Change asynchronous duration
For both triggers and actions, you can limit the duration for the asynchronous pattern to a specific time interval by adding thelimit.timeoutproperty. That way, if the action hasn't finished when the interval lapses, the action's status is marked asCancelledwith theActionTimedOutcode. Thetimeoutproperty usesISO 8601 format.
limit.timeout
Cancelled
ActionTimedOut
timeout
"<trigger-or-action-name>": {
   "type": "Workflow | Webhook | Http | ApiConnectionWebhook | ApiConnection",
   "inputs": {},
   "limit": {
      "timeout": "PT10S"
   },
   "runAfter": {}
}
"<trigger-or-action-name>": {
   "type": "Workflow | Webhook | Http | ApiConnectionWebhook | ApiConnection",
   "inputs": {},
   "limit": {
      "timeout": "PT10S"
   },
   "runAfter": {}
}

Runtime configuration settings
You can change the default runtime behavior for triggers and actions by adding theseruntimeConfigurationproperties to the trigger or action definition.
runtimeConfiguration
runtimeConfiguration.concurrency.runs
runs
1
operationOptions
SingleInstance
runtimeConfiguration.concurrency.maximumWaitingRuns
runtimeConfiguration.concurrency.repetitions
repetitions
1
operationOptions
SingleInstance
runtimeConfiguration.paginationPolicy.minimumItemCount
runtimeConfiguration.secureData.properties
runtimeConfiguration.staticResult
staticResult
name
staticResults
definition
staticResultOptions
Enabled

Operation options
You can change the default behavior for triggers and actions with theoperationOptionsproperty in trigger or action definition.
operationOptions
DisableAsyncPattern
IncludeAuthorizationHeadersInOutputs
Authorization
Sequential
runtimeConfiguration.concurrency.repetitions
1
SingleInstance
runtimeConfiguration.concurrency.runs
1
SuppressWorkflowHeaders
x-ms-*
x-ms-
SuppressWorkflowHeadersOnResponse
x-ms-*
x-ms-

Change trigger concurrency
By default, logic app workflow instances all run at the same time (concurrently or in parallel). This behavior means that each trigger instance fires before the previously active workflow instance finishes running. However, the number of concurrently running instances has adefault limit. When the number of concurrently running workflow instances reaches this limit, any other new instances must wait to run. This limit helps control the number of requests that backend systems receive.
When you turn on the trigger's concurrency control, trigger instances run in parallel up to thedefault limit. To change this default concurrency limit, you can use either the code view editor or the workflow designer because changing the concurrency setting through the designer adds or updates theruntimeConfiguration.concurrency.runsproperty in the underlying trigger definition and vice versa. This property controls the maximum number of new workflow instances that can run in parallel.
runtimeConfiguration.concurrency.runs
Before you enable concurrency on a trigger, review the following considerations:
You can't disable concurrency after you enable the concurrency control.
You can't disable concurrency after you enable the concurrency control.
If the maximum number of concurrent trigger runs reaches the maximum degree of parallelism, subsequent trigger runs might experience throttling or "429 - Too many requests" errors. If you set up aretry policy that handles 429 errors, the trigger might experience a cycle of retry and throttling behavior that causes long delays in processing new trigger requests.
If the maximum number of concurrent trigger runs reaches the maximum degree of parallelism, subsequent trigger runs might experience throttling or "429 - Too many requests" errors. If you set up aretry policy that handles 429 errors, the trigger might experience a cycle of retry and throttling behavior that causes long delays in processing new trigger requests.
When concurrency is enabled, theSplitOn limitis significantly reduced fordebatching arrays. If the number of items exceeds this limit, the SplitOn capability is disabled.
When concurrency is enabled, theSplitOn limitis significantly reduced fordebatching arrays. If the number of items exceeds this limit, the SplitOn capability is disabled.
When concurrency is enabled, a long-running logic app instance might cause new logic app instances to enter a waiting state. This state prevents Azure Logic Apps from creating new instances and happens even when the number of concurrent runs is less than the specified maximum number of concurrent runs.To interrupt this state, cancel the earliest instances that arestill running.On your logic app's menu, selectOverview.In theRuns historysection, select the earliest instance that is still running, for example:TipTo view only instances that are still running, open theAlllist, and selectRunning.UnderLogic app run, selectCancel run.To work around this possibility, add a timeout to any action that might hold up these runs. If you're working in the code editor, seeChange asynchronous duration. Otherwise, if you're using the designer, follow these steps:In your logic app workflow, select the action where you want to add a timeout. In the action's upper-right corner, select the ellipses (...) button, and then selectSettings.UnderTimeout, specify the timeout duration inISO 8601 format.
When concurrency is enabled, a long-running logic app instance might cause new logic app instances to enter a waiting state. This state prevents Azure Logic Apps from creating new instances and happens even when the number of concurrent runs is less than the specified maximum number of concurrent runs.
To interrupt this state, cancel the earliest instances that arestill running.On your logic app's menu, selectOverview.In theRuns historysection, select the earliest instance that is still running, for example:TipTo view only instances that are still running, open theAlllist, and selectRunning.UnderLogic app run, selectCancel run.
To interrupt this state, cancel the earliest instances that arestill running.
On your logic app's menu, selectOverview.
On your logic app's menu, selectOverview.
In theRuns historysection, select the earliest instance that is still running, for example:TipTo view only instances that are still running, open theAlllist, and selectRunning.
In theRuns historysection, select the earliest instance that is still running, for example:

Tip
To view only instances that are still running, open theAlllist, and selectRunning.
UnderLogic app run, selectCancel run.
UnderLogic app run, selectCancel run.

To work around this possibility, add a timeout to any action that might hold up these runs. If you're working in the code editor, seeChange asynchronous duration. Otherwise, if you're using the designer, follow these steps:In your logic app workflow, select the action where you want to add a timeout. In the action's upper-right corner, select the ellipses (...) button, and then selectSettings.UnderTimeout, specify the timeout duration inISO 8601 format.
To work around this possibility, add a timeout to any action that might hold up these runs. If you're working in the code editor, seeChange asynchronous duration. Otherwise, if you're using the designer, follow these steps:
In your logic app workflow, select the action where you want to add a timeout. In the action's upper-right corner, select the ellipses (...) button, and then selectSettings.
In your logic app workflow, select the action where you want to add a timeout. In the action's upper-right corner, select the ellipses (...) button, and then selectSettings.

UnderTimeout, specify the timeout duration inISO 8601 format.
UnderTimeout, specify the timeout duration inISO 8601 format.

To run your logic app sequentially, set the trigger's concurrency to1either by using the code view editor or the designer. Make sure that you don't also set the trigger'soperationOptionsproperty toSingleInstancein the code view editor. Otherwise, you get a validation error. For more information, seeTrigger instances sequentially.
To run your logic app sequentially, set the trigger's concurrency to1either by using the code view editor or the designer. Make sure that you don't also set the trigger'soperationOptionsproperty toSingleInstancein the code view editor. Otherwise, you get a validation error. For more information, seeTrigger instances sequentially.
1
operationOptions
SingleInstance
In the underlying trigger definition, add theruntimeConfiguration.concurrency.runsproperty, and set the value based on thetrigger concurrency limits. To run your workflow sequentially, set the property value to1.
runtimeConfiguration.concurrency.runs
1
This example limits concurrent runs to 10 instances:
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": 10
      }
   }
}
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": 10
      }
   }
}
For more information, seeRuntime configuration settings.
In the trigger's upper-right corner, select the ellipses (...) button, and then selectSettings.
In the trigger's upper-right corner, select the ellipses (...) button, and then selectSettings.
UnderConcurrency Control, setLimittoOn.
UnderConcurrency Control, setLimittoOn.
Drag theDegree of Parallelismslider to the value you want. To run your logic app sequentially, drag the slider value to1.
Drag theDegree of Parallelismslider to the value you want. To run your logic app sequentially, drag the slider value to1.

Change "for each" concurrency
By default, "for each" loop iterations all run at the same time (concurrently or in parallel). This behavior means that each iteration starts running before the previous iteration finishes running. However, the number of concurrently running iterations has adefault limit. When the number of concurrently running iterations reaches this limit, any other iterations must wait to run.
To change the default limit, you can use either the code view editor or the workflow designer because changing the concurrency setting through the designer adds or updates theruntimeConfiguration.concurrency.repetitionsproperty in the underlying "for each" action definition and vice versa. This property controls the maximum number of iterations that can run in parallel.
runtimeConfiguration.concurrency.repetitions
Note
If you set the "for each" action to run sequentially either by using the designer or the code view editor,
don't set the action'soperationOptionsproperty toSequentialin the code view editor. Otherwise,
you get a validation error. For more information, seeRun "for each" loops sequentially.
operationOptions
Sequential
In the underlying "for each" definition, add or update theruntimeConfiguration.concurrency.repetitionsproperty, which can have a value that ranges from1and50.
runtimeConfiguration.concurrency.repetitions
1
50
Here's an example that limits concurrent runs to 10 iterations:
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": 10
      }
   }
}
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": 10
      }
   }
}
For more information, seeRuntime configuration settings.
In theFor eachaction, from the upper-right corner, select the ellipses (...) button, and then selectSettings.
In theFor eachaction, from the upper-right corner, select the ellipses (...) button, and then selectSettings.
UnderConcurrency Control, setConcurrency ControltoOn.
UnderConcurrency Control, setConcurrency ControltoOn.
Drag theDegree of Parallelismslider to the value you want. To run your logic app sequentially, drag the slider value to1.
Drag theDegree of Parallelismslider to the value you want. To run your logic app sequentially, drag the slider value to1.

Change waiting runs limit
By default, logic app workflow instances all run at the same time (concurrently or in parallel). This behavior means that each trigger instance fires before the previously active workflow instance finishes running. However, adefault limitexists on the number of concurrently running workflow instances. When the number of concurrent runs reaches this limit, any other new workflow instances must wait to run. Adefault limitalso exists on the number of waiting workflow instances. When the number of waiting instances reaches this limit, Azure Logic Apps no longer accepts new workflow instances to run. Request and webhook triggers return429 - Too many requestserrors, and recurring triggers start skipping polling attempts.
You canchange the default limit on trigger concurrencyas well as the default limit on waiting runs. However, this change primarily slows down the trigger to relieve the pressure due to concurrency. For example, if you have polling trigger, and the waiting runs queue is full due to in-progress runs, Azure Logic Apps stops polling. If your workflow uses a request-based trigger, and the waiting runs queue is full, Azure Logic Apps starts returning the 429 error. Some scenarios exist where Azure Logic Apps can't stop the trigger from polling without introducing failures and opts to add such runs to the waiting runs queue anyway without failing the calling runs.
In the underlying trigger definition, add theruntimeConfiguration.concurrency.maximumWaitingRunsproperty, which can have a value that ranges from1to100.
runtimeConfiguration.concurrency.maximumWaitingRuns
1
100
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "maximumWaitingRuns": 50
      }
   }
}
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "maximumWaitingRuns": 50
      }
   }
}
For more information, seeRuntime configuration settings.

Trigger instances sequentially
To run each logic app workflow instance only after the previous instance finishes running, set the trigger to run sequentially. You can use either the code view editor or the workflow designer because changing the concurrency setting through designer also adds or updates theruntimeConfiguration.concurrency.runsproperty in the underlying trigger definition and vice versa.
runtimeConfiguration.concurrency.runs
Note
When you set a trigger to run sequentially either by using the designer or the code view editor,
don't set the trigger'soperationOptionsproperty toSequentialin the code view editor.
Otherwise, you get a validation error.
operationOptions
Sequential
In the trigger definition, set either of these properties, but not both.
Set theruntimeConfiguration.concurrency.runsproperty to1:
runtimeConfiguration.concurrency.runs
1
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": 1
      }
   }
}
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "runtimeConfiguration": {
      "concurrency": {
         "runs": 1
      }
   }
}
-or-
Set theoperationOptionsproperty toSingleInstance:
operationOptions
SingleInstance
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "operationOptions": "SingleInstance"
}
"<trigger-name>": {
   "type": "<trigger-name>",
   "recurrence": {
      "frequency": "<time-unit>",
      "interval": <number-of-time-units>,
   },
   "operationOptions": "SingleInstance"
}
For more information, seeRuntime configuration settingsandOperation options.
In the trigger's upper-right corner, select the ellipses (...) button, and then selectSettings.
In the trigger's upper-right corner, select the ellipses (...) button, and then selectSettings.
UnderConcurrency Control, setLimittoOn.
UnderConcurrency Control, setLimittoOn.
Drag theDegree of Parallelismslider to the number1.
Drag theDegree of Parallelismslider to the number1.
1

Run "for each" loops sequentially
To run a "for each" loop iteration only after the previous iteration finishes running, set the "for each" action to run sequentially. You can use either the code view editor or the workflow designer because changing the action's concurrency through designer also adds or updates theruntimeConfiguration.concurrency.repetitionsproperty in the underlying action definition and vice versa.
runtimeConfiguration.concurrency.repetitions
Note
When you set a "for each" action to run sequentially either by using the designer or code view editor,
don't set the action'soperationOptionsproperty toSequentialin the code view editor.
Otherwise, you get a validation error.
operationOptions
Sequential
In the action definition, set either of these properties, but not both.
Set theruntimeConfiguration.concurrency.repetitionsproperty to1:
runtimeConfiguration.concurrency.repetitions
1
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": 1
      }
   }
}
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "runtimeConfiguration": {
      "concurrency": {
         "repetitions": 1
      }
   }
}
-or-
Set theoperationOptionsproperty toSequential:
operationOptions
Sequential
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "operationOptions": "Sequential"
}
"For_each" {
   "type": "Foreach",
   "actions": { "<actions-to-run>" },
   "foreach": "<for-each-expression>",
   "runAfter": {},
   "operationOptions": "Sequential"
}
For more information, seeRuntime configuration settingsandOperation options.
In theFor eachaction's upper-right corner, select the ellipses (...) button, and then selectSettings.
In theFor eachaction's upper-right corner, select the ellipses (...) button, and then selectSettings.
UnderConcurrency Control, setConcurrency ControltoOn.
UnderConcurrency Control, setConcurrency ControltoOn.
Drag theDegree of Parallelismslider to the number1.
Drag theDegree of Parallelismslider to the number1.
1

Run actions in a synchronous operation pattern
By default, the HTTP action and APIConnection actions in Azure Logic Apps follow the standardasynchronous operation pattern, while the Response action follows thesynchronous operation pattern. The asynchronous pattern specifies that after an action calls or sends a request to the specified endpoint, service, system, or API, the receiver immediately returns a"202 ACCEPTED"response. This code confirms that the receiver accepted the request but hasn't finished processing. The response can include alocationheader that specifies the URL and a refresh ID that the caller can use to continually poll or check the status for the asynchronous request until the receiver stops processing and returns a"200 OK"success response or other non-202 response. For more information, seeAsynchronous microservice integration enforces microservice autonomy.
location
In the Logic App Designer, the HTTP action, APIConnection actions, and Response action have theAsynchronous Patternsetting. When enabled, this setting specifies that the caller doesn't wait for processing to finish and can move on to the next action but continues checking the status until processing stops. If disabled, this setting specifies that the caller waits for processing to finish before moving on to the next action. To find this setting, follow these steps:On the HTTP action's title bar, select the ellipses (...) button, which opens the action's settings.Find theAsynchronous Patternsetting.
In the Logic App Designer, the HTTP action, APIConnection actions, and Response action have theAsynchronous Patternsetting. When enabled, this setting specifies that the caller doesn't wait for processing to finish and can move on to the next action but continues checking the status until processing stops. If disabled, this setting specifies that the caller waits for processing to finish before moving on to the next action. To find this setting, follow these steps:
On the HTTP action's title bar, select the ellipses (...) button, which opens the action's settings.
On the HTTP action's title bar, select the ellipses (...) button, which opens the action's settings.
Find theAsynchronous Patternsetting.
Find theAsynchronous Patternsetting.

In the action's underlying JavaScript Object Notation (JSON) definition, the HTTP action and APIConnection actions implicitly follow the asynchronous operation pattern.
In the action's underlying JavaScript Object Notation (JSON) definition, the HTTP action and APIConnection actions implicitly follow the asynchronous operation pattern.
In some scenarios, you might want an action to follow the synchronous pattern instead. For example, when you use the HTTP action, you might want to:
Avoid HTTP timeouts for long-running tasks
Disable checking location headers
In these cases, you can make an action run synchronously by using these options:
Replace the polling version of that action with a webhook version, if available.
Replace the polling version of that action with a webhook version, if available.
Disable the action's asynchronous behavior by following either option:In the Logic App Designer,turn off theAsynchronous Patternsetting.In the action's underlying JSON definition,add the"DisableAsyncPattern"operation option.
Disable the action's asynchronous behavior by following either option:
In the Logic App Designer,turn off theAsynchronous Patternsetting.
In the Logic App Designer,turn off theAsynchronous Patternsetting.
In the action's underlying JSON definition,add the"DisableAsyncPattern"operation option.
In the action's underlying JSON definition,add the"DisableAsyncPattern"operation option.
"DisableAsyncPattern"

In the Logic App Designer, on the action's title bar, select the ellipses (...) button, which opens the action's settings.
In the Logic App Designer, on the action's title bar, select the ellipses (...) button, which opens the action's settings.
Find theAsynchronous Patternsetting, turn the setting toOffif enabled, and selectDone.
Find theAsynchronous Patternsetting, turn the setting toOffif enabled, and selectDone.


In the action's underlying JSON definition, add and set the"operationOptions" propertyto"DisableAsyncPattern"under the action's"inputs"section, for example:
"DisableAsyncPattern"
"inputs"
"<some-long-running-action>": {
   "type": "Http",
   "inputs": { "<action-inputs>" },
   "operationOptions": "DisableAsyncPattern",
   "runAfter": {}
}
"<some-long-running-action>": {
   "type": "Http",
   "inputs": { "<action-inputs>" },
   "operationOptions": "DisableAsyncPattern",
   "runAfter": {}
}

Authenticate triggers and actions
HTTP and HTTPS endpoints support different kinds of authentication. Based on the trigger or action that you use to make outbound calls or requests to access these endpoints, you can select from different ranges of authentication types. For more information, seeAdd authentication to outbound calls.
Next steps
Learn more aboutWorkflow Definition Language
Feedback
Was this page helpful?
Additional resources