Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Use TLS with an ingress controller on Azure Kubernetes Service (AKS)
Article
2024-03-14
2 contributors
In this article
The transport layer security (TLS) protocol uses certificates to provide security for communication, encryption, authentication, and integrity. Using TLS with an ingress controller on AKS allows you to secure communication between your applications and experience the benefits of an ingress controller.
You can bring your own certificates and integrate them with the Secrets Store CSI driver. Alternatively, you can usecert-manager, which automatically generates and configuresLet's Encryptcertificates. Two applications run in the AKS cluster, each of which is accessible over a single IP address.
Important
The Application routing add-on is recommended for ingress in AKS. For more information, seeManaged nginx Ingress with the application routing add-on.
Important
Microsoftdoes notmanage or support cert-manager and any issues stemming from its use. For issues with cert-manager, seecert-manager troubleshootingdocumentation.
There are two open source ingress controllers for Kubernetes based on Nginx: one is maintained by the Kubernetes community (kubernetes/ingress-nginx), and one is maintained by NGINX, Inc. (nginxinc/kubernetes-ingress). This article uses theKubernetes community ingress controller.
Before you begin
This article assumes you have an ingress controller and applications set up. If you need an ingress controller or example applications, seeCreate an ingress controller.
This article assumes you have an ingress controller and applications set up. If you need an ingress controller or example applications, seeCreate an ingress controller.
This article usesHelm 3to install the NGINX ingress controller on asupported version of Kubernetes. Make sure you're using the latest release of Helm and have access to theingress-nginxandjetstackHelm repositories. The steps outlined in this article may not be compatible with previous versions of the Helm chart, NGINX ingress controller, or Kubernetes.For more information on configuring and using Helm, seeInstall applications with Helm in AKS. For upgrade instructions, see theHelm install docs.
This article usesHelm 3to install the NGINX ingress controller on asupported version of Kubernetes. Make sure you're using the latest release of Helm and have access to theingress-nginxandjetstackHelm repositories. The steps outlined in this article may not be compatible with previous versions of the Helm chart, NGINX ingress controller, or Kubernetes.
ingress-nginx
jetstack
For more information on configuring and using Helm, seeInstall applications with Helm in AKS. For upgrade instructions, see theHelm install docs.
This article assumes you have an existing AKS cluster with an integrated Azure Container Registry (ACR). For more information on creating an AKS cluster with an integrated ACR, seeAuthenticate with ACR from AKS.
This article assumes you have an existing AKS cluster with an integrated Azure Container Registry (ACR). For more information on creating an AKS cluster with an integrated ACR, seeAuthenticate with ACR from AKS.
If you're using Azure CLI, this article requires that you're running the Azure CLI version 2.0.64 or later. Runaz --versionto find the version. If you need to install or upgrade, seeInstall Azure CLI.
If you're using Azure CLI, this article requires that you're running the Azure CLI version 2.0.64 or later. Runaz --versionto find the version. If you need to install or upgrade, seeInstall Azure CLI.
az --version
If you're using Azure PowerShell, this article requires that you're running Azure PowerShell version 5.9.0 or later. RunGet-InstalledModule -Name Azto find the version. If you need to install or upgrade, seeInstall Azure PowerShell.
If you're using Azure PowerShell, this article requires that you're running Azure PowerShell version 5.9.0 or later. RunGet-InstalledModule -Name Azto find the version. If you need to install or upgrade, seeInstall Azure PowerShell.
Get-InstalledModule -Name Az
Use TLS with your own certificates with Secrets Store CSI Driver
To use TLS with your own certificates with Secrets Store CSI Driver, you need an AKS cluster with the Secrets Store CSI Driver configured and an Azure Key Vault instance.
For more information, seeSet up Secrets Store CSI Driver to enable NGINX Ingress Controller with TLS.
Use TLS with Let's Encrypt certificates
To use TLS withLet's Encryptcertificates, you'll deploycert-manager, which automatically generates and configures Let's Encrypt certificates.
Import the cert-manager images used by the Helm chart into your ACR
Azure CLI
Azure PowerShell
Useaz acr importto import the following images into your ACR.REGISTRY_NAME=<REGISTRY_NAME>
CERT_MANAGER_REGISTRY=quay.io
CERT_MANAGER_TAG=v1.8.0
CERT_MANAGER_IMAGE_CONTROLLER=jetstack/cert-manager-controller
CERT_MANAGER_IMAGE_WEBHOOK=jetstack/cert-manager-webhook
CERT_MANAGER_IMAGE_CAINJECTOR=jetstack/cert-manager-cainjector

az acr import --name $REGISTRY_NAME --source $CERT_MANAGER_REGISTRY/$CERT_MANAGER_IMAGE_CONTROLLER:$CERT_MANAGER_TAG --image $CERT_MANAGER_IMAGE_CONTROLLER:$CERT_MANAGER_TAG
az acr import --name $REGISTRY_NAME --source $CERT_MANAGER_REGISTRY/$CERT_MANAGER_IMAGE_WEBHOOK:$CERT_MANAGER_TAG --image $CERT_MANAGER_IMAGE_WEBHOOK:$CERT_MANAGER_TAG
az acr import --name $REGISTRY_NAME --source $CERT_MANAGER_REGISTRY/$CERT_MANAGER_IMAGE_CAINJECTOR:$CERT_MANAGER_TAG --image $CERT_MANAGER_IMAGE_CAINJECTOR:$CERT_MANAGER_TAG
Useaz acr importto import the following images into your ACR.
az acr import
REGISTRY_NAME=<REGISTRY_NAME>
CERT_MANAGER_REGISTRY=quay.io
CERT_MANAGER_TAG=v1.8.0
CERT_MANAGER_IMAGE_CONTROLLER=jetstack/cert-manager-controller
CERT_MANAGER_IMAGE_WEBHOOK=jetstack/cert-manager-webhook
CERT_MANAGER_IMAGE_CAINJECTOR=jetstack/cert-manager-cainjector

az acr import --name $REGISTRY_NAME --source $CERT_MANAGER_REGISTRY/$CERT_MANAGER_IMAGE_CONTROLLER:$CERT_MANAGER_TAG --image $CERT_MANAGER_IMAGE_CONTROLLER:$CERT_MANAGER_TAG
az acr import --name $REGISTRY_NAME --source $CERT_MANAGER_REGISTRY/$CERT_MANAGER_IMAGE_WEBHOOK:$CERT_MANAGER_TAG --image $CERT_MANAGER_IMAGE_WEBHOOK:$CERT_MANAGER_TAG
az acr import --name $REGISTRY_NAME --source $CERT_MANAGER_REGISTRY/$CERT_MANAGER_IMAGE_CAINJECTOR:$CERT_MANAGER_TAG --image $CERT_MANAGER_IMAGE_CAINJECTOR:$CERT_MANAGER_TAG
REGISTRY_NAME=<REGISTRY_NAME>
CERT_MANAGER_REGISTRY=quay.io
CERT_MANAGER_TAG=v1.8.0
CERT_MANAGER_IMAGE_CONTROLLER=jetstack/cert-manager-controller
CERT_MANAGER_IMAGE_WEBHOOK=jetstack/cert-manager-webhook
CERT_MANAGER_IMAGE_CAINJECTOR=jetstack/cert-manager-cainjector

az acr import --name $REGISTRY_NAME --source $CERT_MANAGER_REGISTRY/$CERT_MANAGER_IMAGE_CONTROLLER:$CERT_MANAGER_TAG --image $CERT_MANAGER_IMAGE_CONTROLLER:$CERT_MANAGER_TAG
az acr import --name $REGISTRY_NAME --source $CERT_MANAGER_REGISTRY/$CERT_MANAGER_IMAGE_WEBHOOK:$CERT_MANAGER_TAG --image $CERT_MANAGER_IMAGE_WEBHOOK:$CERT_MANAGER_TAG
az acr import --name $REGISTRY_NAME --source $CERT_MANAGER_REGISTRY/$CERT_MANAGER_IMAGE_CAINJECTOR:$CERT_MANAGER_TAG --image $CERT_MANAGER_IMAGE_CAINJECTOR:$CERT_MANAGER_TAG
UseImport-AzContainerRegistryImageto import the following images into your ACR.NoteWhen performing the steps to import the images into your ACR when working in Azure Government, you need to include thetargetTagparameter with the value representing the tag of the image you want to import.$RegistryName = "<REGISTRY_NAME>"
$ResourceGroup = (Get-AzContainerRegistry | Where-Object {$_.name -eq $RegistryName} ).ResourceGroupName
$CertManagerRegistry = "quay.io"
$CertManagerTag = "v1.8.0"
$CertManagerImageController = "jetstack/cert-manager-controller"
$CertManagerImageWebhook = "jetstack/cert-manager-webhook"
$CertManagerImageCaInjector = "jetstack/cert-manager-cainjector"

Import-AzContainerRegistryImage -ResourceGroupName $ResourceGroup -RegistryName $RegistryName -SourceRegistryUri $CertManagerRegistry -SourceImage "${CertManagerImageController}:${CertManagerTag}"
Import-AzContainerRegistryImage -ResourceGroupName $ResourceGroup -RegistryName $RegistryName -SourceRegistryUri $CertManagerRegistry -SourceImage "${CertManagerImageWebhook}:${CertManagerTag}"
Import-AzContainerRegistryImage -ResourceGroupName $ResourceGroup -RegistryName $RegistryName -SourceRegistryUri $CertManagerRegistry -SourceImage "${CertManagerImageCaInjector}:${CertManagerTag}"
UseImport-AzContainerRegistryImageto import the following images into your ACR.
Import-AzContainerRegistryImage
Note
When performing the steps to import the images into your ACR when working in Azure Government, you need to include thetargetTagparameter with the value representing the tag of the image you want to import.
targetTag
$RegistryName = "<REGISTRY_NAME>"
$ResourceGroup = (Get-AzContainerRegistry | Where-Object {$_.name -eq $RegistryName} ).ResourceGroupName
$CertManagerRegistry = "quay.io"
$CertManagerTag = "v1.8.0"
$CertManagerImageController = "jetstack/cert-manager-controller"
$CertManagerImageWebhook = "jetstack/cert-manager-webhook"
$CertManagerImageCaInjector = "jetstack/cert-manager-cainjector"

Import-AzContainerRegistryImage -ResourceGroupName $ResourceGroup -RegistryName $RegistryName -SourceRegistryUri $CertManagerRegistry -SourceImage "${CertManagerImageController}:${CertManagerTag}"
Import-AzContainerRegistryImage -ResourceGroupName $ResourceGroup -RegistryName $RegistryName -SourceRegistryUri $CertManagerRegistry -SourceImage "${CertManagerImageWebhook}:${CertManagerTag}"
Import-AzContainerRegistryImage -ResourceGroupName $ResourceGroup -RegistryName $RegistryName -SourceRegistryUri $CertManagerRegistry -SourceImage "${CertManagerImageCaInjector}:${CertManagerTag}"
$RegistryName = "<REGISTRY_NAME>"
$ResourceGroup = (Get-AzContainerRegistry | Where-Object {$_.name -eq $RegistryName} ).ResourceGroupName
$CertManagerRegistry = "quay.io"
$CertManagerTag = "v1.8.0"
$CertManagerImageController = "jetstack/cert-manager-controller"
$CertManagerImageWebhook = "jetstack/cert-manager-webhook"
$CertManagerImageCaInjector = "jetstack/cert-manager-cainjector"

Import-AzContainerRegistryImage -ResourceGroupName $ResourceGroup -RegistryName $RegistryName -SourceRegistryUri $CertManagerRegistry -SourceImage "${CertManagerImageController}:${CertManagerTag}"
Import-AzContainerRegistryImage -ResourceGroupName $ResourceGroup -RegistryName $RegistryName -SourceRegistryUri $CertManagerRegistry -SourceImage "${CertManagerImageWebhook}:${CertManagerTag}"
Import-AzContainerRegistryImage -ResourceGroupName $ResourceGroup -RegistryName $RegistryName -SourceRegistryUri $CertManagerRegistry -SourceImage "${CertManagerImageCaInjector}:${CertManagerTag}"
Note
You can also import Helm charts into your ACR. For more information, seePush and pull Helm charts to an ACR.
Ingress controller configuration options
You can configure your NGINX ingress controller using either a static public IP address or a dynamic public IP address. If you're using a custom domain, you need to add an A record to your DNS zone. If you're not using a custom domain, you can configure a fully qualified domain name (FQDN) for the ingress controller IP address.
Create a static or dynamic public IP address
You can configure your ingress controller with a static public IP address. The static public IP address remains if you delete your ingress controller. The IP addressdoesn'tremain if you delete your AKS cluster.
When you upgrade your ingress controller, you must pass a parameter to the Helm release to ensure the ingress controller service is made aware of the load balancer that will be allocated to it. For the HTTPS certificates to work correctly, you use a DNS label to configure an FQDN for the ingress controller IP address.
Azure CLI
Azure PowerShell
Get the resource group name of the AKS cluster with theaz aks showcommand.az aks show --resource-group myResourceGroup --name myAKSCluster --query nodeResourceGroup -o tsv
Get the resource group name of the AKS cluster with theaz aks showcommand.
az aks show
az aks show --resource-group myResourceGroup --name myAKSCluster --query nodeResourceGroup -o tsv
az aks show --resource-group myResourceGroup --name myAKSCluster --query nodeResourceGroup -o tsv
Create a public IP address with thestaticallocation method using theaz network public-ip createcommand. The following example creates a public IP address namedmyAKSPublicIPin the AKS cluster resource group obtained in the previous step.az network public-ip create --resource-group MC_myResourceGroup_myAKSCluster_eastus --name myAKSPublicIP --sku Standard --allocation-method static --query publicIp.ipAddress -o tsv
Create a public IP address with thestaticallocation method using theaz network public-ip createcommand. The following example creates a public IP address namedmyAKSPublicIPin the AKS cluster resource group obtained in the previous step.
az network public-ip create
az network public-ip create --resource-group MC_myResourceGroup_myAKSCluster_eastus --name myAKSPublicIP --sku Standard --allocation-method static --query publicIp.ipAddress -o tsv
az network public-ip create --resource-group MC_myResourceGroup_myAKSCluster_eastus --name myAKSPublicIP --sku Standard --allocation-method static --query publicIp.ipAddress -o tsv
Note
Alternatively, you can create an IP address in a different resource group, which you can manage separately from your AKS cluster. If you create an IP address in a different resource group, ensure the following are true:
The cluster identity used by the AKS cluster has delegated permissions to the resource group, such asNetwork Contributor.
Add the--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-resource-group"="<RESOURCE_GROUP>"parameter. Replace<RESOURCE_GROUP>with the name of the resource group where the IP address resides.
--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-resource-group"="<RESOURCE_GROUP>"
<RESOURCE_GROUP>
Add the--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"="<DNS_LABEL>"parameter. The DNS label can be set either when the ingress controller is first deployed, or it can be configured later.
Add the--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"="<DNS_LABEL>"parameter. The DNS label can be set either when the ingress controller is first deployed, or it can be configured later.
--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"="<DNS_LABEL>"
Add the--set controller.service.loadBalancerIP="<STATIC_IP>"parameter. Specify your own public IP address that was created in the previous step.DNS_LABEL="<DNS_LABEL>"
NAMESPACE="ingress-basic"
STATIC_IP=<STATIC_IP>

helm upgrade ingress-nginx ingress-nginx/ingress-nginx \
  --namespace $NAMESPACE \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"=$DNS_LABEL \
  --set controller.service.loadBalancerIP=$STATIC_IP \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
Add the--set controller.service.loadBalancerIP="<STATIC_IP>"parameter. Specify your own public IP address that was created in the previous step.
--set controller.service.loadBalancerIP="<STATIC_IP>"
DNS_LABEL="<DNS_LABEL>"
NAMESPACE="ingress-basic"
STATIC_IP=<STATIC_IP>

helm upgrade ingress-nginx ingress-nginx/ingress-nginx \
  --namespace $NAMESPACE \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"=$DNS_LABEL \
  --set controller.service.loadBalancerIP=$STATIC_IP \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
DNS_LABEL="<DNS_LABEL>"
NAMESPACE="ingress-basic"
STATIC_IP=<STATIC_IP>

helm upgrade ingress-nginx ingress-nginx/ingress-nginx \
  --namespace $NAMESPACE \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"=$DNS_LABEL \
  --set controller.service.loadBalancerIP=$STATIC_IP \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
Get the resource group name of the AKS cluster with theGet-AzAksClustercommand.(Get-AzAksCluster -ResourceGroupName $ResourceGroup -Name myAKSCluster).NodeResourceGroup
Get the resource group name of the AKS cluster with theGet-AzAksClustercommand.
Get-AzAksCluster
(Get-AzAksCluster -ResourceGroupName $ResourceGroup -Name myAKSCluster).NodeResourceGroup
(Get-AzAksCluster -ResourceGroupName $ResourceGroup -Name myAKSCluster).NodeResourceGroup
Create a public IP address with thestaticallocation method using theNew-AzPublicIpAddresscommand. The following example creates a public IP address namedmyAKSPublicIPin the AKS cluster resource group obtained in the previous step.(New-AzPublicIpAddress -ResourceGroupName MC_myResourceGroup_myAKSCluster_eastus -Name myAKSPublicIP -Sku Standard -AllocationMethod Static -Location eastus).IpAddress
Create a public IP address with thestaticallocation method using theNew-AzPublicIpAddresscommand. The following example creates a public IP address namedmyAKSPublicIPin the AKS cluster resource group obtained in the previous step.
New-AzPublicIpAddress
(New-AzPublicIpAddress -ResourceGroupName MC_myResourceGroup_myAKSCluster_eastus -Name myAKSPublicIP -Sku Standard -AllocationMethod Static -Location eastus).IpAddress
(New-AzPublicIpAddress -ResourceGroupName MC_myResourceGroup_myAKSCluster_eastus -Name myAKSPublicIP -Sku Standard -AllocationMethod Static -Location eastus).IpAddress
Note
Alternatively, you can create an IP address in a different resource group, which you can manage separately from your AKS cluster. If you create an IP address in a different resource group, ensure the following are true:
The cluster identity used by the AKS cluster has delegated permissions to the resource group, such asNetwork Contributor.
Add the--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-resource-group"="<RESOURCE_GROUP>"parameter. Replace<RESOURCE_GROUP>with the name of the resource group where the IP address resides.
--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-resource-group"="<RESOURCE_GROUP>"
<RESOURCE_GROUP>
Add the--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"="<DNS_LABEL>"parameter. The DNS label can be set either when the ingress controller is first deployed, or it can be configured later.
Add the--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"="<DNS_LABEL>"parameter. The DNS label can be set either when the ingress controller is first deployed, or it can be configured later.
--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"="<DNS_LABEL>"
Add the--set controller.service.loadBalancerIP="<STATIC_IP>"parameter. Specify your own public IP address that was created in the previous step.$DnsLabel = "<DNS_LABEL>"
$Namespace = "ingress-basic"
$StaticIP = "<STATIC_IP>"

helm upgrade ingress-nginx ingress-nginx/ingress-nginx `
  --namespace $Namespace `
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"=$DnsLabel `
  --set controller.service.loadBalancerIP=$StaticIP `
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
Add the--set controller.service.loadBalancerIP="<STATIC_IP>"parameter. Specify your own public IP address that was created in the previous step.
--set controller.service.loadBalancerIP="<STATIC_IP>"
$DnsLabel = "<DNS_LABEL>"
$Namespace = "ingress-basic"
$StaticIP = "<STATIC_IP>"

helm upgrade ingress-nginx ingress-nginx/ingress-nginx `
  --namespace $Namespace `
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"=$DnsLabel `
  --set controller.service.loadBalancerIP=$StaticIP `
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
$DnsLabel = "<DNS_LABEL>"
$Namespace = "ingress-basic"
$StaticIP = "<STATIC_IP>"

helm upgrade ingress-nginx ingress-nginx/ingress-nginx `
  --namespace $Namespace `
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"=$DnsLabel `
  --set controller.service.loadBalancerIP=$StaticIP `
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
For more information, seeUse a static public IP address and DNS label with the AKS load balancer.
An Azure public IP address is created for your ingress controller upon creation. The public IP address is static for the lifespan of your ingress controller. The public IP addressdoesn'tremain if you delete your ingress controller. If you create a new ingress controller, it will be assigned a new public IP address. Your output should look similar to the following sample output.
Use thekubectl get servicecommand to get the public IP address for your ingress controller.# Get the public IP address for your ingress controller

kubectl --namespace ingress-basic get services -o wide -w nginx-ingress-ingress-nginx-controller

# Sample output

NAME                                     TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)                      AGE   SELECTOR
nginx-ingress-ingress-nginx-controller   LoadBalancer   10.0.74.133   EXTERNAL_IP     80:32486/TCP,443:30953/TCP   44s   app.kubernetes.io/component=controller,app.kubernetes.io/instance=nginx-ingress,app.kubernetes.io/name=ingress-nginx
Use thekubectl get servicecommand to get the public IP address for your ingress controller.
kubectl get service
# Get the public IP address for your ingress controller

kubectl --namespace ingress-basic get services -o wide -w nginx-ingress-ingress-nginx-controller

# Sample output

NAME                                     TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)                      AGE   SELECTOR
nginx-ingress-ingress-nginx-controller   LoadBalancer   10.0.74.133   EXTERNAL_IP     80:32486/TCP,443:30953/TCP   44s   app.kubernetes.io/component=controller,app.kubernetes.io/instance=nginx-ingress,app.kubernetes.io/name=ingress-nginx
# Get the public IP address for your ingress controller

kubectl --namespace ingress-basic get services -o wide -w nginx-ingress-ingress-nginx-controller

# Sample output

NAME                                     TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)                      AGE   SELECTOR
nginx-ingress-ingress-nginx-controller   LoadBalancer   10.0.74.133   EXTERNAL_IP     80:32486/TCP,443:30953/TCP   44s   app.kubernetes.io/component=controller,app.kubernetes.io/instance=nginx-ingress,app.kubernetes.io/name=ingress-nginx
Add an A record to your DNS zone
If you're using a custom domain, you need to add anArecord to your DNS zone. If you're not using a custom domain, you can configure the public IP address with an FQDN.
Azure CLI
Azure PowerShell
Add anArecord to your DNS zone with the external IP address of the NGINX service usingaz network dns record-set a add-record.az network dns record-set a add-record \
    --resource-group myResourceGroup \
    --zone-name MY_CUSTOM_DOMAIN \
    --record-set-name "*" \
    --ipv4-address MY_EXTERNAL_IP
Add anArecord to your DNS zone with the external IP address of the NGINX service usingaz network dns record-set a add-record.
az network dns record-set a add-record
az network dns record-set a add-record \
    --resource-group myResourceGroup \
    --zone-name MY_CUSTOM_DOMAIN \
    --record-set-name "*" \
    --ipv4-address MY_EXTERNAL_IP
az network dns record-set a add-record \
    --resource-group myResourceGroup \
    --zone-name MY_CUSTOM_DOMAIN \
    --record-set-name "*" \
    --ipv4-address MY_EXTERNAL_IP
Add anArecord to your DNS zone with the external IP address of the NGINX service usingNew-AzDnsRecordSet.$Records = @()
$Records += New-AzDnsRecordConfig -IPv4Address <External IP>
New-AzDnsRecordSet -Name "*" `
    -RecordType A `
    -ResourceGroupName <Name of Resource Group for the DNS Zone> `
    -ZoneName <Custom Domain Name> `
    -TTL 3600 `
    -DnsRecords $Records
Add anArecord to your DNS zone with the external IP address of the NGINX service usingNew-AzDnsRecordSet.
New-AzDnsRecordSet
$Records = @()
$Records += New-AzDnsRecordConfig -IPv4Address <External IP>
New-AzDnsRecordSet -Name "*" `
    -RecordType A `
    -ResourceGroupName <Name of Resource Group for the DNS Zone> `
    -ZoneName <Custom Domain Name> `
    -TTL 3600 `
    -DnsRecords $Records
$Records = @()
$Records += New-AzDnsRecordConfig -IPv4Address <External IP>
New-AzDnsRecordSet -Name "*" `
    -RecordType A `
    -ResourceGroupName <Name of Resource Group for the DNS Zone> `
    -ZoneName <Custom Domain Name> `
    -TTL 3600 `
    -DnsRecords $Records
Configure an FQDN for your ingress controller
Optionally, you can configure an FQDN for the ingress controller IP address instead of a custom domain by setting a DNS label. Your FQDN should follow this form:<CUSTOM DNS LABEL>.<AZURE REGION NAME>.cloudapp.azure.com.
<CUSTOM DNS LABEL>.<AZURE REGION NAME>.cloudapp.azure.com
Important
Your DNS label must be unique within its Azure location.
You can configure your FQDN using one of the following methods:
Set the DNS label using Azure CLI or Azure PowerShell.
Set the DNS label using Helm chart settings.
For more information, seePublic IP address DNS name labels.
Make sure to replace<DNS_LABEL>with your unique DNS label.
<DNS_LABEL>
Azure CLI
Azure PowerShell
# Public IP address of your ingress controller
IP="MY_EXTERNAL_IP"

# Name to associate with public IP address
DNSLABEL="<DNS_LABEL>"

# Get the resource-id of the public IP
PUBLICIPID=$(az network public-ip list --query "[?ipAddress!=null]|[?contains(ipAddress, '$IP')].[id]" --output tsv)

# Update public IP address with DNS name
az network public-ip update --ids $PUBLICIPID --dns-name $DNSLABEL

# Display the FQDN
az network public-ip show --ids $PUBLICIPID --query "[dnsSettings.fqdn]" --output tsv
# Public IP address of your ingress controller
IP="MY_EXTERNAL_IP"

# Name to associate with public IP address
DNSLABEL="<DNS_LABEL>"

# Get the resource-id of the public IP
PUBLICIPID=$(az network public-ip list --query "[?ipAddress!=null]|[?contains(ipAddress, '$IP')].[id]" --output tsv)

# Update public IP address with DNS name
az network public-ip update --ids $PUBLICIPID --dns-name $DNSLABEL

# Display the FQDN
az network public-ip show --ids $PUBLICIPID --query "[dnsSettings.fqdn]" --output tsv
# Public IP address of your ingress controller
$AksIpAddress = "MY_EXTERNAL_IP"

# Get the public IP address for the ingress controller
$PublicIp = Get-AzPublicIpAddress | Where-Object {$_.IpAddress -eq $AksIpAddress}

# Update public IP address with DNS name
$PublicIp.DnsSettings = @{"DomainNameLabel" = "<DNS_LABEL>"}
$UpdatedPublicIp = Set-AzPublicIpAddress -PublicIpAddress $publicIp

# Display the FQDN
Write-Output $UpdatedPublicIp.DnsSettings.Fqdn
# Public IP address of your ingress controller
$AksIpAddress = "MY_EXTERNAL_IP"

# Get the public IP address for the ingress controller
$PublicIp = Get-AzPublicIpAddress | Where-Object {$_.IpAddress -eq $AksIpAddress}

# Update public IP address with DNS name
$PublicIp.DnsSettings = @{"DomainNameLabel" = "<DNS_LABEL>"}
$UpdatedPublicIp = Set-AzPublicIpAddress -PublicIpAddress $publicIp

# Display the FQDN
Write-Output $UpdatedPublicIp.DnsSettings.Fqdn
You can pass an annotation setting to your Helm chart configuration using the--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"parameter. This parameter can be set when the ingress controller is first deployed, or it can be configured later.
--set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"
The following example shows how to update this setting after the controller has been deployed. Make sure to replace<DNS_LABEL>with your unique DNS label.
<DNS_LABEL>
Azure CLI
Azure PowerShell
DNSLABEL="<DNS_LABEL>"
NAMESPACE="ingress-basic"

helm upgrade ingress-nginx ingress-nginx/ingress-nginx \
  --namespace $NAMESPACE \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"=$DNSLABEL \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
DNSLABEL="<DNS_LABEL>"
NAMESPACE="ingress-basic"

helm upgrade ingress-nginx ingress-nginx/ingress-nginx \
  --namespace $NAMESPACE \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"=$DNSLABEL \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
$DnsLabel = "<DNS_LABEL>"
$Namespace = "ingress-basic"

helm upgrade ingress-nginx ingress-nginx/ingress-nginx `
  --namespace $Namespace `
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"=$DnsLabel `
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
$DnsLabel = "<DNS_LABEL>"
$Namespace = "ingress-basic"

helm upgrade ingress-nginx ingress-nginx/ingress-nginx `
  --namespace $Namespace `
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-dns-label-name"=$DnsLabel `
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
Install cert-manager
The NGINX ingress controller supports TLS termination. There are several ways to retrieve and configure certificates for HTTPS. This article usescert-manager, which provides automaticLets Encryptcertificate generation and management functionality.
To install the cert-manager controller, use the following commands.
Azure CLI
Azure PowerShell
# Set variable for ACR location to use for pulling images
ACR_URL=<REGISTRY_URL>

# Label the ingress-basic namespace to disable resource validation
kubectl label namespace ingress-basic cert-manager.io/disable-validation=true

# Add the Jetstack Helm repository
helm repo add jetstack https://charts.jetstack.io

# Update your local Helm chart repository cache
helm repo update

# Install the cert-manager Helm chart
helm install cert-manager jetstack/cert-manager \
  --namespace ingress-basic \
  --version=$CERT_MANAGER_TAG \
  --set installCRDs=true \
  --set nodeSelector."kubernetes\.io/os"=linux \
  --set image.repository=$ACR_URL/$CERT_MANAGER_IMAGE_CONTROLLER \
  --set image.tag=$CERT_MANAGER_TAG \
  --set webhook.image.repository=$ACR_URL/$CERT_MANAGER_IMAGE_WEBHOOK \
  --set webhook.image.tag=$CERT_MANAGER_TAG \
  --set cainjector.image.repository=$ACR_URL/$CERT_MANAGER_IMAGE_CAINJECTOR \
  --set cainjector.image.tag=$CERT_MANAGER_TAG
# Set variable for ACR location to use for pulling images
ACR_URL=<REGISTRY_URL>

# Label the ingress-basic namespace to disable resource validation
kubectl label namespace ingress-basic cert-manager.io/disable-validation=true

# Add the Jetstack Helm repository
helm repo add jetstack https://charts.jetstack.io

# Update your local Helm chart repository cache
helm repo update

# Install the cert-manager Helm chart
helm install cert-manager jetstack/cert-manager \
  --namespace ingress-basic \
  --version=$CERT_MANAGER_TAG \
  --set installCRDs=true \
  --set nodeSelector."kubernetes\.io/os"=linux \
  --set image.repository=$ACR_URL/$CERT_MANAGER_IMAGE_CONTROLLER \
  --set image.tag=$CERT_MANAGER_TAG \
  --set webhook.image.repository=$ACR_URL/$CERT_MANAGER_IMAGE_WEBHOOK \
  --set webhook.image.tag=$CERT_MANAGER_TAG \
  --set cainjector.image.repository=$ACR_URL/$CERT_MANAGER_IMAGE_CAINJECTOR \
  --set cainjector.image.tag=$CERT_MANAGER_TAG
# Set variable for ACR location to use for pulling images
$AcrUrl = (Get-AzContainerRegistry -ResourceGroupName $ResourceGroup -Name $RegistryName).LoginServer

# Label the ingress-basic namespace to disable resource validation
kubectl label namespace ingress-basic cert-manager.io/disable-validation=true

# Add the Jetstack Helm repository
helm repo add jetstack https://charts.jetstack.io

# Update your local Helm chart repository cache
helm repo update

# Install the cert-manager Helm chart
helm install cert-manager jetstack/cert-manager `
  --namespace ingress-basic `
  --version $CertManagerTag `
  --set installCRDs=true `
  --set nodeSelector."kubernetes\.io/os"=linux `
  --set image.repository="${AcrUrl}/${CertManagerImageController}" `
  --set image.tag=$CertManagerTag `
  --set webhook.image.repository="${AcrUrl}/${CertManagerImageWebhook}" `
  --set webhook.image.tag=$CertManagerTag `
  --set cainjector.image.repository="${AcrUrl}/${CertManagerImageCaInjector}" `
  --set cainjector.image.tag=$CertManagerTag
# Set variable for ACR location to use for pulling images
$AcrUrl = (Get-AzContainerRegistry -ResourceGroupName $ResourceGroup -Name $RegistryName).LoginServer

# Label the ingress-basic namespace to disable resource validation
kubectl label namespace ingress-basic cert-manager.io/disable-validation=true

# Add the Jetstack Helm repository
helm repo add jetstack https://charts.jetstack.io

# Update your local Helm chart repository cache
helm repo update

# Install the cert-manager Helm chart
helm install cert-manager jetstack/cert-manager `
  --namespace ingress-basic `
  --version $CertManagerTag `
  --set installCRDs=true `
  --set nodeSelector."kubernetes\.io/os"=linux `
  --set image.repository="${AcrUrl}/${CertManagerImageController}" `
  --set image.tag=$CertManagerTag `
  --set webhook.image.repository="${AcrUrl}/${CertManagerImageWebhook}" `
  --set webhook.image.tag=$CertManagerTag `
  --set cainjector.image.repository="${AcrUrl}/${CertManagerImageCaInjector}" `
  --set cainjector.image.tag=$CertManagerTag
For more information on cert-manager configuration, see thecert-manager project.
Create a CA cluster issuer
Before certificates can be issued, cert-manager requires one of the following issuers:
AnIssuer, which works in a single namespace.
AClusterIssuerresource, which works across all namespaces.
For more information, see thecert-manager issuerdocumentation.
Create a cluster issuer, such ascluster-issuer.yaml, using the following example manifest. ReplaceMY_EMAIL_ADDRESSwith a valid address from your organization.apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: MY_EMAIL_ADDRESS
    privateKeySecretRef:
      name: letsencrypt
    solvers:
    - http01:
        ingress:
          class: nginx
          podTemplate:
            spec:
              nodeSelector:
                "kubernetes.io/os": linux
Create a cluster issuer, such ascluster-issuer.yaml, using the following example manifest. ReplaceMY_EMAIL_ADDRESSwith a valid address from your organization.
cluster-issuer.yaml
MY_EMAIL_ADDRESS
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: MY_EMAIL_ADDRESS
    privateKeySecretRef:
      name: letsencrypt
    solvers:
    - http01:
        ingress:
          class: nginx
          podTemplate:
            spec:
              nodeSelector:
                "kubernetes.io/os": linux
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: MY_EMAIL_ADDRESS
    privateKeySecretRef:
      name: letsencrypt
    solvers:
    - http01:
        ingress:
          class: nginx
          podTemplate:
            spec:
              nodeSelector:
                "kubernetes.io/os": linux
Apply the issuer using thekubectl applycommand.kubectl apply -f cluster-issuer.yaml --namespace ingress-basic
Apply the issuer using thekubectl applycommand.
kubectl apply
kubectl apply -f cluster-issuer.yaml --namespace ingress-basic
kubectl apply -f cluster-issuer.yaml --namespace ingress-basic
Update your ingress routes
You need to update your ingress routes to handle traffic to your FQDN or custom domain.
In the following example, traffic is routed as such:
Traffic tohello-world-ingress.MY_CUSTOM_DOMAINis routed to theaks-helloworld-oneservice.
Traffic tohello-world-ingress.MY_CUSTOM_DOMAIN/hello-world-twois routed to theaks-helloworld-twoservice.
Traffic tohello-world-ingress.MY_CUSTOM_DOMAIN/staticis routed to the service namedaks-helloworld-onefor static assets.
Note
If you configured an FQDN for the ingress controller IP address instead of a custom domain, use the FQDN instead ofhello-world-ingress.MY_CUSTOM_DOMAIN.
For example, if your FQDN isdemo-aks-ingress.eastus.cloudapp.azure.com, replacehello-world-ingress.MY_CUSTOM_DOMAINwithdemo-aks-ingress.eastus.cloudapp.azure.cominhello-world-ingress.yaml.
hello-world-ingress.yaml
Create or update thehello-world-ingress.yamlfile using the following example YAML file. Update thespec.tls.hostsandspec.rules.hostto the DNS name you created in a previous step.apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: hello-world-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2
    nginx.ingress.kubernetes.io/use-regex: "true"
    cert-manager.io/cluster-issuer: letsencrypt
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - hello-world-ingress.MY_CUSTOM_DOMAIN
    secretName: tls-secret
  rules:
  - host: hello-world-ingress.MY_CUSTOM_DOMAIN
    http:
      paths:
      - path: /hello-world-one(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-one
            port:
              number: 80
      - path: /hello-world-two(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-two
            port:
              number: 80
      - path: /(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-one
            port:
              number: 80
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: hello-world-ingress-static
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/rewrite-target: /static/$2
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - hello-world-ingress.MY_CUSTOM_DOMAIN
    secretName: tls-secret
  rules:
  - host: hello-world-ingress.MY_CUSTOM_DOMAIN
    http:
      paths:
      - path: /static(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-one
            port:
              number: 80
Create or update thehello-world-ingress.yamlfile using the following example YAML file. Update thespec.tls.hostsandspec.rules.hostto the DNS name you created in a previous step.
hello-world-ingress.yaml
spec.tls.hosts
spec.rules.host
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: hello-world-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2
    nginx.ingress.kubernetes.io/use-regex: "true"
    cert-manager.io/cluster-issuer: letsencrypt
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - hello-world-ingress.MY_CUSTOM_DOMAIN
    secretName: tls-secret
  rules:
  - host: hello-world-ingress.MY_CUSTOM_DOMAIN
    http:
      paths:
      - path: /hello-world-one(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-one
            port:
              number: 80
      - path: /hello-world-two(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-two
            port:
              number: 80
      - path: /(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-one
            port:
              number: 80
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: hello-world-ingress-static
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/rewrite-target: /static/$2
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - hello-world-ingress.MY_CUSTOM_DOMAIN
    secretName: tls-secret
  rules:
  - host: hello-world-ingress.MY_CUSTOM_DOMAIN
    http:
      paths:
      - path: /static(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-one
            port:
              number: 80
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: hello-world-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2
    nginx.ingress.kubernetes.io/use-regex: "true"
    cert-manager.io/cluster-issuer: letsencrypt
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - hello-world-ingress.MY_CUSTOM_DOMAIN
    secretName: tls-secret
  rules:
  - host: hello-world-ingress.MY_CUSTOM_DOMAIN
    http:
      paths:
      - path: /hello-world-one(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-one
            port:
              number: 80
      - path: /hello-world-two(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-two
            port:
              number: 80
      - path: /(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-one
            port:
              number: 80
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: hello-world-ingress-static
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/rewrite-target: /static/$2
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - hello-world-ingress.MY_CUSTOM_DOMAIN
    secretName: tls-secret
  rules:
  - host: hello-world-ingress.MY_CUSTOM_DOMAIN
    http:
      paths:
      - path: /static(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: aks-helloworld-one
            port:
              number: 80
Update the ingress resource using thekubectl applycommand.kubectl apply -f hello-world-ingress.yaml --namespace ingress-basic
Update the ingress resource using thekubectl applycommand.
kubectl apply
kubectl apply -f hello-world-ingress.yaml --namespace ingress-basic
kubectl apply -f hello-world-ingress.yaml --namespace ingress-basic
Verify a certificate object has been created
Next, a certificate resource must be created. The certificate resource defines the desired X.509 certificate. For more information, seecert-manager certificates.
Cert-manager automatically creates a certificate object for you using ingress-shim, which is automatically deployed with cert-manager since v0.2.2. For more information, see theingress-shim documentation.
To verify that the certificate was created successfully, use thekubectl get certificate --namespace ingress-basiccommand and verifyREADYisTrue. It may take several minutes to get the output.
kubectl get certificate --namespace ingress-basic
kubectl get certificate --namespace ingress-basic
kubectl get certificate --namespace ingress-basic
The following output shows the certificate's status.
NAME         READY   SECRET       AGE
tls-secret   True    tls-secret   11m
NAME         READY   SECRET       AGE
tls-secret   True    tls-secret   11m
Test the ingress configuration
Open a web browser tohello-world-ingress.MY_CUSTOM_DOMAINor the FQDN of your Kubernetes ingress controller. Ensure the following are true:
You're redirected to use HTTPS.
The certificate istrusted.
The demo application is shown in the web browser.
Add/hello-world-twoto the end of the domain and ensure the second demo application with the custom title is shown.
Clean up resources
This article used Helm to install the ingress components, certificates, and sample apps. When you deploy a Helm chart, many Kubernetes resources are created. These resources include pods, deployments, and services. To clean up these resources, you can either delete the entire sample namespace or the individual resources.
Delete the sample namespace and all resources
Deleting the sample namespace also deletes all the resources in the namespace.
Delete the entire sample namespace using thekubectl deletecommand and specifying your namespace name.kubectl delete namespace ingress-basic
Delete the entire sample namespace using thekubectl deletecommand and specifying your namespace name.
kubectl delete
kubectl delete namespace ingress-basic
kubectl delete namespace ingress-basic
Delete resources individually
Alternatively, you can delete the resource individually.
Remove the cluster issuer resources.kubectl delete -f cluster-issuer.yaml --namespace ingress-basic
Remove the cluster issuer resources.
kubectl delete -f cluster-issuer.yaml --namespace ingress-basic
kubectl delete -f cluster-issuer.yaml --namespace ingress-basic
List the Helm releases with thehelm listcommand. Look for charts namednginxandcert-manager, as shown in the following example output.$ helm list --namespace ingress-basic

NAME                    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                   APP VERSION
cert-manager            ingress-basic   1               2020-01-15 10:23:36.515514 -0600 CST    deployed        cert-manager-v0.13.0    v0.13.0
nginx                   ingress-basic   1               2020-01-15 10:09:45.982693 -0600 CST    deployed        nginx-ingress-1.29.1    0.27.0
List the Helm releases with thehelm listcommand. Look for charts namednginxandcert-manager, as shown in the following example output.
helm list
$ helm list --namespace ingress-basic

NAME                    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                   APP VERSION
cert-manager            ingress-basic   1               2020-01-15 10:23:36.515514 -0600 CST    deployed        cert-manager-v0.13.0    v0.13.0
nginx                   ingress-basic   1               2020-01-15 10:09:45.982693 -0600 CST    deployed        nginx-ingress-1.29.1    0.27.0
$ helm list --namespace ingress-basic

NAME                    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                   APP VERSION
cert-manager            ingress-basic   1               2020-01-15 10:23:36.515514 -0600 CST    deployed        cert-manager-v0.13.0    v0.13.0
nginx                   ingress-basic   1               2020-01-15 10:09:45.982693 -0600 CST    deployed        nginx-ingress-1.29.1    0.27.0
Uninstall the releases using thehelm uninstallcommand. The following example uninstalls the NGINX ingress and cert-manager deployments.$ helm uninstall cert-manager nginx --namespace ingress-basic

release "cert-manager" uninstalled
release "nginx" uninstalled
Uninstall the releases using thehelm uninstallcommand. The following example uninstalls the NGINX ingress and cert-manager deployments.
helm uninstall
$ helm uninstall cert-manager nginx --namespace ingress-basic

release "cert-manager" uninstalled
release "nginx" uninstalled
$ helm uninstall cert-manager nginx --namespace ingress-basic

release "cert-manager" uninstalled
release "nginx" uninstalled
Remove the two sample applications.kubectl delete -f aks-helloworld-one.yaml --namespace ingress-basic
kubectl delete -f aks-helloworld-two.yaml --namespace ingress-basic
Remove the two sample applications.
kubectl delete -f aks-helloworld-one.yaml --namespace ingress-basic
kubectl delete -f aks-helloworld-two.yaml --namespace ingress-basic
kubectl delete -f aks-helloworld-one.yaml --namespace ingress-basic
kubectl delete -f aks-helloworld-two.yaml --namespace ingress-basic
Remove the ingress route that directed traffic to the sample apps.kubectl delete -f hello-world-ingress.yaml --namespace ingress-basic
Remove the ingress route that directed traffic to the sample apps.
kubectl delete -f hello-world-ingress.yaml --namespace ingress-basic
kubectl delete -f hello-world-ingress.yaml --namespace ingress-basic
Delete the itself namespace. Use thekubectl deletecommand and specify your namespace name.kubectl delete namespace ingress-basic
Delete the itself namespace. Use thekubectl deletecommand and specify your namespace name.
kubectl delete
kubectl delete namespace ingress-basic
kubectl delete namespace ingress-basic
Next steps
This article included some external components to AKS. To learn more about these components, see the following project pages:
Helm CLI
NGINX ingress controller
cert-manager
You can also:
Enable the HTTP application routing add-on
Feedback
Was this page helpful?
Additional resources