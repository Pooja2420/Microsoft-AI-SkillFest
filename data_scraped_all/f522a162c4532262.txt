Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Index data from Azure Cosmos DB for NoSQL for queries in Azure AI Search
Article
2025-01-13
23 contributors
In this article
In this article, learn how to configure anindexerthat imports content fromAzure Cosmos DB for NoSQLand makes it searchable in Azure AI Search.
This article supplementsCreate an indexerwith information that's specific to Cosmos DB. It uses the Azure portal and REST APIs to demonstrate a three-part workflow common to all indexers: create a data source, create an index, create an indexer. Data extraction occurs when you submit the Create Indexer request.
Because terminology can be confusing, it's worth noting thatAzure Cosmos DB indexingandAzure AI Search indexingare different operations. Indexing in Azure AI Search creates and loads a search index on your search service.
Prerequisites
AnAzure Cosmos DB account, database, container, and items. Use the same region for both Azure AI Search and Azure Cosmos DB for lower latency and to avoid bandwidth charges.
AnAzure Cosmos DB account, database, container, and items. Use the same region for both Azure AI Search and Azure Cosmos DB for lower latency and to avoid bandwidth charges.
Anautomatic indexing policyon the Azure Cosmos DB collection, set toConsistent. This is the default configuration. Lazy indexing isn't recommended and can result in missing data.
Anautomatic indexing policyon the Azure Cosmos DB collection, set toConsistent. This is the default configuration. Lazy indexing isn't recommended and can result in missing data.
Read permissions. A "full access" connection string includes a key that grants access to the content, but if you're using identities (Microsoft Entra ID), make sure thesearch service managed identityis assigned bothCosmos DB Account Reader RoleandCosmos DB Built-in Data Reader Role.
Read permissions. A "full access" connection string includes a key that grants access to the content, but if you're using identities (Microsoft Entra ID), make sure thesearch service managed identityis assigned bothCosmos DB Account Reader RoleandCosmos DB Built-in Data Reader Role.
To work through the examples in this article, you need the Azure portal or aREST client. If you're using Azure portal, make sure that access to all public networks is enabled. Other approaches for creating a Cosmos DB indexer include Azure SDKs.
Try with sample data
Use these instructions to create a container and database in Cosmos DB for testing purposes.
Download HotelsData_toCosmosDB.JSONfrom GitHub to create a container in Cosmos DB that contains a subset of the sample hotels data set.
Download HotelsData_toCosmosDB.JSONfrom GitHub to create a container in Cosmos DB that contains a subset of the sample hotels data set.
Sign in to the Azure portal andcreate an account, database, and containeron Cosmos DB.
Sign in to the Azure portal andcreate an account, database, and containeron Cosmos DB.
In Cosmos DB, selectData Explorerfor the new container, provide the following values.PropertyValueDatabaseCreate newDatabase IDhotelsdbShare throughput across containersDon't selectContainer IDhotelsPartition key/HotelIdContainer throughput (autoscale)AutoscaleContainer Max RU/s1000
In Cosmos DB, selectData Explorerfor the new container, provide the following values.
InData Explorer, expandhotelsdband *hotels", and then selectItems.
InData Explorer, expandhotelsdband *hotels", and then selectItems.
SelectUpload Itemand then selectHotelsData_toCosmosDB.JSONfile that you downloaded from GitHub.
SelectUpload Itemand then selectHotelsData_toCosmosDB.JSONfile that you downloaded from GitHub.
Right-clickItemsand selectNew SQL query. The default query isSELECT * FROM c.
Right-clickItemsand selectNew SQL query. The default query isSELECT * FROM c.
SELECT * FROM c
SelectExecute queryto run the query and view results. You should have 50 hotel documents.
SelectExecute queryto run the query and view results. You should have 50 hotel documents.
Now that you have a container, you can use the Azure portal, REST client, or an Azure SDK to index your data.
The Description field provides the most verbose content. You should target this field for full text search and optional vector queries.
Use the Azure portal
You can use either theImport datawizard orImport and vectorize datawizard to automate indexing from an SQL database table or view. The data source configuration is similar for both wizards.
Start the wizard.
Start the wizard.
OnConnect to your data, select or verify that the data source type is eitherAzure Cosmos DBor aNoSQL account.The data source name refers to the data source connection object in Azure AI Search. If you use the vector wizard, your data source name is autogenerated using a custom prefix specified at the end of the wizard workflow.
OnConnect to your data, select or verify that the data source type is eitherAzure Cosmos DBor aNoSQL account.
The data source name refers to the data source connection object in Azure AI Search. If you use the vector wizard, your data source name is autogenerated using a custom prefix specified at the end of the wizard workflow.
Specify the database name and collection. The query is optional. It's useful if you have hierarchical data and you want to import a specific slice.
Specify the database name and collection. The query is optional. It's useful if you have hierarchical data and you want to import a specific slice.
Specify an authentication method, either a managed identity or built-in API key. If you don't specify a managed identity connection, the Azure portal uses the key.If youconfigure Azure AI Search to use a managed identity, and you create arole assignment on Cosmos DBthat grantsCosmos DB Account ReaderandCosmos DB Built-in Data Readerpermissions to the identity, your indexer can connect to Cosmos DB using Microsoft Entra ID and roles.
Specify an authentication method, either a managed identity or built-in API key. If you don't specify a managed identity connection, the Azure portal uses the key.
If youconfigure Azure AI Search to use a managed identity, and you create arole assignment on Cosmos DBthat grantsCosmos DB Account ReaderandCosmos DB Built-in Data Readerpermissions to the identity, your indexer can connect to Cosmos DB using Microsoft Entra ID and roles.
For theImport and vectorize datawizard, you can specify options for change and deletion tracking.Change detectionis supported by default through a_tsfield (timestamp). If you upload content using the approach described inTry with sample data, the collection is created with a_tsfield.Deletion detectionrequires that you have a preexisting top-level field in the collection that can be used as a soft-delete flag. It should be a Boolean field (you could name it IsDeleted). Specifytrueas the soft-deleted value. In the search index, add a corresponding search field calledIsDeletedset to retrievable and filterable.
For theImport and vectorize datawizard, you can specify options for change and deletion tracking.
Change detectionis supported by default through a_tsfield (timestamp). If you upload content using the approach described inTry with sample data, the collection is created with a_tsfield.
_ts
_ts
Deletion detectionrequires that you have a preexisting top-level field in the collection that can be used as a soft-delete flag. It should be a Boolean field (you could name it IsDeleted). Specifytrueas the soft-deleted value. In the search index, add a corresponding search field calledIsDeletedset to retrievable and filterable.
true
Continue with the remaining steps to complete the wizard:Quickstart: Import data wizardQuickstart: Import and vectorize data wizard
Continue with the remaining steps to complete the wizard:
Quickstart: Import data wizard
Quickstart: Import data wizard
Quickstart: Import and vectorize data wizard
Quickstart: Import and vectorize data wizard
Use the REST APIs
This section demonstrates the REST API calls that create a data source, index, and indexer.
Define the data source
The data source definition specifies the data to index, credentials, and policies for identifying changes in the data. A data source is an independent resource that can be used by multiple indexers.
Create or update a data sourceto set its definition:POST https://[service name].search.windows.net/datasources?api-version=2024-07-01
Content-Type: application/json
api-key: [Search service admin key]
{
    "name": "[my-cosmosdb-ds]",
    "type": "cosmosdb",
    "credentials": {
      "connectionString": "AccountEndpoint=https://[cosmos-account-name].documents.azure.com;AccountKey=[cosmos-account-key];Database=[cosmos-database-name]"
    },
    "container": {
      "name": "[my-cosmos-db-collection]",
      "query": null
    },
    "dataChangeDetectionPolicy": {
      "@odata.type": "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
    "  highWaterMarkColumnName": "_ts"
    },
    "dataDeletionDetectionPolicy": null,
    "encryptionKey": null,
    "identity": null
}
Create or update a data sourceto set its definition:
POST https://[service name].search.windows.net/datasources?api-version=2024-07-01
Content-Type: application/json
api-key: [Search service admin key]
{
    "name": "[my-cosmosdb-ds]",
    "type": "cosmosdb",
    "credentials": {
      "connectionString": "AccountEndpoint=https://[cosmos-account-name].documents.azure.com;AccountKey=[cosmos-account-key];Database=[cosmos-database-name]"
    },
    "container": {
      "name": "[my-cosmos-db-collection]",
      "query": null
    },
    "dataChangeDetectionPolicy": {
      "@odata.type": "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
    "  highWaterMarkColumnName": "_ts"
    },
    "dataDeletionDetectionPolicy": null,
    "encryptionKey": null,
    "identity": null
}
POST https://[service name].search.windows.net/datasources?api-version=2024-07-01
Content-Type: application/json
api-key: [Search service admin key]
{
    "name": "[my-cosmosdb-ds]",
    "type": "cosmosdb",
    "credentials": {
      "connectionString": "AccountEndpoint=https://[cosmos-account-name].documents.azure.com;AccountKey=[cosmos-account-key];Database=[cosmos-database-name]"
    },
    "container": {
      "name": "[my-cosmos-db-collection]",
      "query": null
    },
    "dataChangeDetectionPolicy": {
      "@odata.type": "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
    "  highWaterMarkColumnName": "_ts"
    },
    "dataDeletionDetectionPolicy": null,
    "encryptionKey": null,
    "identity": null
}
Set "type" to"cosmosdb"(required). If you're using an older Search API version 2017-11-11, the syntax for "type" is"documentdb". Otherwise, for 2019-05-06 and later, use"cosmosdb".
Set "type" to"cosmosdb"(required). If you're using an older Search API version 2017-11-11, the syntax for "type" is"documentdb". Otherwise, for 2019-05-06 and later, use"cosmosdb".
"cosmosdb"
"documentdb"
"cosmosdb"
Set "credentials" to a connection string. The next section describes the supported formats.
Set "credentials" to a connection string. The next section describes the supported formats.
Set "container" to the collection. The "name" property is required and it specifies the ID of the database collection to be indexed. The "query" property is optional. Use it toflatten an arbitrary JSON documentinto a flat schema that Azure AI Search can index.
Set "container" to the collection. The "name" property is required and it specifies the ID of the database collection to be indexed. The "query" property is optional. Use it toflatten an arbitrary JSON documentinto a flat schema that Azure AI Search can index.
Set "dataChangeDetectionPolicy"if data is volatile and you want the indexer to pick up just the new and updated items on subsequent runs.
Set "dataChangeDetectionPolicy"if data is volatile and you want the indexer to pick up just the new and updated items on subsequent runs.
Set "dataDeletionDetectionPolicy"if you want to remove search documents from a search index when the source item is deleted.
Set "dataDeletionDetectionPolicy"if you want to remove search documents from a search index when the source item is deleted.

Indexers can connect to a collection using the following connections.
Avoid port numbers in the endpoint URL. If you include the port number, the connection fails.
{ "connectionString" : "AccountEndpoint=https://<Cosmos DB account name>.documents.azure.com;AccountKey=<Cosmos DB auth key>;Database=<Cosmos DB database id>
{ "connectionString" : "ResourceId=/subscriptions/<your subscription ID>/resourceGroups/<your resource group name>/providers/Microsoft.DocumentDB/databaseAccounts/<your cosmos db account name>/;(ApiKind=[api-kind];)/(IdentityAuthType=AccessToken)" }
{ "connectionString" : "ResourceId=/subscriptions/<your subscription ID>/resourceGroups/<your resource group name>/providers/Microsoft.DocumentDB/databaseAccounts/<your cosmos db account name>/;(ApiKind=[api-kind];)/(IdentityAuthType=AccountKey)" }
IdentityAuthType
ApiKind
ApiKind
IdentityAuthType

In the "query" property under "container", you can specify a SQL query to flatten nested properties or arrays, project JSON properties, and filter the data to be indexed.
Example document:
{
        "userId": 10001,
        "contact": {
            "firstName": "andy",
            "lastName": "hoh"
        },
        "company": "microsoft",
        "tags": ["azure", "cosmosdb", "search"]
    }
{
        "userId": 10001,
        "contact": {
            "firstName": "andy",
            "lastName": "hoh"
        },
        "company": "microsoft",
        "tags": ["azure", "cosmosdb", "search"]
    }
Filter query:
SELECT * FROM c WHERE c.company = "microsoft" and c._ts >= @HighWaterMark ORDER BY c._ts
SELECT * FROM c WHERE c.company = "microsoft" and c._ts >= @HighWaterMark ORDER BY c._ts
Flattening query:
SELECT c.id, c.userId, c.contact.firstName, c.contact.lastName, c.company, c._ts FROM c WHERE c._ts >= @HighWaterMark ORDER BY c._ts
SELECT c.id, c.userId, c.contact.firstName, c.contact.lastName, c.company, c._ts FROM c WHERE c._ts >= @HighWaterMark ORDER BY c._ts
Projection query:
SELECT VALUE { "id":c.id, "Name":c.contact.firstName, "Company":c.company, "_ts":c._ts } FROM c WHERE c._ts >= @HighWaterMark ORDER BY c._ts
SELECT VALUE { "id":c.id, "Name":c.contact.firstName, "Company":c.company, "_ts":c._ts } FROM c WHERE c._ts >= @HighWaterMark ORDER BY c._ts
Array flattening query:
SELECT c.id, c.userId, tag, c._ts FROM c JOIN tag IN c.tags WHERE c._ts >= @HighWaterMark ORDER BY c._ts
SELECT c.id, c.userId, tag, c._ts FROM c JOIN tag IN c.tags WHERE c._ts >= @HighWaterMark ORDER BY c._ts

Queries using theDISTINCT keywordorGROUP BY clausearen't supported. Azure AI Search relies onSQL query paginationto fully enumerate the results of the query. Neither the DISTINCT keyword or GROUP BY clauses are compatible with thecontinuation tokensused to paginate results.
Examples of unsupported queries:
SELECT DISTINCT c.id, c.userId, c._ts FROM c WHERE c._ts >= @HighWaterMark ORDER BY c._ts

SELECT DISTINCT VALUE c.name FROM c ORDER BY c.name

SELECT TOP 4 COUNT(1) AS foodGroupCount, f.foodGroup FROM Food f GROUP BY f.foodGroup
SELECT DISTINCT c.id, c.userId, c._ts FROM c WHERE c._ts >= @HighWaterMark ORDER BY c._ts

SELECT DISTINCT VALUE c.name FROM c ORDER BY c.name

SELECT TOP 4 COUNT(1) AS foodGroupCount, f.foodGroup FROM Food f GROUP BY f.foodGroup
Although Azure Cosmos DB has a workaround to supportSQL query pagination with the DISTINCT keyword by using the ORDER BY clause, it isn't compatible with Azure AI Search. The query returns a single JSON value, whereas Azure AI Search expects a JSON object.
-- The following query returns a single JSON value and isn't supported by Azure AI Search
SELECT DISTINCT VALUE c.name FROM c ORDER BY c.name
-- The following query returns a single JSON value and isn't supported by Azure AI Search
SELECT DISTINCT VALUE c.name FROM c ORDER BY c.name
Add search fields to an index
In asearch index, add fields to accept the source JSON documents or the output of your custom query projection. Ensure that the search index schema is compatible with source data. For content in Azure Cosmos DB, your search index schema should correspond to theAzure Cosmos DB itemsin your data source.
Create or update an indexto define search fields that store data:POST https://[service name].search.windows.net/indexes?api-version=2024-07-01
Content-Type: application/json
api-key: [Search service admin key]
{
    "name": "mysearchindex",
    "fields": [{
        "name": "rid",
        "type": "Edm.String",
        "key": true,
        "searchable": false
    }, 
    {
        "name": "description",
        "type": "Edm.String",
        "filterable": false,
        "searchable": true,
        "sortable": false,
        "facetable": false,
        "suggestions": true
    }
  ]
}
Create or update an indexto define search fields that store data:
POST https://[service name].search.windows.net/indexes?api-version=2024-07-01
Content-Type: application/json
api-key: [Search service admin key]
{
    "name": "mysearchindex",
    "fields": [{
        "name": "rid",
        "type": "Edm.String",
        "key": true,
        "searchable": false
    }, 
    {
        "name": "description",
        "type": "Edm.String",
        "filterable": false,
        "searchable": true,
        "sortable": false,
        "facetable": false,
        "suggestions": true
    }
  ]
}
POST https://[service name].search.windows.net/indexes?api-version=2024-07-01
Content-Type: application/json
api-key: [Search service admin key]
{
    "name": "mysearchindex",
    "fields": [{
        "name": "rid",
        "type": "Edm.String",
        "key": true,
        "searchable": false
    }, 
    {
        "name": "description",
        "type": "Edm.String",
        "filterable": false,
        "searchable": true,
        "sortable": false,
        "facetable": false,
        "suggestions": true
    }
  ]
}
Create a document key field ("key": true). For partitioned collections, the default document key is the Azure Cosmos DB_ridproperty, which Azure AI Search automatically renames toridbecause field names canât start with an underscore character. Also, Azure Cosmos DB_ridvalues contain characters that are invalid in Azure AI Search keys. For this reason, the_ridvalues are Base64 encoded.
Create a document key field ("key": true). For partitioned collections, the default document key is the Azure Cosmos DB_ridproperty, which Azure AI Search automatically renames toridbecause field names canât start with an underscore character. Also, Azure Cosmos DB_ridvalues contain characters that are invalid in Azure AI Search keys. For this reason, the_ridvalues are Base64 encoded.
_rid
rid
_rid
_rid
Create more fields for more searchable content. SeeCreate an indexfor details.
Create more fields for more searchable content. SeeCreate an indexfor details.
Configure and run the Azure Cosmos DB for NoSQL indexer
Once the index and data source have been created, you're ready to create the indexer. Indexer configuration specifies the inputs, parameters, and properties controlling run time behaviors.
Create or update an indexerby giving it a name and referencing the data source and target index:POST https://[service name].search.windows.net/indexers?api-version=2024-07-01
Content-Type: application/json
api-key: [search service admin key]
{
    "name" : "[my-cosmosdb-indexer]",
    "dataSourceName" : "[my-cosmosdb-ds]",
    "targetIndexName" : "[my-search-index]",
    "disabled": null,
    "schedule": null,
    "parameters": {
        "batchSize": null,
        "maxFailedItems": 0,
        "maxFailedItemsPerBatch": 0,
        "base64EncodeKeys": false,
        "configuration": {}
        },
    "fieldMappings": [],
    "encryptionKey": null
}
Create or update an indexerby giving it a name and referencing the data source and target index:
POST https://[service name].search.windows.net/indexers?api-version=2024-07-01
Content-Type: application/json
api-key: [search service admin key]
{
    "name" : "[my-cosmosdb-indexer]",
    "dataSourceName" : "[my-cosmosdb-ds]",
    "targetIndexName" : "[my-search-index]",
    "disabled": null,
    "schedule": null,
    "parameters": {
        "batchSize": null,
        "maxFailedItems": 0,
        "maxFailedItemsPerBatch": 0,
        "base64EncodeKeys": false,
        "configuration": {}
        },
    "fieldMappings": [],
    "encryptionKey": null
}
POST https://[service name].search.windows.net/indexers?api-version=2024-07-01
Content-Type: application/json
api-key: [search service admin key]
{
    "name" : "[my-cosmosdb-indexer]",
    "dataSourceName" : "[my-cosmosdb-ds]",
    "targetIndexName" : "[my-search-index]",
    "disabled": null,
    "schedule": null,
    "parameters": {
        "batchSize": null,
        "maxFailedItems": 0,
        "maxFailedItemsPerBatch": 0,
        "base64EncodeKeys": false,
        "configuration": {}
        },
    "fieldMappings": [],
    "encryptionKey": null
}
Specify field mappingsif there are differences in field name or type, or if you need multiple versions of a source field in the search index.
Specify field mappingsif there are differences in field name or type, or if you need multiple versions of a source field in the search index.
SeeCreate an indexerfor more information about other properties.
SeeCreate an indexerfor more information about other properties.
An indexer runs automatically when it's created. You can prevent this by setting "disabled" to true. To control indexer execution,run an indexer on demandorput it on a schedule.
Check indexer status
To monitor the indexer status and execution history, check the indexer execution history in the Azure portal, or send aGet Indexer StatusREST APIrequest
Portal
REST
On the search service page, openSearch management>Indexers.
On the search service page, openSearch management>Indexers.
Select an indexer to access configuration and execution history.
Select an indexer to access configuration and execution history.
Select a specific indexer job to view details, warnings, and errors.
Select a specific indexer job to view details, warnings, and errors.
GET https://myservice.search.windows.net/indexers/myindexer/status?api-version=2024-07-01
  Content-Type: application/json  
  api-key: [admin key]
GET https://myservice.search.windows.net/indexers/myindexer/status?api-version=2024-07-01
  Content-Type: application/json  
  api-key: [admin key]
The response includes status and the number of items processed. It should look similar to the following example:
{
        "status":"running",
        "lastResult": {
            "status":"success",
            "errorMessage":null,
            "startTime":"2022-02-21T00:23:24.957Z",
            "endTime":"2022-02-21T00:36:47.752Z",
            "errors":[],
            "itemsProcessed":1599501,
            "itemsFailed":0,
            "initialTrackingState":null,
            "finalTrackingState":null
        },
        "executionHistory":
        [
            {
                "status":"success",
                "errorMessage":null,
                "startTime":"2022-02-21T00:23:24.957Z",
                "endTime":"2022-02-21T00:36:47.752Z",
                "errors":[],
                "itemsProcessed":1599501,
                "itemsFailed":0,
                "initialTrackingState":null,
                "finalTrackingState":null
            },
            ... earlier history items
        ]
    }
{
        "status":"running",
        "lastResult": {
            "status":"success",
            "errorMessage":null,
            "startTime":"2022-02-21T00:23:24.957Z",
            "endTime":"2022-02-21T00:36:47.752Z",
            "errors":[],
            "itemsProcessed":1599501,
            "itemsFailed":0,
            "initialTrackingState":null,
            "finalTrackingState":null
        },
        "executionHistory":
        [
            {
                "status":"success",
                "errorMessage":null,
                "startTime":"2022-02-21T00:23:24.957Z",
                "endTime":"2022-02-21T00:36:47.752Z",
                "errors":[],
                "itemsProcessed":1599501,
                "itemsFailed":0,
                "initialTrackingState":null,
                "finalTrackingState":null
            },
            ... earlier history items
        ]
    }
Execution history contains up to 50 of the most recently completed executions, which are sorted in the reverse chronological order so that the latest execution comes first.

Indexing new and changed documents
Once an indexer has fully populated a search index, you might want subsequent indexer runs to incrementally index just the new and changed documents in your database.
To enable incremental indexing, set the "dataChangeDetectionPolicy" property in your data source definition. This property tells the indexer which change tracking mechanism is used on your data.
For Azure Cosmos DB indexers, the only supported policy is theHighWaterMarkChangeDetectionPolicyusing the_ts(timestamp) property provided by Azure Cosmos DB.
HighWaterMarkChangeDetectionPolicy
_ts
The following example shows adata source definitionwith a change detection policy:
"dataChangeDetectionPolicy": {
    "@odata.type": "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
"  highWaterMarkColumnName": "_ts"
},
"dataChangeDetectionPolicy": {
    "@odata.type": "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
"  highWaterMarkColumnName": "_ts"
},
Note
When you assign anullvalue to a field in your Azure Cosmos DB, the AI Search indexer is unable to distinguish betweennulland a missing field value. Therefore, if a field in the index is empty, it will not be substituted with anullvalue, even if that modification was made in your database.
null
null
null

Incremental indexing and custom queries
If you're using acustom query to retrieve documents, make sure the query orders the results by the_tscolumn. This enables periodic check-pointing that Azure AI Search uses to provide incremental progress in the presence of failures.
_ts
In some cases, even if your query contains anORDER BY [collection alias]._tsclause, Azure AI Search might not infer that the query is ordered by the_ts. You can tell Azure AI Search that results are ordered by setting theassumeOrderByHighWaterMarkColumnconfiguration property.
ORDER BY [collection alias]._ts
_ts
assumeOrderByHighWaterMarkColumn
To specify this hint,create or update your indexer definitionas follows:
{
    ... other indexer definition properties
    "parameters" : {
        "configuration" : { "assumeOrderByHighWaterMarkColumn" : true } }
}
{
    ... other indexer definition properties
    "parameters" : {
        "configuration" : { "assumeOrderByHighWaterMarkColumn" : true } }
}

Indexing deleted documents
When rows are deleted from the collection, you normally want to delete those rows from the search index as well. The purpose of a data deletion detection policy is to efficiently identify deleted data items. Currently, the only supported policy is theSoft Deletepolicy (deletion is marked with a flag of some sort), which is specified in the data source definition as follows:
Soft Delete
"dataDeletionDetectionPolicy"": {
    "@odata.type" : "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
    "softDeleteColumnName" : "the property that specifies whether a document was deleted",
    "softDeleteMarkerValue" : "the value that identifies a document as deleted"
}
"dataDeletionDetectionPolicy"": {
    "@odata.type" : "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
    "softDeleteColumnName" : "the property that specifies whether a document was deleted",
    "softDeleteMarkerValue" : "the value that identifies a document as deleted"
}
If you're using a custom query, make sure that the property referenced bysoftDeleteColumnNameis projected by the query.
softDeleteColumnName
ThesoftDeleteColumnNamemust be a top-level field in the index. Using nested fields within complex data types as thesoftDeleteColumnNameisn't supported.
softDeleteColumnName
softDeleteColumnName
The following example creates a data source with a soft-deletion policy:
POST https://[service name].search.windows.net/datasources?api-version=2024-07-01
Content-Type: application/json
api-key: [Search service admin key]

{
    "name": "[my-cosmosdb-ds]",
    "type": "cosmosdb",
    "credentials": {
        "connectionString": "AccountEndpoint=https://[cosmos-account-name].documents.azure.com;AccountKey=[cosmos-account-key];Database=[cosmos-database-name]"
    },
    "container": { "name": "[my-cosmos-collection]" },
    "dataChangeDetectionPolicy": {
        "@odata.type": "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
        "highWaterMarkColumnName": "_ts"
    },
    "dataDeletionDetectionPolicy": {
        "@odata.type": "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
        "softDeleteColumnName": "isDeleted",
        "softDeleteMarkerValue": "true"
    }
}
POST https://[service name].search.windows.net/datasources?api-version=2024-07-01
Content-Type: application/json
api-key: [Search service admin key]

{
    "name": "[my-cosmosdb-ds]",
    "type": "cosmosdb",
    "credentials": {
        "connectionString": "AccountEndpoint=https://[cosmos-account-name].documents.azure.com;AccountKey=[cosmos-account-key];Database=[cosmos-database-name]"
    },
    "container": { "name": "[my-cosmos-collection]" },
    "dataChangeDetectionPolicy": {
        "@odata.type": "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
        "highWaterMarkColumnName": "_ts"
    },
    "dataDeletionDetectionPolicy": {
        "@odata.type": "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
        "softDeleteColumnName": "isDeleted",
        "softDeleteMarkerValue": "true"
    }
}
Use .NET
For data accessed through the SQL API protocol, you can use the .NET SDK to automate with indexers. We recommend that you review the previous REST API sections to learn concepts, workflow, and requirements. You can then refer to following .NET API reference documentation to implement a JSON indexer in managed code:
azure.search.documents.indexes.models.searchindexerdatasourceconnection
azure.search.documents.indexes.models.searchindexerdatasourcetype
azure.search.documents.indexes.models.searchindex
azure.search.documents.indexes.models.searchindexer
Next steps
You can now control how yourun the indexer,monitor status, orschedule indexer execution. The following articles apply to indexers that pull content from Azure Cosmos DB:
Set up an indexer connection to an Azure Cosmos DB database using a managed identity
Index large data sets
Indexer access to content protected by Azure network security features
Feedback
Was this page helpful?
Additional resources