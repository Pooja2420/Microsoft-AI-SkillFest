Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Tutorial: Develop IoT Edge modules using Visual Studio Code
Article
2024-12-11
16 contributors
In this article
Applies to:IoT Edge 1.5
Important
IoT Edge 1.5 LTS is thesupported release. IoT Edge 1.4 LTS is end of life as of November 12, 2024. If you are on an earlier release, seeUpdate IoT Edge.
This tutorial walks through developing and deploying your own code to an IoT Edge device. You can use Azure IoT Edge modules to deploy code that implements your business logic directly to your IoT Edge devices. In theDeploy code to a Linux devicequickstart, you created an IoT Edge device and deployed a module from the Azure Marketplace.
This article includes steps for two IoT Edge development tools.
Azure IoT Edge Dev Toolcommand-line (CLI). This tool is preferred for development.
Azure IoT Edge tools for Visual Studio Codeextension. The extension is inmaintenance mode.
Use the tool selector button at the beginning of this article to select the tool version.
In this tutorial, you learn how to:
Set up your development machine.
Use the IoT Edge tools to create a new project.
Build your project as aDocker containerand store it in an Azure container registry.
Deploy your code to an IoT Edge device.
The IoT Edge module that you create in this tutorial filters the temperature data that your device generates. It only sends messages upstream if the temperature is above a specified threshold. This type of analysis at the edge is useful for reducing the amount of data that's communicated to and stored in the cloud.
Prerequisites
A development machine:
Use your own computer or a virtual machine.
Your development machine must supportnested virtualizationfor running a container engine.
Most operating systems that can run a container engine can be used to develop IoT Edge modules for Linux devices. This tutorial uses a Windows computer, but points out known differences on macOS or Linux.
InstallVisual Studio Code
Install theAzure CLI.
An Azure IoT Edge device:
You should run IoT Edge on a separate device. This distinction between development machine and IoT Edge device simulates a true deployment scenario and helps keep the different concepts separate.
Use the quickstart articleDeploy code to a Linux Deviceto create an IoT Edge device in Azure or theAzure Resource Template to deploy an IoT Edge enabled VM.
Cloud resources:
A free or standard-tierIoT hubin Azure.
If you don't have anAzure subscription, create anAzure free accountbefore you begin.
Tip
For guidance on interactive debugging in Visual Studio Code or Visual Studio 2022:
Debug Azure IoT Edge modules using Visual Studio Code
Use Visual Studio 2022 to develop and debug modules for Azure IoT Edge
This tutorial teaches the development steps for Visual Studio Code.
Key concepts
This tutorial walks through the development of an IoT Edge module. AnIoT Edge moduleis a container with executable code. You can deploy one or more modules to an IoT Edge device. Modules perform specific tasks like ingesting data from sensors, cleaning and analyzing data, or sending messages to an IoT hub. For more information, seeUnderstand Azure IoT Edge modules.
When developing IoT Edge modules, it's important to understand the difference between the development machine and the target IoT Edge device where the module deploys. The container that you build to hold your module code must match the operating system (OS) of thetarget device. For example, the most common scenario is someone developing a module on a Windows computer intending to target a Linux device running IoT Edge. In that case, the container operating system would be Linux. As you go through this tutorial, keep in mind the difference between thedevelopment machine OSand thecontainer OS.
Tip
If you're usingIoT Edge for Linux on Windows, then thetarget devicein your scenario is the Linux virtual machine, not the Windows host.
This tutorial targets devices running IoT Edge with Linux containers. You can use your preferred operating system as long as your development machine runs Linux containers. We recommend using Visual Studio Code to develop with Linux containers, so that's what this tutorial uses. You can use Visual Studio as well, although there are differences in support between the two tools.
The following table lists the supported development scenarios forLinux containersin Visual Studio Code and Visual Studio.
Install container engine
IoT Edge modules are packaged as containers, so you need aDocker compatible container management systemon your development machine to build and manage them. We recommend Docker Desktop for development because of its feature support and popularity. Docker Desktop on Windows lets you switch between Linux containers and Windows containers so that you can develop modules for different types of IoT Edge devices.
Use the Docker documentation to install on your development machine:
Install Docker Desktop for WindowsWhen you install Docker Desktop for Windows, you're asked whether you want to use Linux or Windows containers. You can change this decision at any time. For this tutorial, we use Linux containers because our modules are targeting Linux devices. For more information, seeSwitch between Windows and Linux containers.
Install Docker Desktop for Windows
When you install Docker Desktop for Windows, you're asked whether you want to use Linux or Windows containers. You can change this decision at any time. For this tutorial, we use Linux containers because our modules are targeting Linux devices. For more information, seeSwitch between Windows and Linux containers.
Install Docker Desktop for Mac
Install Docker Desktop for Mac
ReadAbout Docker CEfor installation information on several Linux platforms.For the Windows Subsystem for Linux (WSL), install Docker Desktop for Windows.
ReadAbout Docker CEfor installation information on several Linux platforms.
For the Windows Subsystem for Linux (WSL), install Docker Desktop for Windows.
Set up tools
Install the Python-basedAzure IoT Edge Dev Toolto create your IoT Edge solution. There are two options:
Use the prebuiltIoT Edge Dev Container
Install the tool using theiotedgedev development setup
Important
TheAzure IoT Edge tools for Visual Studio Codeextension is inmaintenance mode. The preferred development tool is the command-line (CLI)Azure IoT Edge Dev Tool.
Use the IoT extensions for Visual Studio Code to develop IoT Edge modules. These extensions offer project templates, automate the creation of the deployment manifest, and allow you to monitor and manage IoT Edge devices. In this section, you install Visual Studio Code and the IoT extension, then set up your Azure account to manage IoT Hub resources from within Visual Studio Code.
InstallAzure IoT Edgeextension.
InstallAzure IoT Edgeextension.
InstallAzure IoT Hubextension.
InstallAzure IoT Hubextension.
After you install extensions, open the command palette by selectingView>Command Palette.
After you install extensions, open the command palette by selectingView>Command Palette.
In the command palette again, search for and selectAzure IoT Hub: Select IoT Hub. Follow the prompts to select your Azure subscription and IoT Hub.
In the command palette again, search for and selectAzure IoT Hub: Select IoT Hub. Follow the prompts to select your Azure subscription and IoT Hub.
Open the explorer section of Visual Studio Code by either selecting the icon in the activity bar on the left, or by selectingView>Explorer.
Open the explorer section of Visual Studio Code by either selecting the icon in the activity bar on the left, or by selectingView>Explorer.
At the bottom of the explorer section, expand the collapsedAzure IoT Hub / Devicesmenu. You should see the devices and IoT Edge devices associated with the IoT Hub that you selected through the command palette.
At the bottom of the explorer section, expand the collapsedAzure IoT Hub / Devicesmenu. You should see the devices and IoT Edge devices associated with the IoT Hub that you selected through the command palette.
Install language specific tools
Install tools specific to the language you're developing in:
C#
C
Java
Node.js
Python
.NET Core SDK
C# Visual Studio Code extension
C/C++ Visual Studio Code extension
Installing the Azure IoT C SDK isn't required for this tutorial, but can provide helpful functionality like IntelliSense and reading program definitions. For installation information, seeAzure IoT C SDKs and Libraries.
Java SE Development Kit 11andMaven. You need toset theJAVA_HOMEenvironment variableto point to your JDK installation.
JAVA_HOME
Maven
Java Extension Pack for Visual Studio Code
Tip
The Java and Maven installation processes add environment variables to your system. Restart any open Visual Studio Code terminal, PowerShell, or command prompt instances after completing installation. This step ensures that these utilities can recognize the Java and Maven commands going forward.
Node.js.
Yeoman
Azure IoT Edge Node.js Module Generator.
To develop an IoT Edge module in Python, install the following extra prerequisites on your development machine:
PythonandPip.
Cookiecutter.
Python extension for Visual Studio Code.
Note
Ensure that yourbinfolder is on your path for your platform. Typically~/.local/for UNIX and macOS, or%APPDATA%\Pythonon Windows.
bin
~/.local/
%APPDATA%\Python
Create a container registry
In this tutorial, you use theAzure IoT EdgeandAzure IoT Hubextensions to build a module and create acontainer imagefrom the files. Then you push this image to aregistrythat stores and manages your images. Finally, you deploy your image from your registry to run on your IoT Edge device.
Important
The Azure IoT Edge Visual Studio Code extension is inmaintenance mode.
You can use any Docker-compatible registry to hold your container images. Two popular Docker registry services areAzure Container RegistryandDocker Hub. This tutorial uses Azure Container Registry.
If you don't already have a container registry, follow these steps to create a new one in Azure:
In theAzure portal, selectCreate a resource>Containers>Container Registry.
In theAzure portal, selectCreate a resource>Containers>Container Registry.
Provide the following required values to create your container registry:FieldValueSubscriptionSelect a subscription from the drop-down list.Resource groupUse the same resource group for all of the test resources that you create during the IoT Edge quickstarts and tutorials. For example,IoTEdgeResources.Registry nameProvide a unique name.LocationChoose a location close to you.SKUSelectBasic.
Provide the following required values to create your container registry:
SelectReview + create, thenCreate.
SelectReview + create, thenCreate.
Select your new container registry from theResourcessection of your Azure portal home page to open it.
Select your new container registry from theResourcessection of your Azure portal home page to open it.
In the left pane of your container registry, selectAccess keysfrom the menu located underSettings.
In the left pane of your container registry, selectAccess keysfrom the menu located underSettings.

EnableAdmin userwith the toggle button and view theUsernameandPasswordfor your container registry.
EnableAdmin userwith the toggle button and view theUsernameandPasswordfor your container registry.
Copy the values forLogin server,Username, andpasswordand save them somewhere convenient. You use these values throughout this tutorial to provide access to the container registry.
Copy the values forLogin server,Username, andpasswordand save them somewhere convenient. You use these values throughout this tutorial to provide access to the container registry.
Create a new module project
The Azure IoT Edge extension offers project templates for all supported IoT Edge module languages in Visual Studio Code. These templates have all the files and code that you need to deploy a working module to test IoT Edge, or give you a starting point to customize the template with your own business logic.
Create a project template
TheIoT Edge Dev Toolsimplifies Azure IoT Edge development to commands driven by environment variables. It gets you started with IoT Edge development with the IoT Edge Dev Container and IoT Edge solution scaffolding that has a default module and all the required configuration files.
Create a directory for your solution with the path of your choice. Change into youriotedgesolutiondirectory.mkdir c:\dev\iotedgesolution
cd c:\dev\iotedgesolution
Create a directory for your solution with the path of your choice. Change into youriotedgesolutiondirectory.
iotedgesolution
mkdir c:\dev\iotedgesolution
cd c:\dev\iotedgesolution
mkdir c:\dev\iotedgesolution
cd c:\dev\iotedgesolution
Use theiotedgedev solution initcommand to create a solution and set up your Azure IoT Hub in the development language of your choice.C#CJavaNode.jsPythoniotedgedev solution init --template csharpiotedgedev solution init --template ciotedgedev solution init --template javaiotedgedev solution init --template nodejsiotedgedev solution init --template python
Use theiotedgedev solution initcommand to create a solution and set up your Azure IoT Hub in the development language of your choice.
C#
C
Java
Node.js
Python
iotedgedev solution init --template csharp
iotedgedev solution init --template csharp
iotedgedev solution init --template c
iotedgedev solution init --template c
iotedgedev solution init --template java
iotedgedev solution init --template java
iotedgedev solution init --template nodejs
iotedgedev solution init --template nodejs
iotedgedev solution init --template python
iotedgedev solution init --template python
Theiotedgedev solution initscript prompts you to complete several steps including:
Authenticate to Azure
Choose an Azure subscription
Choose or create a resource group
Choose or create an Azure IoT Hub
Choose or create an Azure IoT Edge device
Use Visual Studio Code and theAzure IoT Edgeextension. You start by creating a solution, and then generating the first module in that solution. Each solution can contain multiple modules.
SelectView>Command Palette.
In the command palette, enter and run the commandAzure IoT Edge: New IoT Edge Solution.
Browse to the folder where you want to create the new solution and then selectSelect folder.
Enter a name for your solution.
Select a module template for your preferred development language to be the first module in the solution.
Enter a name for your module. Choose a name that's unique within your container registry.
Provide the name of the module's image repository. Visual Studio Code autopopulates the module name withlocalhost:5000/<your module name>. Replace it with your own registry information. Uselocalhostif you use a local Docker registry for testing. If you use Azure Container Registry, then useLogin serverfrom your registry's settings. The sign-in server looks like<registry name>.azurecr.io. Only replace thelocalhost:5000part of the string so that the final result looks like<registry name>.azurecr.io/<your module name>.
Visual Studio Code takes the information you provided, creates an IoT Edge solution, and then loads it in a new window.
After solution creation, these main files are in the solution:
A.vscodefolder contains configuration filelaunch.json.
A.vscodefolder contains configuration filelaunch.json.
Amodulesfolder that has subfolders for each module. Within the subfolder for each module, the module.json file controls how modules are built and deployed.
Amodulesfolder that has subfolders for each module. Within the subfolder for each module, the module.json file controls how modules are built and deployed.
An.envfile lists your environment variables. The environment variable for the container registry islocalhost:5000by default.
An.envfile lists your environment variables. The environment variable for the container registry islocalhost:5000by default.
Two module deployment files nameddeployment.template.jsonanddeployment.debug.template.jsonlist the modules to deploy to your device. By default, the list includes the IoT Edge system modules (edgeAgent and edgeHub) and sample modules such as:filtermoduleis a sample module that implements a simple filter function.SimulatedTemperatureSensormodule that simulates data you can use for testing. For more information about how deployment manifests work, seeLearn how to use deployment manifests to deploy modules and establish routes. For more information on how the simulated temperature module works, see theSimulatedTemperatureSensor.csproj source code.NoteThe exact modules installed may depend on your language of choice.
Two module deployment files nameddeployment.template.jsonanddeployment.debug.template.jsonlist the modules to deploy to your device. By default, the list includes the IoT Edge system modules (edgeAgent and edgeHub) and sample modules such as:
filtermoduleis a sample module that implements a simple filter function.
SimulatedTemperatureSensormodule that simulates data you can use for testing. For more information about how deployment manifests work, seeLearn how to use deployment manifests to deploy modules and establish routes. For more information on how the simulated temperature module works, see theSimulatedTemperatureSensor.csproj source code.
Note
The exact modules installed may depend on your language of choice.
Set IoT Edge runtime version
The latest stable IoT Edge system module version is 1.5. Set your system modules to version 1.5.
In Visual Studio Code, opendeployment.template.jsondeployment manifest file. Thedeployment manifestis a JSON document that describes the modules to be configured on the targeted IoT Edge device.
In Visual Studio Code, opendeployment.template.jsondeployment manifest file. Thedeployment manifestis a JSON document that describes the modules to be configured on the targeted IoT Edge device.
Change the runtime version for the system runtime module imagesedgeAgentandedgeHub. For example, if you want to use the IoT Edge runtime version 1.5, change the following lines in the deployment manifest file:"systemModules": {
    "edgeAgent": {

        "image": "mcr.microsoft.com/azureiotedge-agent:1.5",

    "edgeHub": {

        "image": "mcr.microsoft.com/azureiotedge-hub:1.5",
Change the runtime version for the system runtime module imagesedgeAgentandedgeHub. For example, if you want to use the IoT Edge runtime version 1.5, change the following lines in the deployment manifest file:
"systemModules": {
    "edgeAgent": {

        "image": "mcr.microsoft.com/azureiotedge-agent:1.5",

    "edgeHub": {

        "image": "mcr.microsoft.com/azureiotedge-hub:1.5",
"systemModules": {
    "edgeAgent": {

        "image": "mcr.microsoft.com/azureiotedge-agent:1.5",

    "edgeHub": {

        "image": "mcr.microsoft.com/azureiotedge-hub:1.5",
Provide your registry credentials to the IoT Edge agent
The environment file stores the credentials for your container registry and shares them with the IoT Edge runtime. The runtime needs these credentials to pull your container images onto the IoT Edge device.
The IoT Edge extension tries to pull your container registry credentials from Azure and populate them in the environment file.
Note
The environment file is only created if you provide an image repository for the module. If you accepted the localhost defaults to test and debug locally, then you don't need to declare environment variables.
Check to see if your credentials exist. If not, add them now:
If Azure Container Registry is your registry, set an Azure Container Registry username and password. Get these values from your container registry'sSettings>Access keysmenu in the Azure portal.
If Azure Container Registry is your registry, set an Azure Container Registry username and password. Get these values from your container registry'sSettings>Access keysmenu in the Azure portal.
Open the.envfile in your module solution.
Open the.envfile in your module solution.
Add theusernameandpasswordvalues that you copied from your Azure container registry.
For example:CONTAINER_REGISTRY_SERVER="myacr.azurecr.io"
CONTAINER_REGISTRY_USERNAME="myacr"
CONTAINER_REGISTRY_PASSWORD="<registry_password>"
Add theusernameandpasswordvalues that you copied from your Azure container registry.
For example:
CONTAINER_REGISTRY_SERVER="myacr.azurecr.io"
CONTAINER_REGISTRY_USERNAME="myacr"
CONTAINER_REGISTRY_PASSWORD="<registry_password>"
CONTAINER_REGISTRY_SERVER="myacr.azurecr.io"
CONTAINER_REGISTRY_USERNAME="myacr"
CONTAINER_REGISTRY_PASSWORD="<registry_password>"
Save your changes to the.envfile.
Save your changes to the.envfile.
Note
This tutorial uses administrator login credentials for Azure Container Registry that are convenient for development and test scenarios. When you're ready for production scenarios, we recommend a least-privilege authentication option like service principals or repository-scoped tokens. For more information, seeManage access to your container registry.
Target architecture
You need to select the architecture you're targeting with each solution, because that affects how the container is built and runs. The default is Linux AMD64. For this tutorial, we're using an Ubuntu virtual machine as the IoT Edge device and keep the defaultamd64.
If you need to change the target architecture for your solution, use the following steps.
Open the command palette and search forAzure IoT Edge: Set Default Target Platform for Edge Solution, or select the shortcut icon in the side bar at the bottom of the window.
Open the command palette and search forAzure IoT Edge: Set Default Target Platform for Edge Solution, or select the shortcut icon in the side bar at the bottom of the window.
In the command palette, select the target architecture from the list of options.
In the command palette, select the target architecture from the list of options.
C#
C, Java, Node.js, Python
The target architecture is set when you create the container image in a later step.
Open or createsettings.jsonin the.vscodedirectory of your solution.
Open or createsettings.jsonin the.vscodedirectory of your solution.
Change theplatformvalue toamd64,arm32v7,arm64v8, orwindows-amd64. For example:{
    "azure-iot-edge.defaultPlatform": {
        "platform": "amd64",
        "alias": null
    }
}
Change theplatformvalue toamd64,arm32v7,arm64v8, orwindows-amd64. For example:
amd64
arm32v7
arm64v8
windows-amd64
{
    "azure-iot-edge.defaultPlatform": {
        "platform": "amd64",
        "alias": null
    }
}
{
    "azure-iot-edge.defaultPlatform": {
        "platform": "amd64",
        "alias": null
    }
}
Update module with custom code
Each template includes sample code that takes simulated sensor data from theSimulatedTemperatureSensormodule and routes it to the IoT hub. The sample module receives messages and then passes them on. The pipeline functionality demonstrates an important concept in IoT Edge, which is how modules communicate with each other.
Each module can have multipleinputandoutputqueues declared in their code. The IoT Edge hub running on the device routes messages from the output of one module into the input of one or more modules. The specific code for declaring inputs and outputs varies between languages, but the concept is the same across all modules. For more information about routing between modules, seeDeclare routes.
C#
C
Java
Node.js
Python
The sample C# code that comes with the project template uses theModuleClient Classfrom the IoT Hub SDK for .NET.
In the Visual Studio Code explorer, openmodules>filtermodule>ModuleBackgroundService.cs.
In the Visual Studio Code explorer, openmodules>filtermodule>ModuleBackgroundService.cs.
Before thefiltermodulenamespace, add threeusingstatements for types that are used later:using System.Collections.Generic;     // For KeyValuePair<>
using Microsoft.Azure.Devices.Shared; // For TwinCollection
using Newtonsoft.Json;                // For JsonConvert
Before thefiltermodulenamespace, add threeusingstatements for types that are used later:
using System.Collections.Generic;     // For KeyValuePair<>
using Microsoft.Azure.Devices.Shared; // For TwinCollection
using Newtonsoft.Json;                // For JsonConvert
using System.Collections.Generic;     // For KeyValuePair<>
using Microsoft.Azure.Devices.Shared; // For TwinCollection
using Newtonsoft.Json;                // For JsonConvert
Add thetemperatureThresholdvariable to theModuleBackgroundServiceclass. This variable sets the value that the measured temperature must exceed for the data to be sent to the IoT hub.static int temperatureThreshold { get; set; } = 25;
Add thetemperatureThresholdvariable to theModuleBackgroundServiceclass. This variable sets the value that the measured temperature must exceed for the data to be sent to the IoT hub.
static int temperatureThreshold { get; set; } = 25;
static int temperatureThreshold { get; set; } = 25;
Add theMessageBody,Machine, andAmbientclasses. These classes define the expected schema for the body of incoming messages.class MessageBody
{
    public Machine machine {get;set;}
    public Ambient ambient {get; set;}
    public string timeCreated {get; set;}
}
class Machine
{
    public double temperature {get; set;}
    public double pressure {get; set;}
}
class Ambient
{
    public double temperature {get; set;}
    public int humidity {get; set;}
}
Add theMessageBody,Machine, andAmbientclasses. These classes define the expected schema for the body of incoming messages.
class MessageBody
{
    public Machine machine {get;set;}
    public Ambient ambient {get; set;}
    public string timeCreated {get; set;}
}
class Machine
{
    public double temperature {get; set;}
    public double pressure {get; set;}
}
class Ambient
{
    public double temperature {get; set;}
    public int humidity {get; set;}
}
class MessageBody
{
    public Machine machine {get;set;}
    public Ambient ambient {get; set;}
    public string timeCreated {get; set;}
}
class Machine
{
    public double temperature {get; set;}
    public double pressure {get; set;}
}
class Ambient
{
    public double temperature {get; set;}
    public int humidity {get; set;}
}
Find theExecuteAsyncfunction. This function creates and configures aModuleClientobject that allows the module to connect to the local Azure IoT Edge runtime to send and receive messages. After creating theModuleClient, the code reads thetemperatureThresholdvalue from the module twin's desired properties. The code registers a callback to receive messages from an IoT Edge hub via an endpoint calledinput1.Replace the call to theProcessMessageAsyncmethod with a new one that updates the name of the endpoint and the method that's called when input arrives. Also, add aSetDesiredPropertyUpdateCallbackAsyncmethod for updates to the desired properties. To make this change,replace the last lineof theExecuteAsyncmethod with the following code:// Register a callback for messages that are received by the module.
// await _moduleClient.SetInputMessageHandlerAsync("input1", PipeMessage, cancellationToken);

// Read the TemperatureThreshold value from the module twin's desired properties
var moduleTwin = await _moduleClient.GetTwinAsync();
await OnDesiredPropertiesUpdate(moduleTwin.Properties.Desired, _moduleClient);

// Attach a callback for updates to the module twin's desired properties.
await _moduleClient.SetDesiredPropertyUpdateCallbackAsync(OnDesiredPropertiesUpdate, null);

// Register a callback for messages that are received by the module. Messages received on the inputFromSensor endpoint are sent to the FilterMessages method.
await _moduleClient.SetInputMessageHandlerAsync("inputFromSensor", FilterMessages, _moduleClient);
Find theExecuteAsyncfunction. This function creates and configures aModuleClientobject that allows the module to connect to the local Azure IoT Edge runtime to send and receive messages. After creating theModuleClient, the code reads thetemperatureThresholdvalue from the module twin's desired properties. The code registers a callback to receive messages from an IoT Edge hub via an endpoint calledinput1.
Replace the call to theProcessMessageAsyncmethod with a new one that updates the name of the endpoint and the method that's called when input arrives. Also, add aSetDesiredPropertyUpdateCallbackAsyncmethod for updates to the desired properties. To make this change,replace the last lineof theExecuteAsyncmethod with the following code:
// Register a callback for messages that are received by the module.
// await _moduleClient.SetInputMessageHandlerAsync("input1", PipeMessage, cancellationToken);

// Read the TemperatureThreshold value from the module twin's desired properties
var moduleTwin = await _moduleClient.GetTwinAsync();
await OnDesiredPropertiesUpdate(moduleTwin.Properties.Desired, _moduleClient);

// Attach a callback for updates to the module twin's desired properties.
await _moduleClient.SetDesiredPropertyUpdateCallbackAsync(OnDesiredPropertiesUpdate, null);

// Register a callback for messages that are received by the module. Messages received on the inputFromSensor endpoint are sent to the FilterMessages method.
await _moduleClient.SetInputMessageHandlerAsync("inputFromSensor", FilterMessages, _moduleClient);
// Register a callback for messages that are received by the module.
// await _moduleClient.SetInputMessageHandlerAsync("input1", PipeMessage, cancellationToken);

// Read the TemperatureThreshold value from the module twin's desired properties
var moduleTwin = await _moduleClient.GetTwinAsync();
await OnDesiredPropertiesUpdate(moduleTwin.Properties.Desired, _moduleClient);

// Attach a callback for updates to the module twin's desired properties.
await _moduleClient.SetDesiredPropertyUpdateCallbackAsync(OnDesiredPropertiesUpdate, null);

// Register a callback for messages that are received by the module. Messages received on the inputFromSensor endpoint are sent to the FilterMessages method.
await _moduleClient.SetInputMessageHandlerAsync("inputFromSensor", FilterMessages, _moduleClient);
Add theonDesiredPropertiesUpdatemethod to theModuleBackgroundServiceclass. This method receives updates on the desired properties from the module twin, and updates thetemperatureThresholdvariable to match. All modules have their own module twin, which lets you configure the code that's running inside a module directly from the cloud.static Task OnDesiredPropertiesUpdate(TwinCollection desiredProperties, object userContext)
{
    try
    {
        Console.WriteLine("Desired property change:");
        Console.WriteLine(JsonConvert.SerializeObject(desiredProperties));

        if (desiredProperties["TemperatureThreshold"]!=null)
            temperatureThreshold = desiredProperties["TemperatureThreshold"];

    }
    catch (AggregateException ex)
    {
        foreach (Exception exception in ex.InnerExceptions)
        {
            Console.WriteLine();
            Console.WriteLine("Error when receiving desired property: {0}", exception);
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine();
        Console.WriteLine("Error when receiving desired property: {0}", ex.Message);
    }
    return Task.CompletedTask;
}
Add theonDesiredPropertiesUpdatemethod to theModuleBackgroundServiceclass. This method receives updates on the desired properties from the module twin, and updates thetemperatureThresholdvariable to match. All modules have their own module twin, which lets you configure the code that's running inside a module directly from the cloud.
static Task OnDesiredPropertiesUpdate(TwinCollection desiredProperties, object userContext)
{
    try
    {
        Console.WriteLine("Desired property change:");
        Console.WriteLine(JsonConvert.SerializeObject(desiredProperties));

        if (desiredProperties["TemperatureThreshold"]!=null)
            temperatureThreshold = desiredProperties["TemperatureThreshold"];

    }
    catch (AggregateException ex)
    {
        foreach (Exception exception in ex.InnerExceptions)
        {
            Console.WriteLine();
            Console.WriteLine("Error when receiving desired property: {0}", exception);
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine();
        Console.WriteLine("Error when receiving desired property: {0}", ex.Message);
    }
    return Task.CompletedTask;
}
static Task OnDesiredPropertiesUpdate(TwinCollection desiredProperties, object userContext)
{
    try
    {
        Console.WriteLine("Desired property change:");
        Console.WriteLine(JsonConvert.SerializeObject(desiredProperties));

        if (desiredProperties["TemperatureThreshold"]!=null)
            temperatureThreshold = desiredProperties["TemperatureThreshold"];

    }
    catch (AggregateException ex)
    {
        foreach (Exception exception in ex.InnerExceptions)
        {
            Console.WriteLine();
            Console.WriteLine("Error when receiving desired property: {0}", exception);
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine();
        Console.WriteLine("Error when receiving desired property: {0}", ex.Message);
    }
    return Task.CompletedTask;
}
Add theFilterMessagesmethod. This method is called whenever the module receives a message from the IoT Edge hub. It filters out messages that report temperatures below the temperature threshold set via the module twin. It also adds theMessageTypeproperty to the message with the value set toAlert.async Task<MessageResponse> FilterMessages(Message message, object userContext)
{
    var counterValue = Interlocked.Increment(ref _counter);
    try
    {
        ModuleClient moduleClient = (ModuleClient)userContext;
        var messageBytes = message.GetBytes();
        var messageString = Encoding.UTF8.GetString(messageBytes);
        Console.WriteLine($"Received message {counterValue}: [{messageString}]");

        // Get the message body.
        var messageBody = JsonConvert.DeserializeObject<MessageBody>(messageString);

        if (messageBody != null && messageBody.machine.temperature > temperatureThreshold)
        {
            Console.WriteLine($"Machine temperature {messageBody.machine.temperature} " +
                $"exceeds threshold {temperatureThreshold}");
            using (var filteredMessage = new Message(messageBytes))
            {
                foreach (KeyValuePair<string, string> prop in message.Properties)
                {
                    filteredMessage.Properties.Add(prop.Key, prop.Value);
                }

                filteredMessage.Properties.Add("MessageType", "Alert");
                await moduleClient.SendEventAsync("output1", filteredMessage);
            }
        }

        // Indicate that the message treatment is completed.
        return MessageResponse.Completed;
    }
    catch (AggregateException ex)
    {
        foreach (Exception exception in ex.InnerExceptions)
        {
            Console.WriteLine();
            Console.WriteLine("Error in sample: {0}", exception);
        }
        // Indicate that the message treatment is not completed.
        var moduleClient = (ModuleClient)userContext;
        return MessageResponse.Abandoned;
    }
    catch (Exception ex)
    {
        Console.WriteLine();
        Console.WriteLine("Error in sample: {0}", ex.Message);
        // Indicate that the message treatment is not completed.
        ModuleClient moduleClient = (ModuleClient)userContext;
        return MessageResponse.Abandoned;
    }
}
Add theFilterMessagesmethod. This method is called whenever the module receives a message from the IoT Edge hub. It filters out messages that report temperatures below the temperature threshold set via the module twin. It also adds theMessageTypeproperty to the message with the value set toAlert.
async Task<MessageResponse> FilterMessages(Message message, object userContext)
{
    var counterValue = Interlocked.Increment(ref _counter);
    try
    {
        ModuleClient moduleClient = (ModuleClient)userContext;
        var messageBytes = message.GetBytes();
        var messageString = Encoding.UTF8.GetString(messageBytes);
        Console.WriteLine($"Received message {counterValue}: [{messageString}]");

        // Get the message body.
        var messageBody = JsonConvert.DeserializeObject<MessageBody>(messageString);

        if (messageBody != null && messageBody.machine.temperature > temperatureThreshold)
        {
            Console.WriteLine($"Machine temperature {messageBody.machine.temperature} " +
                $"exceeds threshold {temperatureThreshold}");
            using (var filteredMessage = new Message(messageBytes))
            {
                foreach (KeyValuePair<string, string> prop in message.Properties)
                {
                    filteredMessage.Properties.Add(prop.Key, prop.Value);
                }

                filteredMessage.Properties.Add("MessageType", "Alert");
                await moduleClient.SendEventAsync("output1", filteredMessage);
            }
        }

        // Indicate that the message treatment is completed.
        return MessageResponse.Completed;
    }
    catch (AggregateException ex)
    {
        foreach (Exception exception in ex.InnerExceptions)
        {
            Console.WriteLine();
            Console.WriteLine("Error in sample: {0}", exception);
        }
        // Indicate that the message treatment is not completed.
        var moduleClient = (ModuleClient)userContext;
        return MessageResponse.Abandoned;
    }
    catch (Exception ex)
    {
        Console.WriteLine();
        Console.WriteLine("Error in sample: {0}", ex.Message);
        // Indicate that the message treatment is not completed.
        ModuleClient moduleClient = (ModuleClient)userContext;
        return MessageResponse.Abandoned;
    }
}
async Task<MessageResponse> FilterMessages(Message message, object userContext)
{
    var counterValue = Interlocked.Increment(ref _counter);
    try
    {
        ModuleClient moduleClient = (ModuleClient)userContext;
        var messageBytes = message.GetBytes();
        var messageString = Encoding.UTF8.GetString(messageBytes);
        Console.WriteLine($"Received message {counterValue}: [{messageString}]");

        // Get the message body.
        var messageBody = JsonConvert.DeserializeObject<MessageBody>(messageString);

        if (messageBody != null && messageBody.machine.temperature > temperatureThreshold)
        {
            Console.WriteLine($"Machine temperature {messageBody.machine.temperature} " +
                $"exceeds threshold {temperatureThreshold}");
            using (var filteredMessage = new Message(messageBytes))
            {
                foreach (KeyValuePair<string, string> prop in message.Properties)
                {
                    filteredMessage.Properties.Add(prop.Key, prop.Value);
                }

                filteredMessage.Properties.Add("MessageType", "Alert");
                await moduleClient.SendEventAsync("output1", filteredMessage);
            }
        }

        // Indicate that the message treatment is completed.
        return MessageResponse.Completed;
    }
    catch (AggregateException ex)
    {
        foreach (Exception exception in ex.InnerExceptions)
        {
            Console.WriteLine();
            Console.WriteLine("Error in sample: {0}", exception);
        }
        // Indicate that the message treatment is not completed.
        var moduleClient = (ModuleClient)userContext;
        return MessageResponse.Abandoned;
    }
    catch (Exception ex)
    {
        Console.WriteLine();
        Console.WriteLine("Error in sample: {0}", ex.Message);
        // Indicate that the message treatment is not completed.
        ModuleClient moduleClient = (ModuleClient)userContext;
        return MessageResponse.Abandoned;
    }
}
Save theModuleBackgroundService.csfile.
Save theModuleBackgroundService.csfile.
In the Visual Studio Code explorer, open thedeployment.template.jsonfile in your IoT Edge solution workspace.
In the Visual Studio Code explorer, open thedeployment.template.jsonfile in your IoT Edge solution workspace.
Since we changed the name of the endpoint that the module listens on, we also need to update the routes in the deployment manifest so that theedgeHubsends messages to the new endpoint.Find theroutessection in the$edgeHubmodule twin. Update thesensorTofiltermoduleroute to replaceinput1withinputFromSensor:"sensorTofiltermodule": "FROM /messages/modules/tempSensor/outputs/temperatureOutput INTO BrokeredEndpoint(\"/modules/filtermodule/inputs/inputFromSensor\")"
Since we changed the name of the endpoint that the module listens on, we also need to update the routes in the deployment manifest so that theedgeHubsends messages to the new endpoint.
Find theroutessection in the$edgeHubmodule twin. Update thesensorTofiltermoduleroute to replaceinput1withinputFromSensor:
input1
inputFromSensor
"sensorTofiltermodule": "FROM /messages/modules/tempSensor/outputs/temperatureOutput INTO BrokeredEndpoint(\"/modules/filtermodule/inputs/inputFromSensor\")"
"sensorTofiltermodule": "FROM /messages/modules/tempSensor/outputs/temperatureOutput INTO BrokeredEndpoint(\"/modules/filtermodule/inputs/inputFromSensor\")"
Add thefiltermodulemodule twin to the deployment manifest. Insert the following JSON content at the bottom of themodulesContentsection, after the$edgeHubmodule twin:"filtermodule": {
       "properties.desired":{
           "TemperatureThreshold":25
       }
   }
Add thefiltermodulemodule twin to the deployment manifest. Insert the following JSON content at the bottom of themodulesContentsection, after the$edgeHubmodule twin:
"filtermodule": {
       "properties.desired":{
           "TemperatureThreshold":25
       }
   }
"filtermodule": {
       "properties.desired":{
           "TemperatureThreshold":25
       }
   }
Save thedeployment.template.jsonfile.
Save thedeployment.template.jsonfile.
The data from the sensor in this scenario comes in JSON format. To filter messages in JSON format, import a JSON library for C. This tutorial uses Parson.Download theParson GitHub repository. Copy theparson.candparson.hfiles into thefiltermodulefolder.Openmodules>filtermodule>CMakeLists.txt. At the top of the file, import the Parson files as a library calledmy_parson.add_library(my_parson
    parson.c
    parson.h
)Addmy_parsonto the list of libraries in thetarget_link_librariesfunction of CMakeLists.txt.Save theCMakeLists.txtfile.Openmodules>filtermodule>main.c. At the bottom of the list of include statements, add a new one to includeparson.hfor JSON support:#include "parson.h"
The data from the sensor in this scenario comes in JSON format. To filter messages in JSON format, import a JSON library for C. This tutorial uses Parson.
Download theParson GitHub repository. Copy theparson.candparson.hfiles into thefiltermodulefolder.
Download theParson GitHub repository. Copy theparson.candparson.hfiles into thefiltermodulefolder.
Openmodules>filtermodule>CMakeLists.txt. At the top of the file, import the Parson files as a library calledmy_parson.add_library(my_parson
    parson.c
    parson.h
)
Openmodules>filtermodule>CMakeLists.txt. At the top of the file, import the Parson files as a library calledmy_parson.
add_library(my_parson
    parson.c
    parson.h
)
add_library(my_parson
    parson.c
    parson.h
)
Addmy_parsonto the list of libraries in thetarget_link_librariesfunction of CMakeLists.txt.
Addmy_parsonto the list of libraries in thetarget_link_librariesfunction of CMakeLists.txt.
my_parson
Save theCMakeLists.txtfile.
Save theCMakeLists.txtfile.
Openmodules>filtermodule>main.c. At the bottom of the list of include statements, add a new one to includeparson.hfor JSON support:#include "parson.h"
Openmodules>filtermodule>main.c. At the bottom of the list of include statements, add a new one to includeparson.hfor JSON support:
parson.h
#include "parson.h"
#include "parson.h"
In themain.cfile, add a global variable calledtemperatureThresholdafter the include section. This variable sets the value that the measured temperature must exceed in order for the data to be sent to IoT Hub.static double temperatureThreshold = 25;
In themain.cfile, add a global variable calledtemperatureThresholdafter the include section. This variable sets the value that the measured temperature must exceed in order for the data to be sent to IoT Hub.
temperatureThreshold
static double temperatureThreshold = 25;
static double temperatureThreshold = 25;
Find theCreateMessageInstancefunction in main.c. Replace the inner if-else statement with the following code that adds a few lines of functionality:if ((messageInstance->messageHandle = IoTHubMessage_Clone(message)) == NULL)
    {
        free(messageInstance);
        messageInstance = NULL;
    }
    else
    {
        messageInstance->messageTrackingId = messagesReceivedByInput1Queue;
        MAP_HANDLE propMap = IoTHubMessage_Properties(messageInstance->messageHandle);
        if (Map_AddOrUpdate(propMap, "MessageType", "Alert") != MAP_OK)
        {
           printf("ERROR: Map_AddOrUpdate Failed!\r\n");
        }
    }The new lines of code in the else statement add a new property to the message, which labels the message as an alert. This code labels all messages as alerts, because we'll add functionality that only sends messages to IoT Hub if they report high temperatures.
Find theCreateMessageInstancefunction in main.c. Replace the inner if-else statement with the following code that adds a few lines of functionality:
CreateMessageInstance
if ((messageInstance->messageHandle = IoTHubMessage_Clone(message)) == NULL)
    {
        free(messageInstance);
        messageInstance = NULL;
    }
    else
    {
        messageInstance->messageTrackingId = messagesReceivedByInput1Queue;
        MAP_HANDLE propMap = IoTHubMessage_Properties(messageInstance->messageHandle);
        if (Map_AddOrUpdate(propMap, "MessageType", "Alert") != MAP_OK)
        {
           printf("ERROR: Map_AddOrUpdate Failed!\r\n");
        }
    }
if ((messageInstance->messageHandle = IoTHubMessage_Clone(message)) == NULL)
    {
        free(messageInstance);
        messageInstance = NULL;
    }
    else
    {
        messageInstance->messageTrackingId = messagesReceivedByInput1Queue;
        MAP_HANDLE propMap = IoTHubMessage_Properties(messageInstance->messageHandle);
        if (Map_AddOrUpdate(propMap, "MessageType", "Alert") != MAP_OK)
        {
           printf("ERROR: Map_AddOrUpdate Failed!\r\n");
        }
    }
The new lines of code in the else statement add a new property to the message, which labels the message as an alert. This code labels all messages as alerts, because we'll add functionality that only sends messages to IoT Hub if they report high temperatures.
Replace the entireInputQueue1Callbackfunction with the following code. This function implements the actual messaging filter. When a message is received, it checks whether the reported temperature exceeds the threshold. If yes, then it forwards the message through its output queue. If not, then it ignores the message.static unsigned char *bytearray_to_str(const unsigned char *buffer, size_t len)
{
    unsigned char *ret = (unsigned char *)malloc(len + 1);
    memcpy(ret, buffer, len);
    ret[len] = '\0';
    return ret;
}

static IOTHUBMESSAGE_DISPOSITION_RESULT InputQueue1Callback(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    IOTHUBMESSAGE_DISPOSITION_RESULT result;
    IOTHUB_CLIENT_RESULT clientResult;
    IOTHUB_MODULE_CLIENT_LL_HANDLE iotHubModuleClientHandle = (IOTHUB_MODULE_CLIENT_LL_HANDLE)userContextCallback;

    unsigned const char* messageBody;
    size_t contentSize;

    if (IoTHubMessage_GetByteArray(message, &messageBody, &contentSize) == IOTHUB_MESSAGE_OK)
    {
        messageBody = bytearray_to_str(messageBody, contentSize);
    } else
    {
        messageBody = "<null>";
    }

    printf("Received Message [%zu]\r\n Data: [%s]\r\n",
            messagesReceivedByInput1Queue, messageBody);

    // Check if the message reports temperatures higher than the threshold
    JSON_Value *root_value = json_parse_string(messageBody);
    JSON_Object *root_object = json_value_get_object(root_value);
    double temperature;
    if (json_object_dotget_value(root_object, "machine.temperature") != NULL && (temperature = json_object_dotget_number(root_object, "machine.temperature")) > temperatureThreshold)
    {
        printf("Machine temperature %f exceeds threshold %f\r\n", temperature, temperatureThreshold);
        // This message should be sent to next stop in the pipeline, namely "output1".  What happens at "output1" is determined
        // by the configuration of the Edge routing table setup.
        MESSAGE_INSTANCE *messageInstance = CreateMessageInstance(message);
        if (NULL == messageInstance)
        {
            result = IOTHUBMESSAGE_ABANDONED;
        }
        else
        {
            printf("Sending message (%zu) to the next stage in pipeline\n", messagesReceivedByInput1Queue);

            clientResult = IoTHubModuleClient_LL_SendEventToOutputAsync(iotHubModuleClientHandle, messageInstance->messageHandle, "output1", SendConfirmationCallback, (void *)messageInstance);
            if (clientResult != IOTHUB_CLIENT_OK)
            {
                IoTHubMessage_Destroy(messageInstance->messageHandle);
                free(messageInstance);
                printf("IoTHubModuleClient_LL_SendEventToOutputAsync failed on sending msg#=%zu, err=%d\n", messagesReceivedByInput1Queue, clientResult);
                result = IOTHUBMESSAGE_ABANDONED;
            }
            else
            {
                result = IOTHUBMESSAGE_ACCEPTED;
            }
        }
    }
    else
    {
        printf("Not sending message (%zu) to the next stage in pipeline.\r\n", messagesReceivedByInput1Queue);
        result = IOTHUBMESSAGE_ACCEPTED;
    }

    messagesReceivedByInput1Queue++;
    return result;
}
Replace the entireInputQueue1Callbackfunction with the following code. This function implements the actual messaging filter. When a message is received, it checks whether the reported temperature exceeds the threshold. If yes, then it forwards the message through its output queue. If not, then it ignores the message.
InputQueue1Callback
static unsigned char *bytearray_to_str(const unsigned char *buffer, size_t len)
{
    unsigned char *ret = (unsigned char *)malloc(len + 1);
    memcpy(ret, buffer, len);
    ret[len] = '\0';
    return ret;
}

static IOTHUBMESSAGE_DISPOSITION_RESULT InputQueue1Callback(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    IOTHUBMESSAGE_DISPOSITION_RESULT result;
    IOTHUB_CLIENT_RESULT clientResult;
    IOTHUB_MODULE_CLIENT_LL_HANDLE iotHubModuleClientHandle = (IOTHUB_MODULE_CLIENT_LL_HANDLE)userContextCallback;

    unsigned const char* messageBody;
    size_t contentSize;

    if (IoTHubMessage_GetByteArray(message, &messageBody, &contentSize) == IOTHUB_MESSAGE_OK)
    {
        messageBody = bytearray_to_str(messageBody, contentSize);
    } else
    {
        messageBody = "<null>";
    }

    printf("Received Message [%zu]\r\n Data: [%s]\r\n",
            messagesReceivedByInput1Queue, messageBody);

    // Check if the message reports temperatures higher than the threshold
    JSON_Value *root_value = json_parse_string(messageBody);
    JSON_Object *root_object = json_value_get_object(root_value);
    double temperature;
    if (json_object_dotget_value(root_object, "machine.temperature") != NULL && (temperature = json_object_dotget_number(root_object, "machine.temperature")) > temperatureThreshold)
    {
        printf("Machine temperature %f exceeds threshold %f\r\n", temperature, temperatureThreshold);
        // This message should be sent to next stop in the pipeline, namely "output1".  What happens at "output1" is determined
        // by the configuration of the Edge routing table setup.
        MESSAGE_INSTANCE *messageInstance = CreateMessageInstance(message);
        if (NULL == messageInstance)
        {
            result = IOTHUBMESSAGE_ABANDONED;
        }
        else
        {
            printf("Sending message (%zu) to the next stage in pipeline\n", messagesReceivedByInput1Queue);

            clientResult = IoTHubModuleClient_LL_SendEventToOutputAsync(iotHubModuleClientHandle, messageInstance->messageHandle, "output1", SendConfirmationCallback, (void *)messageInstance);
            if (clientResult != IOTHUB_CLIENT_OK)
            {
                IoTHubMessage_Destroy(messageInstance->messageHandle);
                free(messageInstance);
                printf("IoTHubModuleClient_LL_SendEventToOutputAsync failed on sending msg#=%zu, err=%d\n", messagesReceivedByInput1Queue, clientResult);
                result = IOTHUBMESSAGE_ABANDONED;
            }
            else
            {
                result = IOTHUBMESSAGE_ACCEPTED;
            }
        }
    }
    else
    {
        printf("Not sending message (%zu) to the next stage in pipeline.\r\n", messagesReceivedByInput1Queue);
        result = IOTHUBMESSAGE_ACCEPTED;
    }

    messagesReceivedByInput1Queue++;
    return result;
}
static unsigned char *bytearray_to_str(const unsigned char *buffer, size_t len)
{
    unsigned char *ret = (unsigned char *)malloc(len + 1);
    memcpy(ret, buffer, len);
    ret[len] = '\0';
    return ret;
}

static IOTHUBMESSAGE_DISPOSITION_RESULT InputQueue1Callback(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    IOTHUBMESSAGE_DISPOSITION_RESULT result;
    IOTHUB_CLIENT_RESULT clientResult;
    IOTHUB_MODULE_CLIENT_LL_HANDLE iotHubModuleClientHandle = (IOTHUB_MODULE_CLIENT_LL_HANDLE)userContextCallback;

    unsigned const char* messageBody;
    size_t contentSize;

    if (IoTHubMessage_GetByteArray(message, &messageBody, &contentSize) == IOTHUB_MESSAGE_OK)
    {
        messageBody = bytearray_to_str(messageBody, contentSize);
    } else
    {
        messageBody = "<null>";
    }

    printf("Received Message [%zu]\r\n Data: [%s]\r\n",
            messagesReceivedByInput1Queue, messageBody);

    // Check if the message reports temperatures higher than the threshold
    JSON_Value *root_value = json_parse_string(messageBody);
    JSON_Object *root_object = json_value_get_object(root_value);
    double temperature;
    if (json_object_dotget_value(root_object, "machine.temperature") != NULL && (temperature = json_object_dotget_number(root_object, "machine.temperature")) > temperatureThreshold)
    {
        printf("Machine temperature %f exceeds threshold %f\r\n", temperature, temperatureThreshold);
        // This message should be sent to next stop in the pipeline, namely "output1".  What happens at "output1" is determined
        // by the configuration of the Edge routing table setup.
        MESSAGE_INSTANCE *messageInstance = CreateMessageInstance(message);
        if (NULL == messageInstance)
        {
            result = IOTHUBMESSAGE_ABANDONED;
        }
        else
        {
            printf("Sending message (%zu) to the next stage in pipeline\n", messagesReceivedByInput1Queue);

            clientResult = IoTHubModuleClient_LL_SendEventToOutputAsync(iotHubModuleClientHandle, messageInstance->messageHandle, "output1", SendConfirmationCallback, (void *)messageInstance);
            if (clientResult != IOTHUB_CLIENT_OK)
            {
                IoTHubMessage_Destroy(messageInstance->messageHandle);
                free(messageInstance);
                printf("IoTHubModuleClient_LL_SendEventToOutputAsync failed on sending msg#=%zu, err=%d\n", messagesReceivedByInput1Queue, clientResult);
                result = IOTHUBMESSAGE_ABANDONED;
            }
            else
            {
                result = IOTHUBMESSAGE_ACCEPTED;
            }
        }
    }
    else
    {
        printf("Not sending message (%zu) to the next stage in pipeline.\r\n", messagesReceivedByInput1Queue);
        result = IOTHUBMESSAGE_ACCEPTED;
    }

    messagesReceivedByInput1Queue++;
    return result;
}
Add amoduleTwinCallbackfunction. This method receives updates on the desired properties from the module twin, and updates thetemperatureThresholdvariable to match. All modules have their own module twin, which lets you configure the code running inside a module directly from the cloud.static void moduleTwinCallback(DEVICE_TWIN_UPDATE_STATE update_state, const unsigned char* payLoad, size_t size, void* userContextCallback)
{
    printf("\r\nTwin callback called with (state=%s, size=%zu):\r\n%s\r\n",
        MU_ENUM_TO_STRING(DEVICE_TWIN_UPDATE_STATE, update_state), size, payLoad);
    JSON_Value *root_value = json_parse_string(payLoad);
    JSON_Object *root_object = json_value_get_object(root_value);
    if (json_object_dotget_value(root_object, "desired.TemperatureThreshold") != NULL) {
        temperatureThreshold = json_object_dotget_number(root_object, "desired.TemperatureThreshold");
    }
    if (json_object_get_value(root_object, "TemperatureThreshold") != NULL) {
        temperatureThreshold = json_object_get_number(root_object, "TemperatureThreshold");
    }
}
Add amoduleTwinCallbackfunction. This method receives updates on the desired properties from the module twin, and updates thetemperatureThresholdvariable to match. All modules have their own module twin, which lets you configure the code running inside a module directly from the cloud.
moduleTwinCallback
static void moduleTwinCallback(DEVICE_TWIN_UPDATE_STATE update_state, const unsigned char* payLoad, size_t size, void* userContextCallback)
{
    printf("\r\nTwin callback called with (state=%s, size=%zu):\r\n%s\r\n",
        MU_ENUM_TO_STRING(DEVICE_TWIN_UPDATE_STATE, update_state), size, payLoad);
    JSON_Value *root_value = json_parse_string(payLoad);
    JSON_Object *root_object = json_value_get_object(root_value);
    if (json_object_dotget_value(root_object, "desired.TemperatureThreshold") != NULL) {
        temperatureThreshold = json_object_dotget_number(root_object, "desired.TemperatureThreshold");
    }
    if (json_object_get_value(root_object, "TemperatureThreshold") != NULL) {
        temperatureThreshold = json_object_get_number(root_object, "TemperatureThreshold");
    }
}
static void moduleTwinCallback(DEVICE_TWIN_UPDATE_STATE update_state, const unsigned char* payLoad, size_t size, void* userContextCallback)
{
    printf("\r\nTwin callback called with (state=%s, size=%zu):\r\n%s\r\n",
        MU_ENUM_TO_STRING(DEVICE_TWIN_UPDATE_STATE, update_state), size, payLoad);
    JSON_Value *root_value = json_parse_string(payLoad);
    JSON_Object *root_object = json_value_get_object(root_value);
    if (json_object_dotget_value(root_object, "desired.TemperatureThreshold") != NULL) {
        temperatureThreshold = json_object_dotget_number(root_object, "desired.TemperatureThreshold");
    }
    if (json_object_get_value(root_object, "TemperatureThreshold") != NULL) {
        temperatureThreshold = json_object_get_number(root_object, "TemperatureThreshold");
    }
}
Find theSetupCallbacksForModulefunction. Replace the function with the following code that adds anelse ifstatement to check if the module twin is updated.static int SetupCallbacksForModule(IOTHUB_MODULE_CLIENT_LL_HANDLE iotHubModuleClientHandle)
{
    int ret;

    if (IoTHubModuleClient_LL_SetInputMessageCallback(iotHubModuleClientHandle, "input1", InputQueue1Callback, (void*)iotHubModuleClientHandle) != IOTHUB_CLIENT_OK)
    {
        printf("ERROR: IoTHubModuleClient_LL_SetInputMessageCallback(\"input1\")..........FAILED!\r\n");
        ret = MU_FAILURE;
    }
    else if (IoTHubModuleClient_LL_SetModuleTwinCallback(iotHubModuleClientHandle, moduleTwinCallback, (void*)iotHubModuleClientHandle) != IOTHUB_CLIENT_OK)
    {
        printf("ERROR: IoTHubModuleClient_LL_SetModuleTwinCallback(default)..........FAILED!\r\n");
        ret = MU_FAILURE;
    }
    else
    {
        ret = 0;
    }

    return ret;
}
Find theSetupCallbacksForModulefunction. Replace the function with the following code that adds anelse ifstatement to check if the module twin is updated.
SetupCallbacksForModule
static int SetupCallbacksForModule(IOTHUB_MODULE_CLIENT_LL_HANDLE iotHubModuleClientHandle)
{
    int ret;

    if (IoTHubModuleClient_LL_SetInputMessageCallback(iotHubModuleClientHandle, "input1", InputQueue1Callback, (void*)iotHubModuleClientHandle) != IOTHUB_CLIENT_OK)
    {
        printf("ERROR: IoTHubModuleClient_LL_SetInputMessageCallback(\"input1\")..........FAILED!\r\n");
        ret = MU_FAILURE;
    }
    else if (IoTHubModuleClient_LL_SetModuleTwinCallback(iotHubModuleClientHandle, moduleTwinCallback, (void*)iotHubModuleClientHandle) != IOTHUB_CLIENT_OK)
    {
        printf("ERROR: IoTHubModuleClient_LL_SetModuleTwinCallback(default)..........FAILED!\r\n");
        ret = MU_FAILURE;
    }
    else
    {
        ret = 0;
    }

    return ret;
}
static int SetupCallbacksForModule(IOTHUB_MODULE_CLIENT_LL_HANDLE iotHubModuleClientHandle)
{
    int ret;

    if (IoTHubModuleClient_LL_SetInputMessageCallback(iotHubModuleClientHandle, "input1", InputQueue1Callback, (void*)iotHubModuleClientHandle) != IOTHUB_CLIENT_OK)
    {
        printf("ERROR: IoTHubModuleClient_LL_SetInputMessageCallback(\"input1\")..........FAILED!\r\n");
        ret = MU_FAILURE;
    }
    else if (IoTHubModuleClient_LL_SetModuleTwinCallback(iotHubModuleClientHandle, moduleTwinCallback, (void*)iotHubModuleClientHandle) != IOTHUB_CLIENT_OK)
    {
        printf("ERROR: IoTHubModuleClient_LL_SetModuleTwinCallback(default)..........FAILED!\r\n");
        ret = MU_FAILURE;
    }
    else
    {
        ret = 0;
    }

    return ret;
}
Save themain.cfile.
Save themain.cfile.
In the Visual Studio Code explorer, open thedeployment.template.jsonfile in your IoT Edge solution workspace.
In the Visual Studio Code explorer, open thedeployment.template.jsonfile in your IoT Edge solution workspace.
Add the filtermodule module twin to the deployment manifest. Insert the following JSON content at the bottom of themoduleContentsection, after the$edgeHubmodule twin:"filtermodule": {
    "properties.desired":{
        "TemperatureThreshold":25
    }
}
Add the filtermodule module twin to the deployment manifest. Insert the following JSON content at the bottom of themoduleContentsection, after the$edgeHubmodule twin:
moduleContent
$edgeHub
"filtermodule": {
    "properties.desired":{
        "TemperatureThreshold":25
    }
}
"filtermodule": {
    "properties.desired":{
        "TemperatureThreshold":25
    }
}
Save thedeployment.template.jsonfile.
Save thedeployment.template.jsonfile.
In the Visual Studio Code explorer, openmodules>filtermodule>src>main>java>com>edgemodule>App.java.
In the Visual Studio Code explorer, openmodules>filtermodule>src>main>java>com>edgemodule>App.java.
Add the following code at the top of the file to import new referenced classes.import java.io.StringReader;
import java.util.concurrent.atomic.AtomicLong;
import java.util.HashMap;
import java.util.Map;

import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonReader;

import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;
import com.microsoft.azure.sdk.iot.device.DeviceTwin.Property;
import com.microsoft.azure.sdk.iot.device.DeviceTwin.TwinPropertyCallBack;
Add the following code at the top of the file to import new referenced classes.
import java.io.StringReader;
import java.util.concurrent.atomic.AtomicLong;
import java.util.HashMap;
import java.util.Map;

import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonReader;

import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;
import com.microsoft.azure.sdk.iot.device.DeviceTwin.Property;
import com.microsoft.azure.sdk.iot.device.DeviceTwin.TwinPropertyCallBack;
import java.io.StringReader;
import java.util.concurrent.atomic.AtomicLong;
import java.util.HashMap;
import java.util.Map;

import javax.json.Json;
import javax.json.JsonObject;
import javax.json.JsonReader;

import com.microsoft.azure.sdk.iot.device.DeviceTwin.Pair;
import com.microsoft.azure.sdk.iot.device.DeviceTwin.Property;
import com.microsoft.azure.sdk.iot.device.DeviceTwin.TwinPropertyCallBack;
Add the following definition into classApp. This variable sets a temperature threshold. The measured machine temperature isn't reported to IoT Hub until it goes over this value.private static final String TEMP_THRESHOLD = "TemperatureThreshold";
private static AtomicLong tempThreshold = new AtomicLong(25);
Add the following definition into classApp. This variable sets a temperature threshold. The measured machine temperature isn't reported to IoT Hub until it goes over this value.
private static final String TEMP_THRESHOLD = "TemperatureThreshold";
private static AtomicLong tempThreshold = new AtomicLong(25);
private static final String TEMP_THRESHOLD = "TemperatureThreshold";
private static AtomicLong tempThreshold = new AtomicLong(25);
Replace the execute method ofMessageCallbackMqttwith the following code. This method is called whenever the module receives an MQTT message from the IoT Edge hub. It filters out messages that report temperatures below the temperature threshold set via the module twin.protected static class MessageCallbackMqtt implements MessageCallback {
    private int counter = 0;
    @Override
    public IotHubMessageResult execute(Message msg, Object context) {
        this.counter += 1;

        String msgString = new String(msg.getBytes(), Message.DEFAULT_IOTHUB_MESSAGE_CHARSET);
        System.out.println(
               String.format("Received message %d: %s",
                        this.counter, msgString));
        if (context instanceof ModuleClient) {
            try (JsonReader jsonReader = Json.createReader(new StringReader(msgString))) {
                final JsonObject msgObject = jsonReader.readObject();
                double temperature = msgObject.getJsonObject("machine").getJsonNumber("temperature").doubleValue();
                long threshold = App.tempThreshold.get();
                if (temperature >= threshold) {
                    ModuleClient client = (ModuleClient) context;
                    System.out.println(
                        String.format("Temperature above threshold %d. Sending message: %s",
                        threshold, msgString));
                    client.sendEventAsync(msg, eventCallback, msg, App.OUTPUT_NAME);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return IotHubMessageResult.COMPLETE;
    }
}
Replace the execute method ofMessageCallbackMqttwith the following code. This method is called whenever the module receives an MQTT message from the IoT Edge hub. It filters out messages that report temperatures below the temperature threshold set via the module twin.
protected static class MessageCallbackMqtt implements MessageCallback {
    private int counter = 0;
    @Override
    public IotHubMessageResult execute(Message msg, Object context) {
        this.counter += 1;

        String msgString = new String(msg.getBytes(), Message.DEFAULT_IOTHUB_MESSAGE_CHARSET);
        System.out.println(
               String.format("Received message %d: %s",
                        this.counter, msgString));
        if (context instanceof ModuleClient) {
            try (JsonReader jsonReader = Json.createReader(new StringReader(msgString))) {
                final JsonObject msgObject = jsonReader.readObject();
                double temperature = msgObject.getJsonObject("machine").getJsonNumber("temperature").doubleValue();
                long threshold = App.tempThreshold.get();
                if (temperature >= threshold) {
                    ModuleClient client = (ModuleClient) context;
                    System.out.println(
                        String.format("Temperature above threshold %d. Sending message: %s",
                        threshold, msgString));
                    client.sendEventAsync(msg, eventCallback, msg, App.OUTPUT_NAME);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return IotHubMessageResult.COMPLETE;
    }
}
protected static class MessageCallbackMqtt implements MessageCallback {
    private int counter = 0;
    @Override
    public IotHubMessageResult execute(Message msg, Object context) {
        this.counter += 1;

        String msgString = new String(msg.getBytes(), Message.DEFAULT_IOTHUB_MESSAGE_CHARSET);
        System.out.println(
               String.format("Received message %d: %s",
                        this.counter, msgString));
        if (context instanceof ModuleClient) {
            try (JsonReader jsonReader = Json.createReader(new StringReader(msgString))) {
                final JsonObject msgObject = jsonReader.readObject();
                double temperature = msgObject.getJsonObject("machine").getJsonNumber("temperature").doubleValue();
                long threshold = App.tempThreshold.get();
                if (temperature >= threshold) {
                    ModuleClient client = (ModuleClient) context;
                    System.out.println(
                        String.format("Temperature above threshold %d. Sending message: %s",
                        threshold, msgString));
                    client.sendEventAsync(msg, eventCallback, msg, App.OUTPUT_NAME);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return IotHubMessageResult.COMPLETE;
    }
}
Add the following two static inner classes into classApp. These classes update the tempThreshold variable when the module twin's desired property changes. All modules have their own module twin, which lets you configure the code that's running inside a module directly from the cloud.protected static class DeviceTwinStatusCallBack implements IotHubEventCallback {
    @Override
    public void execute(IotHubStatusCode status, Object context) {
        System.out.println("IoT Hub responded to device twin operation with status " + status.name());
    }
}

protected static class OnProperty implements TwinPropertyCallBack {
    @Override
    public void TwinPropertyCallBack(Property property, Object context) {
        if (!property.getIsReported()) {
            if (property.getKey().equals(App.TEMP_THRESHOLD)) {
                try {
                    long threshold = Math.round((double) property.getValue());
                    App.tempThreshold.set(threshold);
                } catch (Exception e) {
                    System.out.println("Failed to set TemperatureThread with exception");
                    e.printStackTrace();
                }
            }
        }
    }
}
Add the following two static inner classes into classApp. These classes update the tempThreshold variable when the module twin's desired property changes. All modules have their own module twin, which lets you configure the code that's running inside a module directly from the cloud.
protected static class DeviceTwinStatusCallBack implements IotHubEventCallback {
    @Override
    public void execute(IotHubStatusCode status, Object context) {
        System.out.println("IoT Hub responded to device twin operation with status " + status.name());
    }
}

protected static class OnProperty implements TwinPropertyCallBack {
    @Override
    public void TwinPropertyCallBack(Property property, Object context) {
        if (!property.getIsReported()) {
            if (property.getKey().equals(App.TEMP_THRESHOLD)) {
                try {
                    long threshold = Math.round((double) property.getValue());
                    App.tempThreshold.set(threshold);
                } catch (Exception e) {
                    System.out.println("Failed to set TemperatureThread with exception");
                    e.printStackTrace();
                }
            }
        }
    }
}
protected static class DeviceTwinStatusCallBack implements IotHubEventCallback {
    @Override
    public void execute(IotHubStatusCode status, Object context) {
        System.out.println("IoT Hub responded to device twin operation with status " + status.name());
    }
}

protected static class OnProperty implements TwinPropertyCallBack {
    @Override
    public void TwinPropertyCallBack(Property property, Object context) {
        if (!property.getIsReported()) {
            if (property.getKey().equals(App.TEMP_THRESHOLD)) {
                try {
                    long threshold = Math.round((double) property.getValue());
                    App.tempThreshold.set(threshold);
                } catch (Exception e) {
                    System.out.println("Failed to set TemperatureThread with exception");
                    e.printStackTrace();
                }
            }
        }
    }
}
Add the following lines in tomainmethod afterclient.open()to subscribe the module twin updates.client.startTwin(new DeviceTwinStatusCallBack(), null, new OnProperty(), null);
Map<Property, Pair<TwinPropertyCallBack, Object>> onDesiredPropertyChange = new HashMap<Property, Pair<TwinPropertyCallBack, Object>>() {
    {
        put(new Property(App.TEMP_THRESHOLD, null), new Pair<TwinPropertyCallBack, Object>(new OnProperty(), null));
    }
};
client.subscribeToTwinDesiredProperties(onDesiredPropertyChange);
client.getTwin();
Add the following lines in tomainmethod afterclient.open()to subscribe the module twin updates.
client.startTwin(new DeviceTwinStatusCallBack(), null, new OnProperty(), null);
Map<Property, Pair<TwinPropertyCallBack, Object>> onDesiredPropertyChange = new HashMap<Property, Pair<TwinPropertyCallBack, Object>>() {
    {
        put(new Property(App.TEMP_THRESHOLD, null), new Pair<TwinPropertyCallBack, Object>(new OnProperty(), null));
    }
};
client.subscribeToTwinDesiredProperties(onDesiredPropertyChange);
client.getTwin();
client.startTwin(new DeviceTwinStatusCallBack(), null, new OnProperty(), null);
Map<Property, Pair<TwinPropertyCallBack, Object>> onDesiredPropertyChange = new HashMap<Property, Pair<TwinPropertyCallBack, Object>>() {
    {
        put(new Property(App.TEMP_THRESHOLD, null), new Pair<TwinPropertyCallBack, Object>(new OnProperty(), null));
    }
};
client.subscribeToTwinDesiredProperties(onDesiredPropertyChange);
client.getTwin();
Save theApp.javafile.
Save theApp.javafile.
In the Visual Studio Code explorer, open thedeployment.template.jsonfile in your IoT Edge solution workspace.
In the Visual Studio Code explorer, open thedeployment.template.jsonfile in your IoT Edge solution workspace.
Add thefiltermodulemodule twin to the deployment manifest. Insert the following JSON content at the bottom of themoduleContentsection, after the$edgeHubmodule twin:"filtermodule": {
      "properties.desired":{
          "TemperatureThreshold":25
      }
  }
Add thefiltermodulemodule twin to the deployment manifest. Insert the following JSON content at the bottom of themoduleContentsection, after the$edgeHubmodule twin:
"filtermodule": {
      "properties.desired":{
          "TemperatureThreshold":25
      }
  }
"filtermodule": {
      "properties.desired":{
          "TemperatureThreshold":25
      }
  }
Save thedeployment.template.jsonfile.
Save thedeployment.template.jsonfile.
In the Visual Studio Code explorer, openmodules>filtermodule>app.js.
In the Visual Studio Code explorer, openmodules>filtermodule>app.js.
Add a temperature threshold variable to the beginning ofapp.js. The temperature threshold sets the value that the measured temperature must exceed in order for the data to be sent to IoT Hub.var temperatureThreshold = 25;
Add a temperature threshold variable to the beginning ofapp.js. The temperature threshold sets the value that the measured temperature must exceed in order for the data to be sent to IoT Hub.
var temperatureThreshold = 25;
var temperatureThreshold = 25;
Replace the entirePipeMessagefunction with theFilterMessagefunction.// This function filters out messages that report temperatures below the temperature threshold.
// It also adds the MessageType property to the message with the value set to Alert.
function filterMessage(client, inputName, msg) {
    client.complete(msg, printResultFor('Receiving message'));
    if (inputName === 'input1') {
        var message = msg.getBytes().toString('utf8');
        var messageBody = JSON.parse(message);
        if (messageBody && messageBody.machine && messageBody.machine.temperature && messageBody.machine.temperature > temperatureThreshold) {
            console.log(`Machine temperature ${messageBody.machine.temperature} exceeds threshold ${temperatureThreshold}`);
            var outputMsg = new Message(message);
            outputMsg.properties.add('MessageType', 'Alert');
            client.sendOutputEvent('output1', outputMsg, printResultFor('Sending received message'));
        }
    }
}
Replace the entirePipeMessagefunction with theFilterMessagefunction.
// This function filters out messages that report temperatures below the temperature threshold.
// It also adds the MessageType property to the message with the value set to Alert.
function filterMessage(client, inputName, msg) {
    client.complete(msg, printResultFor('Receiving message'));
    if (inputName === 'input1') {
        var message = msg.getBytes().toString('utf8');
        var messageBody = JSON.parse(message);
        if (messageBody && messageBody.machine && messageBody.machine.temperature && messageBody.machine.temperature > temperatureThreshold) {
            console.log(`Machine temperature ${messageBody.machine.temperature} exceeds threshold ${temperatureThreshold}`);
            var outputMsg = new Message(message);
            outputMsg.properties.add('MessageType', 'Alert');
            client.sendOutputEvent('output1', outputMsg, printResultFor('Sending received message'));
        }
    }
}
// This function filters out messages that report temperatures below the temperature threshold.
// It also adds the MessageType property to the message with the value set to Alert.
function filterMessage(client, inputName, msg) {
    client.complete(msg, printResultFor('Receiving message'));
    if (inputName === 'input1') {
        var message = msg.getBytes().toString('utf8');
        var messageBody = JSON.parse(message);
        if (messageBody && messageBody.machine && messageBody.machine.temperature && messageBody.machine.temperature > temperatureThreshold) {
            console.log(`Machine temperature ${messageBody.machine.temperature} exceeds threshold ${temperatureThreshold}`);
            var outputMsg = new Message(message);
            outputMsg.properties.add('MessageType', 'Alert');
            client.sendOutputEvent('output1', outputMsg, printResultFor('Sending received message'));
        }
    }
}
Replace the function namepipeMessagewithfilterMessagein theclient.on()call.client.on('inputMessage', function (inputName, msg) {
    filterMessage(client, inputName, msg);
    });
Replace the function namepipeMessagewithfilterMessagein theclient.on()call.
pipeMessage
filterMessage
client.on()
client.on('inputMessage', function (inputName, msg) {
    filterMessage(client, inputName, msg);
    });
client.on('inputMessage', function (inputName, msg) {
    filterMessage(client, inputName, msg);
    });
Copy the following code snippet into theclient.open()function callback, afterclient.on()inside theelsestatement. This function is invoked when the desired properties are updated.client.getTwin(function (err, twin) {
    if (err) {
        console.error('Error getting twin: ' + err.message);
    } else {
        twin.on('properties.desired', function(delta) {
            if (delta.TemperatureThreshold) {
                temperatureThreshold = delta.TemperatureThreshold;
            }
        });
    }
});
Copy the following code snippet into theclient.open()function callback, afterclient.on()inside theelsestatement. This function is invoked when the desired properties are updated.
client.open()
client.on()
else
client.getTwin(function (err, twin) {
    if (err) {
        console.error('Error getting twin: ' + err.message);
    } else {
        twin.on('properties.desired', function(delta) {
            if (delta.TemperatureThreshold) {
                temperatureThreshold = delta.TemperatureThreshold;
            }
        });
    }
});
client.getTwin(function (err, twin) {
    if (err) {
        console.error('Error getting twin: ' + err.message);
    } else {
        twin.on('properties.desired', function(delta) {
            if (delta.TemperatureThreshold) {
                temperatureThreshold = delta.TemperatureThreshold;
            }
        });
    }
});
Save theapp.jsfile.
Save theapp.jsfile.
In the Visual Studio Code explorer, open thedeployment.template.jsonfile in your IoT Edge solution workspace.
In the Visual Studio Code explorer, open thedeployment.template.jsonfile in your IoT Edge solution workspace.
Add the filtermodule module twin to the deployment manifest. Insert the following JSON content at the bottom of themoduleContentsection, after the$edgeHubmodule twin:"filtermodule": {
      "properties.desired":{
          "TemperatureThreshold":25
      }
  }
Add the filtermodule module twin to the deployment manifest. Insert the following JSON content at the bottom of themoduleContentsection, after the$edgeHubmodule twin:
moduleContent
$edgeHub
"filtermodule": {
      "properties.desired":{
          "TemperatureThreshold":25
      }
  }
"filtermodule": {
      "properties.desired":{
          "TemperatureThreshold":25
      }
  }
Save thedeployment.template.jsonfile.
Save thedeployment.template.jsonfile.
In this section, add the code that expands thefiltermoduleto analyze the messages before sending them. You add code that filters messages where the reported machine temperature is within the acceptable limits.
In the Visual Studio Code explorer, openmodules>filtermodule>main.py.
In the Visual Studio Code explorer, openmodules>filtermodule>main.py.
At the top of themain.pyfile, import thejsonlibrary:import json
At the top of themain.pyfile, import thejsonlibrary:
import json
import json
Add global definitions forTEMPERATURE_THRESHOLD,RECEIVED_MESSAGESandTWIN_CALLBACKSvariables. The temperature threshold sets the value that the measured machine temperature must exceed for the data to be sent to the IoT hub.# global counters
TEMPERATURE_THRESHOLD = 25
TWIN_CALLBACKS = 0
RECEIVED_MESSAGES = 0
Add global definitions forTEMPERATURE_THRESHOLD,RECEIVED_MESSAGESandTWIN_CALLBACKSvariables. The temperature threshold sets the value that the measured machine temperature must exceed for the data to be sent to the IoT hub.
# global counters
TEMPERATURE_THRESHOLD = 25
TWIN_CALLBACKS = 0
RECEIVED_MESSAGES = 0
# global counters
TEMPERATURE_THRESHOLD = 25
TWIN_CALLBACKS = 0
RECEIVED_MESSAGES = 0
Replace thecreate_clientfunction with the following code:def create_client():
    client = IoTHubModuleClient.create_from_edge_environment()

    # Define function for handling received messages
    async def receive_message_handler(message):
        global RECEIVED_MESSAGES
        print("Message received")
        size = len(message.data)
        message_text = message.data.decode('utf-8')
        print("    Data: <<<{data}>>> & Size={size}".format(data=message.data, size=size))
        print("    Properties: {}".format(message.custom_properties))
        RECEIVED_MESSAGES += 1
        print("Total messages received: {}".format(RECEIVED_MESSAGES))

        if message.input_name == "input1":
            message_json = json.loads(message_text)
            if "machine" in message_json and "temperature" in message_json["machine"] and message_json["machine"]["temperature"] > TEMPERATURE_THRESHOLD:
                message.custom_properties["MessageType"] = "Alert"
                print("ALERT: Machine temperature {temp} exceeds threshold {threshold}".format(
                    temp=message_json["machine"]["temperature"], threshold=TEMPERATURE_THRESHOLD
                ))
                await client.send_message_to_output(message, "output1")

    # Define function for handling received twin patches
    async def receive_twin_patch_handler(twin_patch):
        global TEMPERATURE_THRESHOLD
        global TWIN_CALLBACKS
        print("Twin Patch received")
        print("     {}".format(twin_patch))
        if "TemperatureThreshold" in twin_patch:
            TEMPERATURE_THRESHOLD = twin_patch["TemperatureThreshold"]
        TWIN_CALLBACKS += 1
        print("Total calls confirmed: {}".format(TWIN_CALLBACKS))

    try:
        # Set handler on the client
        client.on_message_received = receive_message_handler
        client.on_twin_desired_properties_patch_received = receive_twin_patch_handler
    except:
        # Cleanup if failure occurs
        client.shutdown()
        raise

    return client
Replace thecreate_clientfunction with the following code:
def create_client():
    client = IoTHubModuleClient.create_from_edge_environment()

    # Define function for handling received messages
    async def receive_message_handler(message):
        global RECEIVED_MESSAGES
        print("Message received")
        size = len(message.data)
        message_text = message.data.decode('utf-8')
        print("    Data: <<<{data}>>> & Size={size}".format(data=message.data, size=size))
        print("    Properties: {}".format(message.custom_properties))
        RECEIVED_MESSAGES += 1
        print("Total messages received: {}".format(RECEIVED_MESSAGES))

        if message.input_name == "input1":
            message_json = json.loads(message_text)
            if "machine" in message_json and "temperature" in message_json["machine"] and message_json["machine"]["temperature"] > TEMPERATURE_THRESHOLD:
                message.custom_properties["MessageType"] = "Alert"
                print("ALERT: Machine temperature {temp} exceeds threshold {threshold}".format(
                    temp=message_json["machine"]["temperature"], threshold=TEMPERATURE_THRESHOLD
                ))
                await client.send_message_to_output(message, "output1")

    # Define function for handling received twin patches
    async def receive_twin_patch_handler(twin_patch):
        global TEMPERATURE_THRESHOLD
        global TWIN_CALLBACKS
        print("Twin Patch received")
        print("     {}".format(twin_patch))
        if "TemperatureThreshold" in twin_patch:
            TEMPERATURE_THRESHOLD = twin_patch["TemperatureThreshold"]
        TWIN_CALLBACKS += 1
        print("Total calls confirmed: {}".format(TWIN_CALLBACKS))

    try:
        # Set handler on the client
        client.on_message_received = receive_message_handler
        client.on_twin_desired_properties_patch_received = receive_twin_patch_handler
    except:
        # Cleanup if failure occurs
        client.shutdown()
        raise

    return client
def create_client():
    client = IoTHubModuleClient.create_from_edge_environment()

    # Define function for handling received messages
    async def receive_message_handler(message):
        global RECEIVED_MESSAGES
        print("Message received")
        size = len(message.data)
        message_text = message.data.decode('utf-8')
        print("    Data: <<<{data}>>> & Size={size}".format(data=message.data, size=size))
        print("    Properties: {}".format(message.custom_properties))
        RECEIVED_MESSAGES += 1
        print("Total messages received: {}".format(RECEIVED_MESSAGES))

        if message.input_name == "input1":
            message_json = json.loads(message_text)
            if "machine" in message_json and "temperature" in message_json["machine"] and message_json["machine"]["temperature"] > TEMPERATURE_THRESHOLD:
                message.custom_properties["MessageType"] = "Alert"
                print("ALERT: Machine temperature {temp} exceeds threshold {threshold}".format(
                    temp=message_json["machine"]["temperature"], threshold=TEMPERATURE_THRESHOLD
                ))
                await client.send_message_to_output(message, "output1")

    # Define function for handling received twin patches
    async def receive_twin_patch_handler(twin_patch):
        global TEMPERATURE_THRESHOLD
        global TWIN_CALLBACKS
        print("Twin Patch received")
        print("     {}".format(twin_patch))
        if "TemperatureThreshold" in twin_patch:
            TEMPERATURE_THRESHOLD = twin_patch["TemperatureThreshold"]
        TWIN_CALLBACKS += 1
        print("Total calls confirmed: {}".format(TWIN_CALLBACKS))

    try:
        # Set handler on the client
        client.on_message_received = receive_message_handler
        client.on_twin_desired_properties_patch_received = receive_twin_patch_handler
    except:
        # Cleanup if failure occurs
        client.shutdown()
        raise

    return client
Save themain.pyfile.
Save themain.pyfile.
In the Visual Studio Code explorer, open thedeployment.template.jsonfile in your IoT Edge solution workspace.
In the Visual Studio Code explorer, open thedeployment.template.jsonfile in your IoT Edge solution workspace.
Add thefiltermodulemodule twin to the deployment manifest. Insert the following JSON content at the bottom of themodulesContentsection, after the$edgeHubmodule twin:"filtermodule": {
        "properties.desired":{
            "TemperatureThreshold":25
        }
    }
Add thefiltermodulemodule twin to the deployment manifest. Insert the following JSON content at the bottom of themodulesContentsection, after the$edgeHubmodule twin:
"filtermodule": {
        "properties.desired":{
            "TemperatureThreshold":25
        }
    }
"filtermodule": {
        "properties.desired":{
            "TemperatureThreshold":25
        }
    }
Save thedeployment.template.jsonfile.
Save thedeployment.template.jsonfile.
Build and push your solution
You updated the module code and the deployment template to help understand some key deployment concepts. Now, you're ready to build your module container image and push it to your container registry.
In Visual Studio Code, open thedeployment.template.jsondeployment manifest file. Thedeployment manifestdescribes the modules to be configured on the targeted IoT Edge device. Before deployment, you need to update your Azure Container Registry credentials and your module images with the propercreateOptionsvalues. For more information about createOption values, seeHow to configure container create options for IoT Edge modules.
createOptions
If you're using an Azure Container Registry to store your module image, add your credentials to themodulesContent>edgeAgent>settings>registryCredentialssection indeployment.template.json. Replacemyacrwith your own registry name and provide your password andLogin serveraddress. For example:
"registryCredentials": {
    "myacr": {
        "username": "myacr",
        "password": "<your_acr_password>",
        "address": "myacr.azurecr.io"
    }
}
"registryCredentials": {
    "myacr": {
        "username": "myacr",
        "password": "<your_acr_password>",
        "address": "myacr.azurecr.io"
    }
}
Add or replace the following stringified content to thecreateOptionsvalue for each system (edgeHub and edgeAgent) and custom module (filtermodule and tempSensor) listed. Change the values if necessary.
"createOptions": "{\"HostConfig\":{\"PortBindings\":{\"5671/tcp\":[{\"HostPort\":\"5671\"}],\"8883/tcp\":[{\"HostPort\":\"8883\"}],\"443/tcp\":[{\"HostPort\":\"443\"}]}}}"
"createOptions": "{\"HostConfig\":{\"PortBindings\":{\"5671/tcp\":[{\"HostPort\":\"5671\"}],\"8883/tcp\":[{\"HostPort\":\"8883\"}],\"443/tcp\":[{\"HostPort\":\"443\"}]}}}"
For example, thefiltermoduleconfiguration should be similar to:
"filtermodule": {
"version": "1.0",
"type": "docker",
"status": "running",
"restartPolicy": "always",
"settings": {
   "image": "myacr.azurecr.io/filtermodule:0.0.1-amd64",
   "createOptions": "{\"HostConfig\":{\"PortBindings\":{\"5671/tcp\":[{\"HostPort\":\"5671\"}],\"8883/tcp\":[{\"HostPort\":\"8883\"}],\"443/tcp\":[{\"HostPort\":\"443\"}]}}}"
}
"filtermodule": {
"version": "1.0",
"type": "docker",
"status": "running",
"restartPolicy": "always",
"settings": {
   "image": "myacr.azurecr.io/filtermodule:0.0.1-amd64",
   "createOptions": "{\"HostConfig\":{\"PortBindings\":{\"5671/tcp\":[{\"HostPort\":\"5671\"}],\"8883/tcp\":[{\"HostPort\":\"8883\"}],\"443/tcp\":[{\"HostPort\":\"443\"}]}}}"
}
Open the Visual Studio Code integrated terminal by selectingTerminal>New Terminal.
C#
C, Java, Node.js, Python
Use thedotnet publishcommand to build the container image for Linux and amd64 architecture. Change directory to thefiltermoduledirectory in your project and run thedotnet publishcommand.
dotnet publish
dotnet publish --os linux --arch x64 /t:PublishContainer
dotnet publish --os linux --arch x64 /t:PublishContainer
Currently, theiotedgedevtool template targets .NET 7.0. If you want to target a different version of .NET, you can edit thefiltermodule.csprojfile and change theTargetFrameworkandPackageReferencevalues. For example to target .NET 8.0, yourfiltermodule.csprojfile should look like this:
<Project Sdk="Microsoft.NET.Sdk.Worker">
    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>
    <ItemGroup>
        <PackageReference Include="Microsoft.Azure.Devices.Client" Version="1.42.0" />
        <PackageReference Include="Microsoft.Extensions.Hosting" Version="8.0.0" />
    </ItemGroup>
</Project>
<Project Sdk="Microsoft.NET.Sdk.Worker">
    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>
    <ItemGroup>
        <PackageReference Include="Microsoft.Azure.Devices.Client" Version="1.42.0" />
        <PackageReference Include="Microsoft.Extensions.Hosting" Version="8.0.0" />
    </ItemGroup>
</Project>
Tag the docker image with your container registry information, version, and architecture. Replacemyacrwith your own registry name.
docker tag filtermodule myacr.azurecr.io/filtermodule:0.0.1-amd64
docker tag filtermodule myacr.azurecr.io/filtermodule:0.0.1-amd64
Use the module's Dockerfile tobuildand tag the module Docker image.
docker build --rm -f "<DockerFilePath>" -t <ImageNameAndTag> "<ContextPath>"
docker build --rm -f "<DockerFilePath>" -t <ImageNameAndTag> "<ContextPath>"
For example, to build the image for the local registry or an Azure container registry, use the following commands:
# Build and tag the image for the local registry

docker build --rm -f "./modules/filtermodule/Dockerfile.amd64.debug" -t localhost:5000/filtermodule:0.0.1-amd64 "./modules/filtermodule"

# Or build and tag the image for an Azure Container Registry. Replace myacr with your own registry name.

docker build --rm -f "./modules/filtermodule/Dockerfile.amd64.debug" -t myacr.azurecr.io/filtermodule:0.0.1-amd64 "./modules/filtermodule"
# Build and tag the image for the local registry

docker build --rm -f "./modules/filtermodule/Dockerfile.amd64.debug" -t localhost:5000/filtermodule:0.0.1-amd64 "./modules/filtermodule"

# Or build and tag the image for an Azure Container Registry. Replace myacr with your own registry name.

docker build --rm -f "./modules/filtermodule/Dockerfile.amd64.debug" -t myacr.azurecr.io/filtermodule:0.0.1-amd64 "./modules/filtermodule"
Provide your container registry credentials to Docker so that it can push your container image to storage in the registry.
Sign in to Docker with the Azure Container Registry (ACR) credentials.docker login -u <ACR username> -p <ACR password> <ACR login server>You might receive a security warning recommending the use of--password-stdin. While that's a recommended best practice for production scenarios, it's outside the scope of this tutorial. For more information, see thedocker loginreference.
Sign in to Docker with the Azure Container Registry (ACR) credentials.
docker login -u <ACR username> -p <ACR password> <ACR login server>
docker login -u <ACR username> -p <ACR password> <ACR login server>
You might receive a security warning recommending the use of--password-stdin. While that's a recommended best practice for production scenarios, it's outside the scope of this tutorial. For more information, see thedocker loginreference.
--password-stdin
Sign in to the Azure Container Registry. You need toInstall Azure CLIto use theazcommand. This command asks for your user name and password found in your container registry inSettings>Access keys.az acr login -n <ACR registry name>TipIf you get logged out at any point in this tutorial, repeat the Docker and Azure Container Registry sign in steps to continue.
Sign in to the Azure Container Registry. You need toInstall Azure CLIto use theazcommand. This command asks for your user name and password found in your container registry inSettings>Access keys.
az
az acr login -n <ACR registry name>
az acr login -n <ACR registry name>
Tip
If you get logged out at any point in this tutorial, repeat the Docker and Azure Container Registry sign in steps to continue.
Pushyour module image to the local registry or a container registry.docker push <ImageName>For example:# Push the Docker image to the local registry

docker push localhost:5000/filtermodule:0.0.1-amd64

# Or push the Docker image to an Azure Container Registry. Replace myacr with your Azure Container Registry name.

az acr login --name myacr
docker push myacr.azurecr.io/filtermodule:0.0.1-amd64
Pushyour module image to the local registry or a container registry.
docker push <ImageName>
docker push <ImageName>
For example:
# Push the Docker image to the local registry

docker push localhost:5000/filtermodule:0.0.1-amd64

# Or push the Docker image to an Azure Container Registry. Replace myacr with your Azure Container Registry name.

az acr login --name myacr
docker push myacr.azurecr.io/filtermodule:0.0.1-amd64
# Push the Docker image to the local registry

docker push localhost:5000/filtermodule:0.0.1-amd64

# Or push the Docker image to an Azure Container Registry. Replace myacr with your Azure Container Registry name.

az acr login --name myacr
docker push myacr.azurecr.io/filtermodule:0.0.1-amd64
Update the deployment templatedeployment.template.jsonwith the container registry image location. For example, if you're using an Azure Container Registrymyacr.azurecr.ioand your image isfiltermodule:0.0.1-amd64, update thefiltermoduleconfiguration to:
"filtermodule": {
    "version": "1.0",
    "type": "docker",
    "status": "running",
    "restartPolicy": "always",
    "settings": {
        "image": "myacr.azurecr.io/filtermodule:0.0.1-amd64",
        "createOptions": "{\"HostConfig\":{\"PortBindings\":{\"5671/tcp\":[{\"HostPort\":\"5671\"}],\"8883/tcp\":[{\"HostPort\":\"8883\"}],\"443/tcp\":[{\"HostPort\":\"443\"}]}}}"
    }
}
"filtermodule": {
    "version": "1.0",
    "type": "docker",
    "status": "running",
    "restartPolicy": "always",
    "settings": {
        "image": "myacr.azurecr.io/filtermodule:0.0.1-amd64",
        "createOptions": "{\"HostConfig\":{\"PortBindings\":{\"5671/tcp\":[{\"HostPort\":\"5671\"}],\"8883/tcp\":[{\"HostPort\":\"8883\"}],\"443/tcp\":[{\"HostPort\":\"443\"}]}}}"
    }
}
In the Visual Studio Code explorer, right-click thedeployment.template.jsonfile and selectBuild and Push IoT Edge Solution.
The build and push command starts three operations. First, it creates a new folder in the solution calledconfigthat holds the full deployment manifest, built out of information in the deployment template and other solution files. Second, it runsdocker buildto build the container image based on the appropriate dockerfile for your target architecture. Then, it runsdocker pushto push the image repository to your container registry.
docker build
docker push
This process may take several minutes the first time, but is faster the next time that you run the commands.
If you make changes to your module code, you need to rebuild and push the module image to your container registry. Use the steps in this section to update the build and container image. You can skip this section if you didn't make any changes to your module code.
Open thedeployment.amd64.jsonfile in newly created config folder. The filename reflects the target architecture, so it's different if you chose a different architecture.
Notice that the two parameters that had placeholders now contain their proper values. TheregistryCredentialssection has your registry username and password pulled from the.envfile. Thefiltermodulehas the full image repository with the name, version, and architecture tag from themodule.jsonfile.
Open themodule.jsonfile in thefiltermodulefolder.
Open themodule.jsonfile in thefiltermodulefolder.
Change the version number for the module image. For example, increment the patch version number to"version": "0.0.2"as if you made a small fix in the module code.TipModule versions enable version control, and allow you to test changes on a small set of devices before deploying updates to production. If you don't increment the module version before building and pushing, then you overwrite the repository in your container registry.
Change the version number for the module image. For example, increment the patch version number to"version": "0.0.2"as if you made a small fix in the module code.
"version": "0.0.2"
Tip
Module versions enable version control, and allow you to test changes on a small set of devices before deploying updates to production. If you don't increment the module version before building and pushing, then you overwrite the repository in your container registry.
Save your changes to themodule.jsonfile.
Save your changes to themodule.jsonfile.
Build and push the updated image with a0.0.2version tag. For example, to build and push the image for the local registry or an Azure container registry, use the following commands:
C#
C, Java, Node.js, Python
# Build the container image for Linux and amd64 architecture.

dotnet publish --os linux --arch x64

# For local registry:
# Tag the image with version 0.0.2, x64 architecture, and the local registry.

docker tag filtermodule localhost:5000/filtermodule:0.0.2-amd64

# For Azure Container Registry:
# Tag the image with version 0.0.2, x64 architecture, and your container registry information. Replace **myacr** with your own registry name.

docker tag filtermodule myacr.azurecr.io/filtermodule:0.0.2-amd64
# Build the container image for Linux and amd64 architecture.

dotnet publish --os linux --arch x64

# For local registry:
# Tag the image with version 0.0.2, x64 architecture, and the local registry.

docker tag filtermodule localhost:5000/filtermodule:0.0.2-amd64

# For Azure Container Registry:
# Tag the image with version 0.0.2, x64 architecture, and your container registry information. Replace **myacr** with your own registry name.

docker tag filtermodule myacr.azurecr.io/filtermodule:0.0.2-amd64
# Build and push the 0.0.2 image for the local registry

docker build --rm -f "./modules/filtermodule/Dockerfile.amd64.debug" -t localhost:5000/filtermodule:0.0.2-amd64 "./modules/filtermodule"

docker push localhost:5000/filtermodule:0.0.2-amd64

# Or build and push the 0.0.2 image for an Azure Container Registry. Replace myacr with your own registry name.

docker build --rm -f "./modules/filtermodule/Dockerfile.amd64.debug" -t myacr.azurecr.io/filtermodule:0.0.2-amd64 "./modules/filtermodule"

docker push myacr.azurecr.io/filtermodule:0.0.2-amd64
# Build and push the 0.0.2 image for the local registry

docker build --rm -f "./modules/filtermodule/Dockerfile.amd64.debug" -t localhost:5000/filtermodule:0.0.2-amd64 "./modules/filtermodule"

docker push localhost:5000/filtermodule:0.0.2-amd64

# Or build and push the 0.0.2 image for an Azure Container Registry. Replace myacr with your own registry name.

docker build --rm -f "./modules/filtermodule/Dockerfile.amd64.debug" -t myacr.azurecr.io/filtermodule:0.0.2-amd64 "./modules/filtermodule"

docker push myacr.azurecr.io/filtermodule:0.0.2-amd64
Right-click thedeployment.template.jsonfile again, and again selectBuild and Push IoT Edge Solution.
Open thedeployment.amd64.jsonfile again. Notice the build system doesn't create a new file when you run the build and push command again. Rather, the same file updates to reflect the changes. Thefiltermoduleimage now points to the 0.0.2 version of the container.
To further verify what the build and push command did, go to theAzure portaland navigate to your container registry.
In your container registry, selectRepositoriesthenfiltermodule. Verify that both versions of the image push to the registry.

Troubleshoot
If you encounter errors when building and pushing your module image, it often has to do with Docker configuration on your development machine. Use the following checks to review your configuration:
Did you run thedocker logincommand using the credentials that you copied from your container registry? These credentials are different than the ones that you use to sign in to Azure.
docker login
Is your container repository correct? Does it have your correct container registry name and your correct module name? Open themodule.jsonfile in thefiltermodulefolder to check. The repository value should look like<registry name>.azurecr.io/filtermodule.
If you used a different name thanfiltermodulefor your module, is that name consistent throughout the solution?
Is your machine running the same type of containers that you're building? This tutorial is for Linux IoT Edge devices, so Visual Studio Code should sayamd64orarm32v7in the side bar, and Docker Desktop should be running Linux containers.
Deploy modules to device
You verified that there are built container images stored in your container registry, so it's time to deploy them to a device. Make sure that your IoT Edge device is up and running.
Use theIoT Edge Azure CLI set-modulescommand to deploy the modules to the Azure IoT Hub. For example, to deploy the modules defined in thedeployment.template.jsonfile to IoT Hubmy-iot-hubfor the IoT Edge devicemy-device, use the following command. Replace the values forhub-name,device-id, andloginIoT Hub connection string with your own.
az iot edge set-modules --hub-name my-iot-hub --device-id my-device --content ./deployment.template.json --login "HostName=my-iot-hub.azure-devices.net;SharedAccessKeyName=iothubowner;SharedAccessKey=<SharedAccessKey>"
az iot edge set-modules --hub-name my-iot-hub --device-id my-device --content ./deployment.template.json --login "HostName=my-iot-hub.azure-devices.net;SharedAccessKeyName=iothubowner;SharedAccessKey=<SharedAccessKey>"
Tip
You can find your IoT Hub connection string including the shared access key in the Azure portal. Go to your IoT Hub >Security settings>Shared access policies>iothubowner.
In the Visual Studio Code explorer, under theAzure IoT Hubsection, expandDevicesto see your list of IoT devices.
In the Visual Studio Code explorer, under theAzure IoT Hubsection, expandDevicesto see your list of IoT devices.
Right-click the IoT Edge device that you want to deploy to, then selectCreate Deployment for Single Device.
Right-click the IoT Edge device that you want to deploy to, then selectCreate Deployment for Single Device.
In the file explorer, navigate into theconfigfolder then select thedeployment.amd64.jsonfile.Don't use the deployment.template.json file, which doesn't have the container registry credentials or module image values in it. If you target a Linux ARM32 device, the deployment manifest's name isdeployment.arm32v7.json.
In the file explorer, navigate into theconfigfolder then select thedeployment.amd64.jsonfile.
Don't use the deployment.template.json file, which doesn't have the container registry credentials or module image values in it. If you target a Linux ARM32 device, the deployment manifest's name isdeployment.arm32v7.json.
Under your device, expandModulesto see a list of deployed and running modules. Select the refresh button. You should see the newtempSensorandfiltermodulemodules running on your device.It might take a few minutes for the modules to start. The IoT Edge runtime needs to receive its new deployment manifest, pull down the module images from the container runtime, then start each new module.
Under your device, expandModulesto see a list of deployed and running modules. Select the refresh button. You should see the newtempSensorandfiltermodulemodules running on your device.
It might take a few minutes for the modules to start. The IoT Edge runtime needs to receive its new deployment manifest, pull down the module images from the container runtime, then start each new module.
View messages from device
The sample module code receives messages through its input queue and passes them along through its output queue. The deployment manifest declared routes that passed messages tofiltermodulefromtempSensor, and then forwarded messages fromfiltermoduleto IoT Hub. The Azure IoT Edge and Azure IoT Hub extensions allow you to see messages as they arrive at IoT Hub from your individual devices.
In the Visual Studio Code explorer, right-click the IoT Edge device that you want to monitor, then selectStart Monitoring Built-in Event Endpoint.
In the Visual Studio Code explorer, right-click the IoT Edge device that you want to monitor, then selectStart Monitoring Built-in Event Endpoint.
Watch the output window in Visual Studio Code to see messages arriving at your IoT hub.
Watch the output window in Visual Studio Code to see messages arriving at your IoT hub.

View changes on device
If you want to see what's happening on your device itself, use the commands in this section to inspect the IoT Edge runtime and modules running on your device.
The commands in this section are for your IoT Edge device, not your development machine. If you're using a virtual machine for your IoT Edge device, connect to it now. In Azure, go to the virtual machine's overview page and selectConnectto access the secure shell connection.
View all modules deployed to your device, and check their status:iotedge listYou should see four modules: the two IoT Edge runtime modules,tempSensor, andfiltermodule. You should see all four listed as running.
View all modules deployed to your device, and check their status:
iotedge list
iotedge list
You should see four modules: the two IoT Edge runtime modules,tempSensor, andfiltermodule. You should see all four listed as running.
Inspect the logs for a specific module:iotedge logs <module name>IoT Edge modules are case-sensitive.ThetempSensorandfiltermodulelogs should show the messages they're processing. The edgeAgent module is responsible for starting the other modules, so its logs have information about implementing the deployment manifest. If you find a module is unlisted or not running, the edgeAgent logs likely have the errors. The edgeHub module is responsible for communications between the modules and IoT Hub. If the modules are up and running, but the messages aren't arriving at your IoT hub, the edgeHub logs likely have the errors.
Inspect the logs for a specific module:
iotedge logs <module name>
iotedge logs <module name>
IoT Edge modules are case-sensitive.
ThetempSensorandfiltermodulelogs should show the messages they're processing. The edgeAgent module is responsible for starting the other modules, so its logs have information about implementing the deployment manifest. If you find a module is unlisted or not running, the edgeAgent logs likely have the errors. The edgeHub module is responsible for communications between the modules and IoT Hub. If the modules are up and running, but the messages aren't arriving at your IoT hub, the edgeHub logs likely have the errors.
Clean up resources
If you plan to continue to the next recommended article, you can keep the resources and configurations that you created and reuse them. You can also keep using the same IoT Edge device as a test device.
Otherwise, you can delete the local configurations and the Azure resources that you used in this article to avoid charges.
Delete Azure resources
Deleting Azure resources and resource groups is irreversible. Make sure that you don't accidentally delete the wrong resource group or resources. If you created the IoT hub inside an existing resource group that has resources that you want to keep, delete only the IoT hub resource itself, not the resource group.
To delete the resources:
Sign in to theAzure portal, and then selectResource groups.
Sign in to theAzure portal, and then selectResource groups.
Select the name of the resource group that contains your IoT Edge test resources.
Select the name of the resource group that contains your IoT Edge test resources.
Review the list of resources that your resource group contains. If you want to delete all of them, you can selectDelete resource group. If you want to delete only some of them, you can select each resource to delete them individually.
Review the list of resources that your resource group contains. If you want to delete all of them, you can selectDelete resource group. If you want to delete only some of them, you can select each resource to delete them individually.
Next steps
In this tutorial, you set up Visual Studio Code on your development machine and deployed your first IoT Edge module that contains code to filter raw data generated by your IoT Edge device.
You can continue on to the next tutorials to learn how Azure IoT Edge can help you deploy Azure cloud services to process and analyze data at the edge.
Debug Azure IoT Edge modulesFunctionsStream AnalyticsCustom Vision Service
Feedback
Was this page helpful?
Additional resources