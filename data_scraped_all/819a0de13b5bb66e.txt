Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Configure Azure Monitor OpenTelemetry
Article
2025-03-26
19 contributors
In this article
This guide explains how to configure OpenTelemetry (OTel) inAzure Monitor Application Insightsusing the Azure Monitor OpenTelemetry distro. Proper configuration ensures consistent telemetry data collection across .NET, Java, Node.js, and Python applications, allowing for more reliable monitoring and diagnostics.
Connection string
A connection string in Application Insights defines the target location for sending telemetry data.
ASP.NET Core
.NET
Java
Java native
Node.js
Python
Use one of the following three ways to configure the connection string:
AddUseAzureMonitor()to yourprogram.csfile:var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry().UseAzureMonitor(options => {
    options.ConnectionString = "<Your Connection String>";
});

var app = builder.Build();

app.Run();
AddUseAzureMonitor()to yourprogram.csfile:
UseAzureMonitor()
program.cs
var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry().UseAzureMonitor(options => {
    options.ConnectionString = "<Your Connection String>";
});

var app = builder.Build();

app.Run();
var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry().UseAzureMonitor(options => {
    options.ConnectionString = "<Your Connection String>";
});

var app = builder.Build();

app.Run();
Set an environment variable.APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
Set an environment variable.
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
Add the following section to yourappsettings.jsonconfig file.{
  "AzureMonitor": {
      "ConnectionString": "<Your Connection String>"
  }
}
Add the following section to yourappsettings.jsonconfig file.
appsettings.json
{
  "AzureMonitor": {
      "ConnectionString": "<Your Connection String>"
  }
}
{
  "AzureMonitor": {
      "ConnectionString": "<Your Connection String>"
  }
}
Note
If you set the connection string in more than one place, we adhere to the following precedence:
Code
Environment Variable
Configuration File
Use one of the following two ways to configure the connection string:
Add the Azure Monitor Exporter to each OpenTelemetry signal in application startup.// Create a new OpenTelemetry tracer provider.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddAzureMonitorTraceExporter(options =>
    {
        options.ConnectionString = "<Your Connection String>";
    })
    .Build();

// Create a new OpenTelemetry meter provider.
// It is important to keep the MetricsProvider instance active throughout the process lifetime.
var metricsProvider = Sdk.CreateMeterProviderBuilder()
    .AddAzureMonitorMetricExporter(options =>
    {
        options.ConnectionString = "<Your Connection String>";
    })
    .Build();

// Create a new logger factory.
// It is important to keep the LoggerFactory instance active throughout the process lifetime.
var loggerFactory = LoggerFactory.Create(builder =>
{
    builder.AddOpenTelemetry(logging =>
    {
        logging.AddAzureMonitorLogExporter(options =>
        {
            options.ConnectionString = "<Your Connection String>";
        });
    });
});
Add the Azure Monitor Exporter to each OpenTelemetry signal in application startup.
// Create a new OpenTelemetry tracer provider.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddAzureMonitorTraceExporter(options =>
    {
        options.ConnectionString = "<Your Connection String>";
    })
    .Build();

// Create a new OpenTelemetry meter provider.
// It is important to keep the MetricsProvider instance active throughout the process lifetime.
var metricsProvider = Sdk.CreateMeterProviderBuilder()
    .AddAzureMonitorMetricExporter(options =>
    {
        options.ConnectionString = "<Your Connection String>";
    })
    .Build();

// Create a new logger factory.
// It is important to keep the LoggerFactory instance active throughout the process lifetime.
var loggerFactory = LoggerFactory.Create(builder =>
{
    builder.AddOpenTelemetry(logging =>
    {
        logging.AddAzureMonitorLogExporter(options =>
        {
            options.ConnectionString = "<Your Connection String>";
        });
    });
});
// Create a new OpenTelemetry tracer provider.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddAzureMonitorTraceExporter(options =>
    {
        options.ConnectionString = "<Your Connection String>";
    })
    .Build();

// Create a new OpenTelemetry meter provider.
// It is important to keep the MetricsProvider instance active throughout the process lifetime.
var metricsProvider = Sdk.CreateMeterProviderBuilder()
    .AddAzureMonitorMetricExporter(options =>
    {
        options.ConnectionString = "<Your Connection String>";
    })
    .Build();

// Create a new logger factory.
// It is important to keep the LoggerFactory instance active throughout the process lifetime.
var loggerFactory = LoggerFactory.Create(builder =>
{
    builder.AddOpenTelemetry(logging =>
    {
        logging.AddAzureMonitorLogExporter(options =>
        {
            options.ConnectionString = "<Your Connection String>";
        });
    });
});
Set an environment variable.APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
Set an environment variable.
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
Note
If you set the connection string in more than one place, we adhere to the following precedence:
Code
Environment Variable
To set the connection string, seeConnection string.
Use one of the following two ways to configure the connection string:
Set an environment variable.APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
Set an environment variable.
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
Set a property.applicationinsights.connection.string=<Your Connection String>
Set a property.
applicationinsights.connection.string=<Your Connection String>
applicationinsights.connection.string=<Your Connection String>
Use one of the following two ways to configure the connection string:
Set an environment variable.APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
Set an environment variable.
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
Use a configuration object.// Import the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions class from the @azure/monitor-opentelemetry package.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");

// Create a new AzureMonitorOpenTelemetryOptions object.
const options: AzureMonitorOpenTelemetryOptions = {
  azureMonitorExporterOptions: {
    connectionString: "<your connection string>"
  }
};

// Enable Azure Monitor integration using the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions object.
useAzureMonitor(options);
Use a configuration object.
// Import the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions class from the @azure/monitor-opentelemetry package.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");

// Create a new AzureMonitorOpenTelemetryOptions object.
const options: AzureMonitorOpenTelemetryOptions = {
  azureMonitorExporterOptions: {
    connectionString: "<your connection string>"
  }
};

// Enable Azure Monitor integration using the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions object.
useAzureMonitor(options);
// Import the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions class from the @azure/monitor-opentelemetry package.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");

// Create a new AzureMonitorOpenTelemetryOptions object.
const options: AzureMonitorOpenTelemetryOptions = {
  azureMonitorExporterOptions: {
    connectionString: "<your connection string>"
  }
};

// Enable Azure Monitor integration using the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions object.
useAzureMonitor(options);
Use one of the following two ways to configure the connection string:
Set an environment variable.APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
Set an environment variable.
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
APPLICATIONINSIGHTS_CONNECTION_STRING=<Your Connection String>
Use theconfigure_azure_monitorfunction.
Use theconfigure_azure_monitorfunction.
configure_azure_monitor
# Import the `configure_azure_monitor()` function from the `azure.monitor.opentelemetry` package.
from azure.monitor.opentelemetry import configure_azure_monitor

# Configure OpenTelemetry to use Azure Monitor with the specified connection string.
# Replace `<your-connection-string>` with the connection string of your Azure Monitor Application Insights resource.
configure_azure_monitor(
    connection_string="<your-connection-string>",
)
# Import the `configure_azure_monitor()` function from the `azure.monitor.opentelemetry` package.
from azure.monitor.opentelemetry import configure_azure_monitor

# Configure OpenTelemetry to use Azure Monitor with the specified connection string.
# Replace `<your-connection-string>` with the connection string of your Azure Monitor Application Insights resource.
configure_azure_monitor(
    connection_string="<your-connection-string>",
)
Set the Cloud Role Name and the Cloud Role Instance
Forsupported languages, the Azure Monitor OpenTelemetry Distro automatically detects the resource context and provides default values for theCloud Role Nameand the Cloud Role Instance properties of your component. However, you might want to override the default values to something that makes sense to your team. The cloud role name value appears on the Application Map as the name underneath a node.
ASP.NET Core
.NET
Java
Java native
Node.js
Python
Set the Cloud Role Name and the Cloud Role Instance viaResourceattributes. Cloud Role Name usesservice.namespaceandservice.nameattributes, although it falls back toservice.nameifservice.namespaceisn't set. Cloud Role Instance uses theservice.instance.idattribute value. For information on standard attributes for resources, seeOpenTelemetry Semantic Conventions.
service.namespace
service.name
service.name
service.namespace
service.instance.id
// Setting role name and role instance

// Create a dictionary of resource attributes.
var resourceAttributes = new Dictionary<string, object> {
    { "service.name", "my-service" },
    { "service.namespace", "my-namespace" },
    { "service.instance.id", "my-instance" }};

// Create a new ASP.NET Core web application builder.
var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry()
    .UseAzureMonitor()
    // Configure the ResourceBuilder to add the custom resource attributes to all signals.
    // Custom resource attributes should be added AFTER AzureMonitor to override the default ResourceDetectors.
    .ConfigureResource(resourceBuilder => resourceBuilder.AddAttributes(_testResourceAttributes));

// Build the ASP.NET Core web application.
var app = builder.Build();

// Start the ASP.NET Core web application.
app.Run();
// Setting role name and role instance

// Create a dictionary of resource attributes.
var resourceAttributes = new Dictionary<string, object> {
    { "service.name", "my-service" },
    { "service.namespace", "my-namespace" },
    { "service.instance.id", "my-instance" }};

// Create a new ASP.NET Core web application builder.
var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry()
    .UseAzureMonitor()
    // Configure the ResourceBuilder to add the custom resource attributes to all signals.
    // Custom resource attributes should be added AFTER AzureMonitor to override the default ResourceDetectors.
    .ConfigureResource(resourceBuilder => resourceBuilder.AddAttributes(_testResourceAttributes));

// Build the ASP.NET Core web application.
var app = builder.Build();

// Start the ASP.NET Core web application.
app.Run();
Set the Cloud Role Name and the Cloud Role Instance viaResourceattributes. Cloud Role Name usesservice.namespaceandservice.nameattributes, although it falls back toservice.nameifservice.namespaceisn't set. Cloud Role Instance uses theservice.instance.idattribute value. For information on standard attributes for resources, seeOpenTelemetry Semantic Conventions.
service.namespace
service.name
service.name
service.namespace
service.instance.id
// Setting role name and role instance

// Create a dictionary of resource attributes.
var resourceAttributes = new Dictionary<string, object> {
    { "service.name", "my-service" },
    { "service.namespace", "my-namespace" },
    { "service.instance.id", "my-instance" }};

// Create a resource builder.
var resourceBuilder = ResourceBuilder.CreateDefault().AddAttributes(resourceAttributes);

// Create a new OpenTelemetry tracer provider and set the resource builder.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    // Set ResourceBuilder on the TracerProvider.
    .SetResourceBuilder(resourceBuilder)
    .AddAzureMonitorTraceExporter()
    .Build();

// Create a new OpenTelemetry meter provider and set the resource builder.
// It is important to keep the MetricsProvider instance active throughout the process lifetime.
var metricsProvider = Sdk.CreateMeterProviderBuilder()
    // Set ResourceBuilder on the MeterProvider.
    .SetResourceBuilder(resourceBuilder)
    .AddAzureMonitorMetricExporter()
    .Build();

// Create a new logger factory and add the OpenTelemetry logger provider with the resource builder.
// It is important to keep the LoggerFactory instance active throughout the process lifetime.
var loggerFactory = LoggerFactory.Create(builder =>
{
    builder.AddOpenTelemetry(logging =>
    {
        // Set ResourceBuilder on the Logging config.
        logging.SetResourceBuilder(resourceBuilder);
        logging.AddAzureMonitorLogExporter();
    });
});
// Setting role name and role instance

// Create a dictionary of resource attributes.
var resourceAttributes = new Dictionary<string, object> {
    { "service.name", "my-service" },
    { "service.namespace", "my-namespace" },
    { "service.instance.id", "my-instance" }};

// Create a resource builder.
var resourceBuilder = ResourceBuilder.CreateDefault().AddAttributes(resourceAttributes);

// Create a new OpenTelemetry tracer provider and set the resource builder.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    // Set ResourceBuilder on the TracerProvider.
    .SetResourceBuilder(resourceBuilder)
    .AddAzureMonitorTraceExporter()
    .Build();

// Create a new OpenTelemetry meter provider and set the resource builder.
// It is important to keep the MetricsProvider instance active throughout the process lifetime.
var metricsProvider = Sdk.CreateMeterProviderBuilder()
    // Set ResourceBuilder on the MeterProvider.
    .SetResourceBuilder(resourceBuilder)
    .AddAzureMonitorMetricExporter()
    .Build();

// Create a new logger factory and add the OpenTelemetry logger provider with the resource builder.
// It is important to keep the LoggerFactory instance active throughout the process lifetime.
var loggerFactory = LoggerFactory.Create(builder =>
{
    builder.AddOpenTelemetry(logging =>
    {
        // Set ResourceBuilder on the Logging config.
        logging.SetResourceBuilder(resourceBuilder);
        logging.AddAzureMonitorLogExporter();
    });
});
To set the cloud role name, seecloud role name.
To set the cloud role instance, seecloud role instance.
To set the cloud role name:
Use thespring.application.namefor Spring Boot native image applications
spring.application.name
Use thequarkus.application.namefor Quarkus native image applications
quarkus.application.name
Set the Cloud Role Name and the Cloud Role Instance viaResourceattributes. Cloud Role Name usesservice.namespaceandservice.nameattributes, although it falls back toservice.nameifservice.namespaceisn't set. Cloud Role Instance uses theservice.instance.idattribute value. For information on standard attributes for resources, seeOpenTelemetry Semantic Conventions.
service.namespace
service.name
service.name
service.namespace
service.instance.id
// Import the useAzureMonitor function, the AzureMonitorOpenTelemetryOptions class, the Resource class, and the SemanticResourceAttributes class from the @azure/monitor-opentelemetry, @opentelemetry/resources, and @opentelemetry/semantic-conventions packages, respectively.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");
const { Resource } = require("@opentelemetry/resources");
const { SemanticResourceAttributes } = require("@opentelemetry/semantic-conventions");

// Create a new Resource object with the following custom resource attributes:
//
// * service_name: my-service
// * service_namespace: my-namespace
// * service_instance_id: my-instance
const customResource = new Resource({
  [SemanticResourceAttributes.SERVICE_NAME]: "my-service",
  [SemanticResourceAttributes.SERVICE_NAMESPACE]: "my-namespace",
  [SemanticResourceAttributes.SERVICE_INSTANCE_ID]: "my-instance",
});

// Create a new AzureMonitorOpenTelemetryOptions object and set the resource property to the customResource object.
const options: AzureMonitorOpenTelemetryOptions = {
  resource: customResource
};

// Enable Azure Monitor integration using the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions object.
useAzureMonitor(options);
// Import the useAzureMonitor function, the AzureMonitorOpenTelemetryOptions class, the Resource class, and the SemanticResourceAttributes class from the @azure/monitor-opentelemetry, @opentelemetry/resources, and @opentelemetry/semantic-conventions packages, respectively.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");
const { Resource } = require("@opentelemetry/resources");
const { SemanticResourceAttributes } = require("@opentelemetry/semantic-conventions");

// Create a new Resource object with the following custom resource attributes:
//
// * service_name: my-service
// * service_namespace: my-namespace
// * service_instance_id: my-instance
const customResource = new Resource({
  [SemanticResourceAttributes.SERVICE_NAME]: "my-service",
  [SemanticResourceAttributes.SERVICE_NAMESPACE]: "my-namespace",
  [SemanticResourceAttributes.SERVICE_INSTANCE_ID]: "my-instance",
});

// Create a new AzureMonitorOpenTelemetryOptions object and set the resource property to the customResource object.
const options: AzureMonitorOpenTelemetryOptions = {
  resource: customResource
};

// Enable Azure Monitor integration using the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions object.
useAzureMonitor(options);
Set the Cloud Role Name and the Cloud Role Instance viaResourceattributes. Cloud Role Name usesservice.namespaceandservice.nameattributes, although it falls back toservice.nameifservice.namespaceisn't set. Cloud Role Instance uses theservice.instance.idattribute value. For information on standard attributes for resources, seeOpenTelemetry Semantic Conventions.
service.namespace
service.name
service.name
service.namespace
service.instance.id
Set Resource attributes using theOTEL_RESOURCE_ATTRIBUTESand/orOTEL_SERVICE_NAMEenvironment variables.OTEL_RESOURCE_ATTRIBUTEStakes series of comma-separated key-value pairs. For example, to set the Cloud Role Name tomy-namespace.my-helloworld-serviceand set Cloud Role Instance tomy-instance, you can setOTEL_RESOURCE_ATTRIBUTESandOTEL_SERVICE_NAMEas such:
OTEL_RESOURCE_ATTRIBUTES
OTEL_SERVICE_NAME
OTEL_RESOURCE_ATTRIBUTES
my-namespace.my-helloworld-service
my-instance
OTEL_RESOURCE_ATTRIBUTES
OTEL_SERVICE_NAME
export OTEL_RESOURCE_ATTRIBUTES="service.namespace=my-namespace,service.instance.id=my-instance"
export OTEL_SERVICE_NAME="my-helloworld-service"
export OTEL_RESOURCE_ATTRIBUTES="service.namespace=my-namespace,service.instance.id=my-instance"
export OTEL_SERVICE_NAME="my-helloworld-service"
If you don't set theservice.namespaceResource attribute, you can alternatively set the Cloud Role Name with only the OTEL_SERVICE_NAME environment variable or theservice.nameResource attribute. For example, to set the Cloud Role Name tomy-helloworld-serviceand set Cloud Role Instance tomy-instance, you can setOTEL_RESOURCE_ATTRIBUTESandOTEL_SERVICE_NAMEas such:
service.namespace
service.name
my-helloworld-service
my-instance
OTEL_RESOURCE_ATTRIBUTES
OTEL_SERVICE_NAME
export OTEL_RESOURCE_ATTRIBUTES="service.instance.id=my-instance"
export OTEL_SERVICE_NAME="my-helloworld-service"
export OTEL_RESOURCE_ATTRIBUTES="service.instance.id=my-instance"
export OTEL_SERVICE_NAME="my-helloworld-service"
Enable Sampling
You might want to enable sampling to reduce your data ingestion volume, which reduces your cost. Azure Monitor provides a customfixed-ratesampler that populates events with a sampling ratio, which Application Insights converts toItemCount. Thefixed-ratesampler ensures accurate experiences and event counts. The sampler is designed to preserve your traces across services, and it's interoperable with older Application Insights Software Development Kits (SDKs). For more information, seeLearn More about sampling.
ItemCount
Note
Metrics and Logs are unaffected by sampling.
If you're seeing unexpected charges or high costs in Application Insights, this guide can help. It covers common causes like high telemetry volume, data ingestion spikes, and misconfigured sampling. It's especially useful if you're troubleshooting issues related to cost spikes, telemetry volume, sampling not working, data caps, high ingestion, or unexpected billing. To get started, seeTroubleshoot high data ingestion in Application Insights.
ASP.NET Core
.NET
Java
Java native
Node.js
Python
The sampler expects a sample rate of between 0 and 1 inclusive. A rate of 0.1 means approximately 10% of your traces are sent.
// Create a new ASP.NET Core web application builder.
var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry().UseAzureMonitor(options =>
{
    // Set the sampling ratio to 10%. This means that 10% of all traces will be sampled and sent to Azure Monitor.
    options.SamplingRatio = 0.1F;
});

// Build the ASP.NET Core web application.
var app = builder.Build();

// Start the ASP.NET Core web application.
app.Run();
// Create a new ASP.NET Core web application builder.
var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry().UseAzureMonitor(options =>
{
    // Set the sampling ratio to 10%. This means that 10% of all traces will be sampled and sent to Azure Monitor.
    options.SamplingRatio = 0.1F;
});

// Build the ASP.NET Core web application.
var app = builder.Build();

// Start the ASP.NET Core web application.
app.Run();
The sampler expects a sample rate of between 0 and 1 inclusive. A rate of 0.1 means approximately 10% of your traces are sent.
// Create a new OpenTelemetry tracer provider.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddAzureMonitorTraceExporter(options =>
    {   
        // Set the sampling ratio to 10%. This means that 10% of all traces will be sampled and sent to Azure Monitor.
        options.SamplingRatio = 0.1F;
    })
    .Build();
// Create a new OpenTelemetry tracer provider.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddAzureMonitorTraceExporter(options =>
    {   
        // Set the sampling ratio to 10%. This means that 10% of all traces will be sampled and sent to Azure Monitor.
        options.SamplingRatio = 0.1F;
    })
    .Build();
Starting from 3.4.0, rate-limited sampling is available and is now the default. For more information about sampling, seeJava sampling.
For Spring Boot native applications, thesampling configurations of the OpenTelemetry Java SDK are applicable.
For Quarkus native applications, review theQuarkus OpenTelemetry documentation.
The sampler expects a sample rate of between 0 and 1 inclusive. A rate of 0.1 means approximately 10% of your traces are sent.
// Import the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions class from the @azure/monitor-opentelemetry package.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");

// Create a new AzureMonitorOpenTelemetryOptions object and set the samplingRatio property to 0.1.
const options: AzureMonitorOpenTelemetryOptions = {
  samplingRatio: 0.1
};

// Enable Azure Monitor integration using the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions object.
useAzureMonitor(options);
// Import the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions class from the @azure/monitor-opentelemetry package.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");

// Create a new AzureMonitorOpenTelemetryOptions object and set the samplingRatio property to 0.1.
const options: AzureMonitorOpenTelemetryOptions = {
  samplingRatio: 0.1
};

// Enable Azure Monitor integration using the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions object.
useAzureMonitor(options);
Theconfigure_azure_monitor()function automatically utilizes
ApplicationInsightsSampler for compatibility with Application Insights SDKs and
to sample your telemetry. TheOTEL_TRACES_SAMPLER_ARGenvironment variable can be used to specify
the sampling rate, with a valid range of 0 to 1, where 0 is 0% and 1 is 100%.
For example, a value of 0.1 means 10% of your traces are sent.
configure_azure_monitor()
OTEL_TRACES_SAMPLER_ARG
export OTEL_TRACES_SAMPLER_ARG=0.1
export OTEL_TRACES_SAMPLER_ARG=0.1
Tip
When using fixed-rate/percentage sampling and you aren't sure what to set the sampling rate as, start at 5%. (0.05 sampling ratio) Adjust the rate based on the accuracy of the operations shown in the failures and performance panes. A higher rate generally results in higher accuracy. However, ANY sampling affects accuracy so we recommend alerting onOpenTelemetry metrics, which are unaffected by sampling.

Live metrics
Live metricsprovides a real-time analytics dashboard for insight into application activity and performance.
ASP.NET Core
.NET
Java
Java native
Node.js
Python
Important
See theSupplemental Terms of Use for Microsoft Azure Previewsfor legal terms that apply to Azure features that are in beta, preview, or otherwise not yet released into general availability.
This feature is enabled by default.
Users can disable Live Metrics when configuring the Distro.
builder.Services.AddOpenTelemetry().UseAzureMonitor(options => {
	// Disable the Live Metrics feature.
    options.EnableLiveMetrics = false;
});
builder.Services.AddOpenTelemetry().UseAzureMonitor(options => {
	// Disable the Live Metrics feature.
    options.EnableLiveMetrics = false;
});
This feature isn't available in the Azure Monitor .NET Exporter.
Note
We recommend theAzure Monitor OpenTelemetry Exporterfor console and worker service applications, which doesn't include live metrics.
The Live Metrics experience is enabled by default.
For more information on Java configuration, seeConfiguration options: Azure Monitor Application Insights for Java.
The Live Metrics aren't available today for GraalVM native applications.
Important
See theSupplemental Terms of Use for Microsoft Azure Previewsfor legal terms that apply to Azure features that are in beta, preview, or otherwise not yet released into general availability.
Users can enable/disable Live Metrics when configuring the Distro using theenableLiveMetricsproperty.
enableLiveMetrics
const options: AzureMonitorOpenTelemetryOptions = {
    azureMonitorExporterOptions: {
        connectionString:
            process.env["APPLICATIONINSIGHTS_CONNECTION_STRING"] || "<your connection string>",
    },
    enableLiveMetrics: false
};

useAzureMonitor(options);
const options: AzureMonitorOpenTelemetryOptions = {
    azureMonitorExporterOptions: {
        connectionString:
            process.env["APPLICATIONINSIGHTS_CONNECTION_STRING"] || "<your connection string>",
    },
    enableLiveMetrics: false
};

useAzureMonitor(options);
Important
See theSupplemental Terms of Use for Microsoft Azure Previewsfor legal terms that apply to Azure features that are in beta, preview, or otherwise not yet released into general availability.
You can enable live metrics using the Azure monitor OpenTelemetry Distro for Python as follows:
...
configure_azure_monitor(
	enable_live_metrics=True
)
...
...
configure_azure_monitor(
	enable_live_metrics=True
)
...
Enable Microsoft Entra ID (formerly Azure AD) authentication
You might want to enable Microsoft Entra authentication for a more secure connection to Azure, which prevents unauthorized telemetry from being ingested into your subscription.
For more information, see our dedicated Microsoft Entra authentication page linked for each supported language.
ASP.NET Core
.NET
Java
Java native
Node.js
Python
For information on configuring Entra ID authentication, seeMicrosoft Entra authentication for Application Insights
For information on configuring Entra ID authentication, seeMicrosoft Entra authentication for Application Insights
For information on configuring Entra ID authentication, seeMicrosoft Entra authentication for Application Insights
Microsoft Entra ID authentication isn't available for GraalVM Native applications.
For information on configuring Entra ID authentication, seeMicrosoft Entra authentication for Application Insights
For information on configuring Entra ID authentication, seeMicrosoft Entra authentication for Application Insights
Offline Storage and Automatic Retries
Azure Monitor OpenTelemetry-based offerings cache telemetry when an application disconnects from Application Insights and retries sending for up to 48 hours. For data handling recommendations, seeExport and delete private data. High-load applications occasionally drop telemetry for two reasons: exceeding the allowable time or exceeding the maximum file size. When necessary, the product prioritizes recent events over old ones.
ASP.NET Core
.NET
Java
Java native
Node.js
Python
The Distro package includes the AzureMonitorExporter, which by default uses one of the following locations for offline storage (listed in order of precedence):
Windows%LOCALAPPDATA%\Microsoft\AzureMonitor%TEMP%\Microsoft\AzureMonitor
%LOCALAPPDATA%\Microsoft\AzureMonitor
%TEMP%\Microsoft\AzureMonitor
Non-Windows%TMPDIR%/Microsoft/AzureMonitor/var/tmp/Microsoft/AzureMonitor/tmp/Microsoft/AzureMonitor
%TMPDIR%/Microsoft/AzureMonitor
/var/tmp/Microsoft/AzureMonitor
/tmp/Microsoft/AzureMonitor
To override the default directory, you should setAzureMonitorOptions.StorageDirectory.
AzureMonitorOptions.StorageDirectory
// Create a new ASP.NET Core web application builder.
var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry().UseAzureMonitor(options =>
{
    // Set the Azure Monitor storage directory to "C:\\SomeDirectory".
    // This is the directory where the OpenTelemetry SDK will store any telemetry data that cannot be sent to Azure Monitor immediately.
    options.StorageDirectory = "C:\\SomeDirectory";
});

// Build the ASP.NET Core web application.
var app = builder.Build();

// Start the ASP.NET Core web application.
app.Run();
// Create a new ASP.NET Core web application builder.
var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry().UseAzureMonitor(options =>
{
    // Set the Azure Monitor storage directory to "C:\\SomeDirectory".
    // This is the directory where the OpenTelemetry SDK will store any telemetry data that cannot be sent to Azure Monitor immediately.
    options.StorageDirectory = "C:\\SomeDirectory";
});

// Build the ASP.NET Core web application.
var app = builder.Build();

// Start the ASP.NET Core web application.
app.Run();
To disable this feature, you should setAzureMonitorOptions.DisableOfflineStorage = true.
AzureMonitorOptions.DisableOfflineStorage = true
By default, the AzureMonitorExporter uses one of the following locations for offline storage (listed in order of precedence):
Windows%LOCALAPPDATA%\Microsoft\AzureMonitor%TEMP%\Microsoft\AzureMonitor
%LOCALAPPDATA%\Microsoft\AzureMonitor
%TEMP%\Microsoft\AzureMonitor
Non-Windows%TMPDIR%/Microsoft/AzureMonitor/var/tmp/Microsoft/AzureMonitor/tmp/Microsoft/AzureMonitor
%TMPDIR%/Microsoft/AzureMonitor
/var/tmp/Microsoft/AzureMonitor
/tmp/Microsoft/AzureMonitor
To override the default directory, you should setAzureMonitorExporterOptions.StorageDirectory.
AzureMonitorExporterOptions.StorageDirectory
// Create a new OpenTelemetry tracer provider and set the storage directory.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddAzureMonitorTraceExporter(options =>
    {
        // Set the Azure Monitor storage directory to "C:\\SomeDirectory".
        // This is the directory where the OpenTelemetry SDK will store any trace data that cannot be sent to Azure Monitor immediately.
        options.StorageDirectory = "C:\\SomeDirectory";
        })
        .Build();

// Create a new OpenTelemetry meter provider and set the storage directory.
// It is important to keep the MetricsProvider instance active throughout the process lifetime.
var metricsProvider = Sdk.CreateMeterProviderBuilder()
    .AddAzureMonitorMetricExporter(options =>
    {
        // Set the Azure Monitor storage directory to "C:\\SomeDirectory".
        // This is the directory where the OpenTelemetry SDK will store any metric data that cannot be sent to Azure Monitor immediately.
        options.StorageDirectory = "C:\\SomeDirectory";
        })
        .Build();

// Create a new logger factory and add the OpenTelemetry logger provider with the storage directory.
// It is important to keep the LoggerFactory instance active throughout the process lifetime.
var loggerFactory = LoggerFactory.Create(builder =>
{
    builder.AddOpenTelemetry(logging =>
    {
        logging.AddAzureMonitorLogExporter(options =>
        {
            // Set the Azure Monitor storage directory to "C:\\SomeDirectory".
            // This is the directory where the OpenTelemetry SDK will store any log data that cannot be sent to Azure Monitor immediately.
            options.StorageDirectory = "C:\\SomeDirectory";
        });
    });
});
// Create a new OpenTelemetry tracer provider and set the storage directory.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddAzureMonitorTraceExporter(options =>
    {
        // Set the Azure Monitor storage directory to "C:\\SomeDirectory".
        // This is the directory where the OpenTelemetry SDK will store any trace data that cannot be sent to Azure Monitor immediately.
        options.StorageDirectory = "C:\\SomeDirectory";
        })
        .Build();

// Create a new OpenTelemetry meter provider and set the storage directory.
// It is important to keep the MetricsProvider instance active throughout the process lifetime.
var metricsProvider = Sdk.CreateMeterProviderBuilder()
    .AddAzureMonitorMetricExporter(options =>
    {
        // Set the Azure Monitor storage directory to "C:\\SomeDirectory".
        // This is the directory where the OpenTelemetry SDK will store any metric data that cannot be sent to Azure Monitor immediately.
        options.StorageDirectory = "C:\\SomeDirectory";
        })
        .Build();

// Create a new logger factory and add the OpenTelemetry logger provider with the storage directory.
// It is important to keep the LoggerFactory instance active throughout the process lifetime.
var loggerFactory = LoggerFactory.Create(builder =>
{
    builder.AddOpenTelemetry(logging =>
    {
        logging.AddAzureMonitorLogExporter(options =>
        {
            // Set the Azure Monitor storage directory to "C:\\SomeDirectory".
            // This is the directory where the OpenTelemetry SDK will store any log data that cannot be sent to Azure Monitor immediately.
            options.StorageDirectory = "C:\\SomeDirectory";
        });
    });
});
To disable this feature, you should setAzureMonitorExporterOptions.DisableOfflineStorage = true.
AzureMonitorExporterOptions.DisableOfflineStorage = true
When the agent can't send telemetry to Azure Monitor, it stores telemetry files on disk. The files are saved in atelemetryfolder under the directory specified by thejava.io.tmpdirsystem property. Each file name starts with a timestamp and ends with the.trnextension. This offline storage mechanism helps ensure telemetry is retained during temporary network outages or ingestion failures.
telemetry
java.io.tmpdir
.trn
The agent stores up to 50 MB of telemetry data by default and allowsconfiguration of the storage limit. Attempts to send stored telemetry are made periodically. Telemetry files older than 48 hours are deleted and the oldest events are discarded when the storage limit is reached.
For a full list of available configurations, seeConfiguration options.
When the agent can't send telemetry to Azure Monitor, it stores telemetry files on disk. The files are saved in atelemetryfolder under the directory specified by thejava.io.tmpdirsystem property. Each file name starts with a timestamp and ends with the.trnextension. This offline storage mechanism helps ensure telemetry is retained during temporary network outages or ingestion failures.
telemetry
java.io.tmpdir
.trn
The agent stores up to 50 MB of telemetry data by default. Attempts to send stored telemetry are made periodically. Telemetry files older than 48 hours are deleted and the oldest events are discarded when the storage limit is reached.
By default, the AzureMonitorExporter uses one of the following locations for offline storage.
Windows%TEMP%\Microsoft\AzureMonitor
%TEMP%\Microsoft\AzureMonitor
Non-Windows%TMPDIR%/Microsoft/AzureMonitor/var/tmp/Microsoft/AzureMonitor
%TMPDIR%/Microsoft/AzureMonitor
/var/tmp/Microsoft/AzureMonitor
To override the default directory, you should setstorageDirectory.
storageDirectory
For example:
// Import the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions class from the @azure/monitor-opentelemetry package.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");

// Create a new AzureMonitorOpenTelemetryOptions object and set the azureMonitorExporterOptions property to an object with the following properties:
//
// * connectionString: The connection string for your Azure Monitor Application Insights resource.
// * storageDirectory: The directory where the Azure Monitor OpenTelemetry exporter will store telemetry data when it is offline.
// * disableOfflineStorage: A boolean value that specifies whether to disable offline storage.
const options: AzureMonitorOpenTelemetryOptions = {
  azureMonitorExporterOptions: {
    connectionString: "<Your Connection String>",
    storageDirectory: "C:\\SomeDirectory",
    disableOfflineStorage: false
  }
};

// Enable Azure Monitor integration using the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions object.
useAzureMonitor(options);
// Import the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions class from the @azure/monitor-opentelemetry package.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");

// Create a new AzureMonitorOpenTelemetryOptions object and set the azureMonitorExporterOptions property to an object with the following properties:
//
// * connectionString: The connection string for your Azure Monitor Application Insights resource.
// * storageDirectory: The directory where the Azure Monitor OpenTelemetry exporter will store telemetry data when it is offline.
// * disableOfflineStorage: A boolean value that specifies whether to disable offline storage.
const options: AzureMonitorOpenTelemetryOptions = {
  azureMonitorExporterOptions: {
    connectionString: "<Your Connection String>",
    storageDirectory: "C:\\SomeDirectory",
    disableOfflineStorage: false
  }
};

// Enable Azure Monitor integration using the useAzureMonitor function and the AzureMonitorOpenTelemetryOptions object.
useAzureMonitor(options);
To disable this feature, you should setdisableOfflineStorage = true.
disableOfflineStorage = true
By default, Azure Monitor exporters use the following path:
<tempfile.gettempdir()>/Microsoft/AzureMonitor/opentelemetry-python-<your-instrumentation-key>
<tempfile.gettempdir()>/Microsoft/AzureMonitor/opentelemetry-python-<your-instrumentation-key>
To override the default directory, you should setstorage_directoryto the directory you want.
storage_directory
For example:
...
# Configure OpenTelemetry to use Azure Monitor with the specified connection string and storage directory.
# Replace `your-connection-string` with the connection string to your Azure Monitor Application Insights resource.
# Replace `C:\\SomeDirectory` with the directory where you want to store the telemetry data before it is sent to Azure Monitor.
configure_azure_monitor(
    connection_string="your-connection-string",
    storage_directory="C:\\SomeDirectory",
)
...
...
# Configure OpenTelemetry to use Azure Monitor with the specified connection string and storage directory.
# Replace `your-connection-string` with the connection string to your Azure Monitor Application Insights resource.
# Replace `C:\\SomeDirectory` with the directory where you want to store the telemetry data before it is sent to Azure Monitor.
configure_azure_monitor(
    connection_string="your-connection-string",
    storage_directory="C:\\SomeDirectory",
)
...
To disable this feature, you should setdisable_offline_storagetoTrue. Defaults toFalse.
disable_offline_storage
True
False
For example:
...
# Configure OpenTelemetry to use Azure Monitor with the specified connection string and disable offline storage.
# Replace `your-connection-string` with the connection string to your Azure Monitor Application Insights resource.
configure_azure_monitor(
    connection_string="your-connection-string",
    disable_offline_storage=True,
)
...
...
# Configure OpenTelemetry to use Azure Monitor with the specified connection string and disable offline storage.
# Replace `your-connection-string` with the connection string to your Azure Monitor Application Insights resource.
configure_azure_monitor(
    connection_string="your-connection-string",
    disable_offline_storage=True,
)
...
Enable the OTLP Exporter
You might want to enable the OpenTelemetry Protocol (OTLP) Exporter alongside the Azure Monitor Exporter to send your telemetry to two locations.
Note
The OTLP Exporter is shown for convenience only. We don't officially support the OTLP Exporter or any components or third-party experiences downstream of it.
ASP.NET Core
.NET
Java
Java native
Node.js
Python
Install theOpenTelemetry.Exporter.OpenTelemetryProtocolpackage in your project.dotnet add package OpenTelemetry.Exporter.OpenTelemetryProtocol
Install theOpenTelemetry.Exporter.OpenTelemetryProtocolpackage in your project.
dotnet add package OpenTelemetry.Exporter.OpenTelemetryProtocol
dotnet add package OpenTelemetry.Exporter.OpenTelemetryProtocol
Add the following code snippet. This example assumes you have an OpenTelemetry Collector with an OTLP receiver running. For details, see theexample on GitHub.// Create a new ASP.NET Core web application builder.
var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry().UseAzureMonitor();

// Add the OpenTelemetry OTLP exporter to the application.
// This exporter will send telemetry data to an OTLP receiver, such as Prometheus
builder.Services.AddOpenTelemetry().WithTracing(builder => builder.AddOtlpExporter());
builder.Services.AddOpenTelemetry().WithMetrics(builder => builder.AddOtlpExporter());

// Build the ASP.NET Core web application.
var app = builder.Build();

// Start the ASP.NET Core web application.
app.Run();
Add the following code snippet. This example assumes you have an OpenTelemetry Collector with an OTLP receiver running. For details, see theexample on GitHub.
// Create a new ASP.NET Core web application builder.
var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry().UseAzureMonitor();

// Add the OpenTelemetry OTLP exporter to the application.
// This exporter will send telemetry data to an OTLP receiver, such as Prometheus
builder.Services.AddOpenTelemetry().WithTracing(builder => builder.AddOtlpExporter());
builder.Services.AddOpenTelemetry().WithMetrics(builder => builder.AddOtlpExporter());

// Build the ASP.NET Core web application.
var app = builder.Build();

// Start the ASP.NET Core web application.
app.Run();
// Create a new ASP.NET Core web application builder.
var builder = WebApplication.CreateBuilder(args);

// Add the OpenTelemetry telemetry service to the application.
// This service will collect and send telemetry data to Azure Monitor.
builder.Services.AddOpenTelemetry().UseAzureMonitor();

// Add the OpenTelemetry OTLP exporter to the application.
// This exporter will send telemetry data to an OTLP receiver, such as Prometheus
builder.Services.AddOpenTelemetry().WithTracing(builder => builder.AddOtlpExporter());
builder.Services.AddOpenTelemetry().WithMetrics(builder => builder.AddOtlpExporter());

// Build the ASP.NET Core web application.
var app = builder.Build();

// Start the ASP.NET Core web application.
app.Run();
Install theOpenTelemetry.Exporter.OpenTelemetryProtocolpackage in your project.dotnet add package OpenTelemetry.Exporter.OpenTelemetryProtocol
Install theOpenTelemetry.Exporter.OpenTelemetryProtocolpackage in your project.
dotnet add package OpenTelemetry.Exporter.OpenTelemetryProtocol
dotnet add package OpenTelemetry.Exporter.OpenTelemetryProtocol
Add the following code snippet. This example assumes you have an OpenTelemetry Collector with an OTLP receiver running. For details, see theexample on GitHub.// Create a new OpenTelemetry tracer provider and add the Azure Monitor trace exporter and the OTLP trace exporter.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddAzureMonitorTraceExporter()
    .AddOtlpExporter()
    .Build();

// Create a new OpenTelemetry meter provider and add the Azure Monitor metric exporter and the OTLP metric exporter.
// It is important to keep the MetricsProvider instance active throughout the process lifetime.
var metricsProvider = Sdk.CreateMeterProviderBuilder()
    .AddAzureMonitorMetricExporter()
    .AddOtlpExporter()
    .Build();
Add the following code snippet. This example assumes you have an OpenTelemetry Collector with an OTLP receiver running. For details, see theexample on GitHub.
// Create a new OpenTelemetry tracer provider and add the Azure Monitor trace exporter and the OTLP trace exporter.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddAzureMonitorTraceExporter()
    .AddOtlpExporter()
    .Build();

// Create a new OpenTelemetry meter provider and add the Azure Monitor metric exporter and the OTLP metric exporter.
// It is important to keep the MetricsProvider instance active throughout the process lifetime.
var metricsProvider = Sdk.CreateMeterProviderBuilder()
    .AddAzureMonitorMetricExporter()
    .AddOtlpExporter()
    .Build();
// Create a new OpenTelemetry tracer provider and add the Azure Monitor trace exporter and the OTLP trace exporter.
// It is important to keep the TracerProvider instance active throughout the process lifetime.
var tracerProvider = Sdk.CreateTracerProviderBuilder()
    .AddAzureMonitorTraceExporter()
    .AddOtlpExporter()
    .Build();

// Create a new OpenTelemetry meter provider and add the Azure Monitor metric exporter and the OTLP metric exporter.
// It is important to keep the MetricsProvider instance active throughout the process lifetime.
var metricsProvider = Sdk.CreateMeterProviderBuilder()
    .AddAzureMonitorMetricExporter()
    .AddOtlpExporter()
    .Build();
For more information about Java, see theJava supplemental documentation.
You can't enable the OpenTelemetry Protocol (OTLP) Exporter alongside the Azure Monitor Exporter to send your telemetry to two locations.
Install theOpenTelemetry Collector Trace Exporterand other OpenTelemetry packages in your project.npm install @opentelemetry/api
    npm install @opentelemetry/exporter-trace-otlp-http
    npm install @opentelemetry/sdk-trace-base
    npm install @opentelemetry/sdk-trace-node
Install theOpenTelemetry Collector Trace Exporterand other OpenTelemetry packages in your project.
npm install @opentelemetry/api
    npm install @opentelemetry/exporter-trace-otlp-http
    npm install @opentelemetry/sdk-trace-base
    npm install @opentelemetry/sdk-trace-node
npm install @opentelemetry/api
    npm install @opentelemetry/exporter-trace-otlp-http
    npm install @opentelemetry/sdk-trace-base
    npm install @opentelemetry/sdk-trace-node
Add the following code snippet. This example assumes you have an OpenTelemetry Collector with an OTLP receiver running. For details, see theexample on GitHub.// Import the useAzureMonitor function, the AzureMonitorOpenTelemetryOptions class, the trace module, the ProxyTracerProvider class, the BatchSpanProcessor class, the NodeTracerProvider class, and the OTLPTraceExporter class from the @azure/monitor-opentelemetry, @opentelemetry/api, @opentelemetry/sdk-trace-base, @opentelemetry/sdk-trace-node, and @opentelemetry/exporter-trace-otlp-http packages, respectively.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");
const { BatchSpanProcessor } = require('@opentelemetry/sdk-trace-base');
const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-http');

// Create a new OTLPTraceExporter object.
const otlpExporter = new OTLPTraceExporter();

// Enable Azure Monitor integration.
const options: AzureMonitorOpenTelemetryOptions = {
    // Add the SpanEnrichingProcessor
    spanProcessors: [new BatchSpanProcessor(otlpExporter)] 
}
useAzureMonitor(options);
Add the following code snippet. This example assumes you have an OpenTelemetry Collector with an OTLP receiver running. For details, see theexample on GitHub.
// Import the useAzureMonitor function, the AzureMonitorOpenTelemetryOptions class, the trace module, the ProxyTracerProvider class, the BatchSpanProcessor class, the NodeTracerProvider class, and the OTLPTraceExporter class from the @azure/monitor-opentelemetry, @opentelemetry/api, @opentelemetry/sdk-trace-base, @opentelemetry/sdk-trace-node, and @opentelemetry/exporter-trace-otlp-http packages, respectively.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");
const { BatchSpanProcessor } = require('@opentelemetry/sdk-trace-base');
const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-http');

// Create a new OTLPTraceExporter object.
const otlpExporter = new OTLPTraceExporter();

// Enable Azure Monitor integration.
const options: AzureMonitorOpenTelemetryOptions = {
    // Add the SpanEnrichingProcessor
    spanProcessors: [new BatchSpanProcessor(otlpExporter)] 
}
useAzureMonitor(options);
// Import the useAzureMonitor function, the AzureMonitorOpenTelemetryOptions class, the trace module, the ProxyTracerProvider class, the BatchSpanProcessor class, the NodeTracerProvider class, and the OTLPTraceExporter class from the @azure/monitor-opentelemetry, @opentelemetry/api, @opentelemetry/sdk-trace-base, @opentelemetry/sdk-trace-node, and @opentelemetry/exporter-trace-otlp-http packages, respectively.
const { useAzureMonitor, AzureMonitorOpenTelemetryOptions } = require("@azure/monitor-opentelemetry");
const { BatchSpanProcessor } = require('@opentelemetry/sdk-trace-base');
const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-http');

// Create a new OTLPTraceExporter object.
const otlpExporter = new OTLPTraceExporter();

// Enable Azure Monitor integration.
const options: AzureMonitorOpenTelemetryOptions = {
    // Add the SpanEnrichingProcessor
    spanProcessors: [new BatchSpanProcessor(otlpExporter)] 
}
useAzureMonitor(options);
Install theopentelemetry-exporter-otlppackage.
Install theopentelemetry-exporter-otlppackage.
Add the following code snippet. This example assumes you have an OpenTelemetry Collector with an OTLP receiver running. For details, see thisREADME.# Import the `configure_azure_monitor()`, `trace`, `OTLPSpanExporter`, and `BatchSpanProcessor` classes from the appropriate packages.    
from azure.monitor.opentelemetry import configure_azure_monitor
from opentelemetry import trace
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.trace.export import BatchSpanProcessor

# Configure OpenTelemetry to use Azure Monitor with the specified connection string.
# Replace `<your-connection-string>` with the connection string to your Azure Monitor Application Insights resource.
configure_azure_monitor(
    connection_string="<your-connection-string>",
)

# Get the tracer for the current module.
tracer = trace.get_tracer(__name__) 

# Create an OTLP span exporter that sends spans to the specified endpoint.
# Replace `http://localhost:4317` with the endpoint of your OTLP collector.
otlp_exporter = OTLPSpanExporter(endpoint="http://localhost:4317")

# Create a batch span processor that uses the OTLP span exporter.
span_processor = BatchSpanProcessor(otlp_exporter)

# Add the batch span processor to the tracer provider.
trace.get_tracer_provider().add_span_processor(span_processor)

# Start a new span with the name "test".
with tracer.start_as_current_span("test"):
    print("Hello world!")
Add the following code snippet. This example assumes you have an OpenTelemetry Collector with an OTLP receiver running. For details, see thisREADME.
# Import the `configure_azure_monitor()`, `trace`, `OTLPSpanExporter`, and `BatchSpanProcessor` classes from the appropriate packages.    
from azure.monitor.opentelemetry import configure_azure_monitor
from opentelemetry import trace
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.trace.export import BatchSpanProcessor

# Configure OpenTelemetry to use Azure Monitor with the specified connection string.
# Replace `<your-connection-string>` with the connection string to your Azure Monitor Application Insights resource.
configure_azure_monitor(
    connection_string="<your-connection-string>",
)

# Get the tracer for the current module.
tracer = trace.get_tracer(__name__) 

# Create an OTLP span exporter that sends spans to the specified endpoint.
# Replace `http://localhost:4317` with the endpoint of your OTLP collector.
otlp_exporter = OTLPSpanExporter(endpoint="http://localhost:4317")

# Create a batch span processor that uses the OTLP span exporter.
span_processor = BatchSpanProcessor(otlp_exporter)

# Add the batch span processor to the tracer provider.
trace.get_tracer_provider().add_span_processor(span_processor)

# Start a new span with the name "test".
with tracer.start_as_current_span("test"):
    print("Hello world!")
# Import the `configure_azure_monitor()`, `trace`, `OTLPSpanExporter`, and `BatchSpanProcessor` classes from the appropriate packages.    
from azure.monitor.opentelemetry import configure_azure_monitor
from opentelemetry import trace
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.trace.export import BatchSpanProcessor

# Configure OpenTelemetry to use Azure Monitor with the specified connection string.
# Replace `<your-connection-string>` with the connection string to your Azure Monitor Application Insights resource.
configure_azure_monitor(
    connection_string="<your-connection-string>",
)

# Get the tracer for the current module.
tracer = trace.get_tracer(__name__) 

# Create an OTLP span exporter that sends spans to the specified endpoint.
# Replace `http://localhost:4317` with the endpoint of your OTLP collector.
otlp_exporter = OTLPSpanExporter(endpoint="http://localhost:4317")

# Create a batch span processor that uses the OTLP span exporter.
span_processor = BatchSpanProcessor(otlp_exporter)

# Add the batch span processor to the tracer provider.
trace.get_tracer_provider().add_span_processor(span_processor)

# Start a new span with the name "test".
with tracer.start_as_current_span("test"):
    print("Hello world!")
OpenTelemetry configurations
The following OpenTelemetry configurations can be accessed through environment variables while using the Azure Monitor OpenTelemetry Distros.
ASP.NET Core
.NET
Java
Java native
Node.js
Python
APPLICATIONINSIGHTS_CONNECTION_STRING
APPLICATIONINSIGHTS_STATSBEAT_DISABLED
true
OTEL_RESOURCE_ATTRIBUTES
OTEL_SERVICE_NAME
service.name
service.name
OTEL_RESOURCE_ATTRIBUTES
OTEL_SERVICE_NAME
APPLICATIONINSIGHTS_CONNECTION_STRING
APPLICATIONINSIGHTS_STATSBEAT_DISABLED
true
OTEL_RESOURCE_ATTRIBUTES
OTEL_SERVICE_NAME
service.name
service.name
OTEL_RESOURCE_ATTRIBUTES
OTEL_SERVICE_NAME
For more information about Java, see theJava supplemental documentation.
APPLICATIONINSIGHTS_CONNECTION_STRING
For Spring Boot native applications, theOpenTelemetry Java SDK configurationsare available.
For Quarkus native applications, review theQuarkus OpenTelemetry documentation.
For more information about OpenTelemetry SDK configuration, see theOpenTelemetry documentation.
For more information about OpenTelemetry SDK configuration, see theOpenTelemetry documentationandAzure monitor Distro Usage.
Redact URL Query Strings
To redact URL query strings, turn off query string collection. We recommend this setting if you call Azure storage using a SAS token.
ASP.NET Core
.NET
Java
Java native
Node.js
Python
When you're using theAzure.Monitor.OpenTelemetry.AspNetCoredistro package, both theASP.NET CoreandHttpClientInstrumentation libraries are included.
Our distro package sets Query String Redaction off by default.
To change this behavior, you must set an environment variable to eithertrueorfalse.
true
false
ASP.NET Core Instrumentation:OTEL_DOTNET_EXPERIMENTAL_ASPNETCORE_DISABLE_URL_QUERY_REDACTIONQuery String Redaction is disabled by default. To enable, set this environment variable tofalse.
OTEL_DOTNET_EXPERIMENTAL_ASPNETCORE_DISABLE_URL_QUERY_REDACTION
false
Http Client Instrumentation:OTEL_DOTNET_EXPERIMENTAL_HTTPCLIENT_DISABLE_URL_QUERY_REDACTIONQuery String Redaction is disabled by default. To enable, set this environment variable tofalse.
OTEL_DOTNET_EXPERIMENTAL_HTTPCLIENT_DISABLE_URL_QUERY_REDACTION
false
When using theAzure.Monitor.OpenTelemetry.Exporter, you must manually include either theASP.NET CoreorHttpClientInstrumentation libraries in your OpenTelemetry configuration.
These Instrumentation libraries have QueryString Redaction enabled by default.
To change this behavior, you must set an environment variable to eithertrueorfalse.
true
false
ASP.NET Core Instrumentation:OTEL_DOTNET_EXPERIMENTAL_ASPNETCORE_DISABLE_URL_QUERY_REDACTIONQuery String Redaction is enabled by default. To disable, set this environment variable totrue.
OTEL_DOTNET_EXPERIMENTAL_ASPNETCORE_DISABLE_URL_QUERY_REDACTION
true
Http Client Instrumentation:OTEL_DOTNET_EXPERIMENTAL_HTTPCLIENT_DISABLE_URL_QUERY_REDACTIONQuery String Redaction is enabled by default. To disable, set this environment variable totrue.
OTEL_DOTNET_EXPERIMENTAL_HTTPCLIENT_DISABLE_URL_QUERY_REDACTION
true
Add the following to theapplicationinsights.jsonconfiguration file:
applicationinsights.json
{
  "preview": {
    "processors": [
      {
        "type": "attribute",
        "actions": [
          {
            "key": "url.query",
            "pattern": "^.*$",
            "replace": "REDACTED",
            "action": "mask"
          }
        ]
      },
      {
        "type": "attribute",
        "actions": [
          {
            "key": "url.full",
            "pattern": "[?].*$",
            "replace": "?REDACTED",
            "action": "mask"
          }
        ]
      }
    ]
  }
}
{
  "preview": {
    "processors": [
      {
        "type": "attribute",
        "actions": [
          {
            "key": "url.query",
            "pattern": "^.*$",
            "replace": "REDACTED",
            "action": "mask"
          }
        ]
      },
      {
        "type": "attribute",
        "actions": [
          {
            "key": "url.full",
            "pattern": "[?].*$",
            "replace": "?REDACTED",
            "action": "mask"
          }
        ]
      }
    ]
  }
}
We're actively working in the OpenTelemetry community to support redaction.
When you're using theAzure Monitor OpenTelemetry distropackage, query strings can be redacted via creating and applying a span processor to the distro configuration.
import { useAzureMonitor, AzureMonitorOpenTelemetryOptions } from "@azure/monitor-opentelemetry";
import { Context } from "@opentelemetry/api";
import { ReadableSpan, Span, SpanProcessor } from "@opentelemetry/sdk-trace-base";
import { SEMATTRS_HTTP_ROUTE, SEMATTRS_HTTP_TARGET, SEMATTRS_HTTP_URL } from "@opentelemetry/semantic-conventions";

class RedactQueryStringProcessor implements SpanProcessor {
  forceFlush(): Promise<void> {
	return Promise.resolve();
  }
  onStart(span: Span, parentContext: Context): void {
    return;
  }
  shutdown(): Promise<void> {
	return Promise.resolve();
  }
  onEnd(span: ReadableSpan) {
    const httpRouteIndex: number = String(span.attributes[SEMATTRS_HTTP_ROUTE]).indexOf('?');
    const httpUrlIndex: number = String(span.attributes[SEMATTRS_HTTP_URL]).indexOf('?');
    const httpTargetIndex: number = String(span.attributes[SEMATTRS_HTTP_TARGET]).indexOf('?');
    if (httpRouteIndex !== -1) {
      span.attributes[SEMATTRS_HTTP_ROUTE] = String(span.attributes[SEMATTRS_HTTP_ROUTE]).substring(0, httpRouteIndex);
    }
    if (httpUrlIndex !== -1) {
      span.attributes[SEMATTRS_HTTP_URL] = String(span.attributes[SEMATTRS_HTTP_URL]).substring(0, httpUrlIndex);
    }
    if (httpTargetIndex !== -1) {
      span.attributes[SEMATTRS_HTTP_TARGET] = String(span.attributes[SEMATTRS_HTTP_TARGET]).substring(0, httpTargetIndex);
    }
  }
}

const options: AzureMonitorOpenTelemetryOptions = {
  azureMonitorExporterOptions: {
      connectionString: <YOUR_CONNECTION_STRING>,
  },
  spanProcessors: [new RedactQueryStringProcessor()]
};

useAzureMonitor(options);
import { useAzureMonitor, AzureMonitorOpenTelemetryOptions } from "@azure/monitor-opentelemetry";
import { Context } from "@opentelemetry/api";
import { ReadableSpan, Span, SpanProcessor } from "@opentelemetry/sdk-trace-base";
import { SEMATTRS_HTTP_ROUTE, SEMATTRS_HTTP_TARGET, SEMATTRS_HTTP_URL } from "@opentelemetry/semantic-conventions";

class RedactQueryStringProcessor implements SpanProcessor {
  forceFlush(): Promise<void> {
	return Promise.resolve();
  }
  onStart(span: Span, parentContext: Context): void {
    return;
  }
  shutdown(): Promise<void> {
	return Promise.resolve();
  }
  onEnd(span: ReadableSpan) {
    const httpRouteIndex: number = String(span.attributes[SEMATTRS_HTTP_ROUTE]).indexOf('?');
    const httpUrlIndex: number = String(span.attributes[SEMATTRS_HTTP_URL]).indexOf('?');
    const httpTargetIndex: number = String(span.attributes[SEMATTRS_HTTP_TARGET]).indexOf('?');
    if (httpRouteIndex !== -1) {
      span.attributes[SEMATTRS_HTTP_ROUTE] = String(span.attributes[SEMATTRS_HTTP_ROUTE]).substring(0, httpRouteIndex);
    }
    if (httpUrlIndex !== -1) {
      span.attributes[SEMATTRS_HTTP_URL] = String(span.attributes[SEMATTRS_HTTP_URL]).substring(0, httpUrlIndex);
    }
    if (httpTargetIndex !== -1) {
      span.attributes[SEMATTRS_HTTP_TARGET] = String(span.attributes[SEMATTRS_HTTP_TARGET]).substring(0, httpTargetIndex);
    }
  }
}

const options: AzureMonitorOpenTelemetryOptions = {
  azureMonitorExporterOptions: {
      connectionString: <YOUR_CONNECTION_STRING>,
  },
  spanProcessors: [new RedactQueryStringProcessor()]
};

useAzureMonitor(options);
We're actively working in the OpenTelemetry community to support redaction.
Feedback
Was this page helpful?
Additional resources