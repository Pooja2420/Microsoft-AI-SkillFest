Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Tutorial: Get started with the Azure WebJobs SDK for event-driven background processing
Article
2025-01-17
23 contributors
In this article
Get started with the Azure WebJobs SDK for Azure App Service to enable your web apps to run background tasks, scheduled tasks, and respond to events.
Use Visual Studio 2022 to create a .NET 8 console app that uses the WebJobs SDK to respond to Azure Storage Queue messages, run the project locally, and finally deploy it to Azure.
In this tutorial, you will learn how to:
Create a console app
Add a function
Test locally
Deploy to Azure
Enable Application Insights logging
Add input/output bindings
Prerequisites
Visual Studio 2022 with theAzure developmentworkload.Install Visual Studio 2022.
Visual Studio 2022 with theAzure developmentworkload.Install Visual Studio 2022.
An Azure account with an active subscription.Create an account for free.
An Azure account with an active subscription.Create an account for free.
Create a console app
In this section, you start by creating a project in Visual Studio 2022. Next, you'll add tools for Azure development, code publishing, and functions that listen for triggers and call functions. Last, you'll set up console logging that disables a legacy monitoring tool and enables a console provider with default filtering.
Note
The procedures in this article are verified for creating a C# console app that runs on .NET 8.0.
Create a project
In Visual Studio, selectFile>New>Project.
In Visual Studio, selectFile>New>Project.
UnderCreate a new project, selectConsole Application (C#), and then selectNext.
UnderCreate a new project, selectConsole Application (C#), and then selectNext.
UnderConfigure your new project, name the projectWebJobsSDKSample, and then selectNext.
UnderConfigure your new project, name the projectWebJobsSDKSample, and then selectNext.
Choose yourTarget frameworkand selectCreate. This tutorial has been verified using .NET 6.0.
Choose yourTarget frameworkand selectCreate. This tutorial has been verified using .NET 6.0.
Install WebJobs NuGet packages
Install the latest WebJobs NuGet package. This package includes Microsoft.Azure.WebJobs (WebJobs SDK), which lets you publish your function code to WebJobs in Azure App Service.
Get the latest stable 4.x version of theMicrosoft.Azure.WebJobs.Extensions NuGet package.
Get the latest stable 4.x version of theMicrosoft.Azure.WebJobs.Extensions NuGet package.
In Visual Studio, go toTools>NuGet Package Manager.
In Visual Studio, go toTools>NuGet Package Manager.
SelectPackage Manager Console. You'll see a list of NuGet cmdlets, a link to documentation, and aPM>entry point.
SelectPackage Manager Console. You'll see a list of NuGet cmdlets, a link to documentation, and aPM>entry point.
PM>
In the following command, replace<4_X_VERSION>with the current version number you found in step 1.Install-Package Microsoft.Azure.WebJobs.Extensions -version <4_X_VERSION>NoteThe sample code in this article works with package versions 4.x. Make sure you use a 4.x version because you get build errors when using package versions 5.x.
In the following command, replace<4_X_VERSION>with the current version number you found in step 1.
<4_X_VERSION>
Install-Package Microsoft.Azure.WebJobs.Extensions -version <4_X_VERSION>
Install-Package Microsoft.Azure.WebJobs.Extensions -version <4_X_VERSION>
Note
The sample code in this article works with package versions 4.x. Make sure you use a 4.x version because you get build errors when using package versions 5.x.
In thePackage Manager Console, execute the command. The extension list appears and automatically installs.
In thePackage Manager Console, execute the command. The extension list appears and automatically installs.
Create the Host
The host is the runtime container for functions that listens for triggers and calls functions. The following steps create a host that implementsIHost, which is the Generic Host in ASP.NET Core.
IHost
Select theProgram.cstab, remove the existing contents, and add theseusingstatements:using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
Select theProgram.cstab, remove the existing contents, and add theseusingstatements:
using
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
Also underProgram.cs, add the following code:namespace WebJobsSDKSample
{
    class Program
    {
        static async Task Main()
        {
            var builder = new HostBuilder();
            builder.ConfigureWebJobs(b =>
            {
                b.AddAzureStorageCoreServices();
            });
            var host = builder.Build();
            using (host)
            {
                await host.RunAsync();
            }
        }
    }
}
Also underProgram.cs, add the following code:
namespace WebJobsSDKSample
{
    class Program
    {
        static async Task Main()
        {
            var builder = new HostBuilder();
            builder.ConfigureWebJobs(b =>
            {
                b.AddAzureStorageCoreServices();
            });
            var host = builder.Build();
            using (host)
            {
                await host.RunAsync();
            }
        }
    }
}
namespace WebJobsSDKSample
{
    class Program
    {
        static async Task Main()
        {
            var builder = new HostBuilder();
            builder.ConfigureWebJobs(b =>
            {
                b.AddAzureStorageCoreServices();
            });
            var host = builder.Build();
            using (host)
            {
                await host.RunAsync();
            }
        }
    }
}
In ASP.NET Core, host configurations are set by calling methods on theHostBuilderinstance. For more information, see.NET Generic Host. TheConfigureWebJobsextension method initializes the WebJobs host. InConfigureWebJobs, initialize specific binding extensions, such as the Storage binding extension, and set properties of those extensions.
HostBuilder
ConfigureWebJobs
ConfigureWebJobs
Enable console logging
Set up console logging that uses theASP.NET Core logging framework. This framework, Microsoft.Extensions.Logging, includes an API that works with a variety of built-in and third-party logging providers.
Get the latest stable version of theMicrosoft.Extensions.Logging.ConsoleNuGet package, which includesMicrosoft.Extensions.Logging.
Get the latest stable version of theMicrosoft.Extensions.Logging.ConsoleNuGet package, which includesMicrosoft.Extensions.Logging.
Microsoft.Extensions.Logging.Console
Microsoft.Extensions.Logging
In the following command, replace<9_X_VERSION>with the current version number you found in step 1. Each type of NuGet Package has a unique version number.Install-Package Microsoft.Extensions.Logging.Console -version <9_X_VERSION>
In the following command, replace<9_X_VERSION>with the current version number you found in step 1. Each type of NuGet Package has a unique version number.
<9_X_VERSION>
Install-Package Microsoft.Extensions.Logging.Console -version <9_X_VERSION>
Install-Package Microsoft.Extensions.Logging.Console -version <9_X_VERSION>
In thePackage Manager Console, fill in the current version number and execute the command. The extension list appears and automatically installs.
In thePackage Manager Console, fill in the current version number and execute the command. The extension list appears and automatically installs.
Under the tabProgram.cs, add thisusingstatement:using Microsoft.Extensions.Logging;
Under the tabProgram.cs, add thisusingstatement:
using
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging;
Continuing underProgram.cs, add theConfigureLoggingmethod toHostBuilder, before theBuildcommand. TheAddConsolemethod adds console logging to the configuration.builder.ConfigureLogging((context, b) =>
{
     b.SetMinimumLevel(LogLevel.Error);
     b.AddFilter("Function", LogLevel.Information);
     b.AddFilter("Host", LogLevel.Debug);
     b.AddConsole();
});This adds logging that captures log output for function executions at theInformationlevel, the host at theDebuglevel, and theerrorlevel for all other components. TheMainmethod now looks like this:static async Task Main()
{
    var builder = new HostBuilder();
    builder.ConfigureWebJobs(b =>
    {
        b.AddAzureStorageCoreServices();
    });
    builder.ConfigureLogging((context, b) =>
    {
        b.SetMinimumLevel(LogLevel.Error);
        b.AddFilter("Function", LogLevel.Information);
        b.AddFilter("Host", LogLevel.Debug);
        b.AddConsole();
    });
    var host = builder.Build();
    using (host)
    {
        await host.RunAsync();
    }
}This addition makes these changes:Disablesdashboard logging. The dashboard is a legacy monitoring tool, and dashboard logging is not recommended for high-throughput production scenarios.Adds the console provider with defaultfiltering.
Continuing underProgram.cs, add theConfigureLoggingmethod toHostBuilder, before theBuildcommand. TheAddConsolemethod adds console logging to the configuration.
ConfigureLogging
HostBuilder
Build
AddConsole
builder.ConfigureLogging((context, b) =>
{
     b.SetMinimumLevel(LogLevel.Error);
     b.AddFilter("Function", LogLevel.Information);
     b.AddFilter("Host", LogLevel.Debug);
     b.AddConsole();
});
builder.ConfigureLogging((context, b) =>
{
     b.SetMinimumLevel(LogLevel.Error);
     b.AddFilter("Function", LogLevel.Information);
     b.AddFilter("Host", LogLevel.Debug);
     b.AddConsole();
});
This adds logging that captures log output for function executions at theInformationlevel, the host at theDebuglevel, and theerrorlevel for all other components. TheMainmethod now looks like this:
Information
Debug
error
Main
static async Task Main()
{
    var builder = new HostBuilder();
    builder.ConfigureWebJobs(b =>
    {
        b.AddAzureStorageCoreServices();
    });
    builder.ConfigureLogging((context, b) =>
    {
        b.SetMinimumLevel(LogLevel.Error);
        b.AddFilter("Function", LogLevel.Information);
        b.AddFilter("Host", LogLevel.Debug);
        b.AddConsole();
    });
    var host = builder.Build();
    using (host)
    {
        await host.RunAsync();
    }
}
static async Task Main()
{
    var builder = new HostBuilder();
    builder.ConfigureWebJobs(b =>
    {
        b.AddAzureStorageCoreServices();
    });
    builder.ConfigureLogging((context, b) =>
    {
        b.SetMinimumLevel(LogLevel.Error);
        b.AddFilter("Function", LogLevel.Information);
        b.AddFilter("Host", LogLevel.Debug);
        b.AddConsole();
    });
    var host = builder.Build();
    using (host)
    {
        await host.RunAsync();
    }
}
This addition makes these changes:
Disablesdashboard logging. The dashboard is a legacy monitoring tool, and dashboard logging is not recommended for high-throughput production scenarios.
Adds the console provider with defaultfiltering.
Now, you can add a function that is triggered by messages arriving in an Azure Storage queue.
Add a function
A function is unit of code that runs on a schedule, is triggered based on events, or is run on demand. A trigger listens to a service event. In the context of the WebJobs SDK, triggered doesn't refer to the deployment mode. Event-driven or scheduled WebJobs created using the SDK should always be deployed as continuous WebJobs with "Always on" enabled.
In this section, you create a function triggered by messages in an Azure Storage queue. First, you need to add a binding extension to connect to Azure Storage.
Install the Storage binding extension
Starting with version 3 of the WebJobs SDK, to connect to Azure Storage services you must install a separate Storage binding extension package.
Note
Beginning with 5.x, Microsoft.Azure.WebJobs.Extensions.Storage has beensplit by storage serviceand has migrated theAddAzureStorage()extension method by service type. This version also requires you to update the version of theMicrosoft.Azure.WebJobs.Host.Storageassembly used by the SDK.
AddAzureStorage()
Microsoft.Azure.WebJobs.Host.Storage
Get the latest stable version of theMicrosoft.Azure.WebJobs.Extensions.StorageNuGet package, version 5.x.
Get the latest stable version of theMicrosoft.Azure.WebJobs.Extensions.StorageNuGet package, version 5.x.
In the following command, replace<5_X_VERSION>with the current version  number you found in step 1. Each type of NuGet Package has a unique version number.Install-Package Microsoft.Azure.WebJobs.Extensions.Storage -Version <5_X_VERSION>
In the following command, replace<5_X_VERSION>with the current version  number you found in step 1. Each type of NuGet Package has a unique version number.
<5_X_VERSION>
Install-Package Microsoft.Azure.WebJobs.Extensions.Storage -Version <5_X_VERSION>
Install-Package Microsoft.Azure.WebJobs.Extensions.Storage -Version <5_X_VERSION>
In thePackage Manager Console, execute the command with the current version number at thePM>entry point.
In thePackage Manager Console, execute the command with the current version number at thePM>entry point.
PM>
Also run this command to update theMicrosoft.Azure.WebJobs.Host.Storagepackage to version 4.1.0:Install-Package Microsoft.Azure.WebJobs.Host.Storage -Version 4.1.0
Also run this command to update theMicrosoft.Azure.WebJobs.Host.Storagepackage to version 4.1.0:
Microsoft.Azure.WebJobs.Host.Storage
Install-Package Microsoft.Azure.WebJobs.Host.Storage -Version 4.1.0
Install-Package Microsoft.Azure.WebJobs.Host.Storage -Version 4.1.0
Continuing inProgram.cs, in theConfigureWebJobsextension method, add theAddAzureStorageQueuesmethod on theHostBuilderinstance (before theBuildcommand) to initialize the Storage extension. At this point, theConfigureWebJobsmethod looks like this:builder.ConfigureWebJobs(b =>
{
    b.AddAzureStorageCoreServices();
    b.AddAzureStorageQueues();
});
Continuing inProgram.cs, in theConfigureWebJobsextension method, add theAddAzureStorageQueuesmethod on theHostBuilderinstance (before theBuildcommand) to initialize the Storage extension. At this point, theConfigureWebJobsmethod looks like this:
ConfigureWebJobs
AddAzureStorageQueues
HostBuilder
Build
ConfigureWebJobs
builder.ConfigureWebJobs(b =>
{
    b.AddAzureStorageCoreServices();
    b.AddAzureStorageQueues();
});
builder.ConfigureWebJobs(b =>
{
    b.AddAzureStorageCoreServices();
    b.AddAzureStorageQueues();
});
Add the following code in theMainmethod after thebuilderis instantiated:builder.UseEnvironment(EnvironmentName.Development);Running indevelopment modereduces thequeue polling exponential backoffthat can significantly delay the amount of time it takes for the runtime to find the message and invoke the function. You should remove this line of code or switch toProductionwhen you're done with development and testing.TheMainmethod should now look like the following example:static async Task Main()
{
    var builder = new HostBuilder();
    builder.UseEnvironment(EnvironmentName.Development);
    builder.ConfigureWebJobs(b =>
    {
        b.AddAzureStorageCoreServices();
        b.AddAzureStorageQueues();
    });
    builder.ConfigureLogging((context, b) =>
    {
        b.SetMinimumLevel(LogLevel.Error);
        b.AddFilter("Function", LogLevel.Information);
        b.AddFilter("Host", LogLevel.Debug);
        b.AddConsole();
    });
    var host = builder.Build();
    using (host)
    {
        await host.RunAsync();
    }
}
Add the following code in theMainmethod after thebuilderis instantiated:
Main
builder
builder.UseEnvironment(EnvironmentName.Development);
builder.UseEnvironment(EnvironmentName.Development);
Running indevelopment modereduces thequeue polling exponential backoffthat can significantly delay the amount of time it takes for the runtime to find the message and invoke the function. You should remove this line of code or switch toProductionwhen you're done with development and testing.
Production
TheMainmethod should now look like the following example:
Main
static async Task Main()
{
    var builder = new HostBuilder();
    builder.UseEnvironment(EnvironmentName.Development);
    builder.ConfigureWebJobs(b =>
    {
        b.AddAzureStorageCoreServices();
        b.AddAzureStorageQueues();
    });
    builder.ConfigureLogging((context, b) =>
    {
        b.SetMinimumLevel(LogLevel.Error);
        b.AddFilter("Function", LogLevel.Information);
        b.AddFilter("Host", LogLevel.Debug);
        b.AddConsole();
    });
    var host = builder.Build();
    using (host)
    {
        await host.RunAsync();
    }
}
static async Task Main()
{
    var builder = new HostBuilder();
    builder.UseEnvironment(EnvironmentName.Development);
    builder.ConfigureWebJobs(b =>
    {
        b.AddAzureStorageCoreServices();
        b.AddAzureStorageQueues();
    });
    builder.ConfigureLogging((context, b) =>
    {
        b.SetMinimumLevel(LogLevel.Error);
        b.AddFilter("Function", LogLevel.Information);
        b.AddFilter("Host", LogLevel.Debug);
        b.AddConsole();
    });
    var host = builder.Build();
    using (host)
    {
        await host.RunAsync();
    }
}
Create a queue triggered function
TheQueueTriggerattribute tells the runtime to call this function when a new message is written on an Azure Storage queue calledqueue. The contents of the queue message are provided to the method code in themessageparameter. The body of the method is where you process the trigger data. In this example, the code just logs the message.
QueueTrigger
queue
message
In Solution Explorer, right-click the project, selectAdd>New Item, and then selectClass.
In Solution Explorer, right-click the project, selectAdd>New Item, and then selectClass.
Name the new C# class fileFunctions.csand selectAdd.
Name the new C# class fileFunctions.csand selectAdd.
InFunctions.cs, replace the generated template with the following code:using Microsoft.Azure.WebJobs;
using Microsoft.Extensions.Logging;

namespace WebJobsSDKSample
{
    public static class Functions
    {
        public static void ProcessQueueMessage([QueueTrigger("queue")] string message, ILogger logger)
        {
            logger.LogInformation(message);
        }
    }
}You should mark theFunctionsclass aspublic staticin order for the runtime to access and execute the method. In the above code sample, when a message is added to a queue namedqueue, the function executes and themessagestring is written to the logs. The queue being monitored is in the default Azure Storage account, which you create next.
InFunctions.cs, replace the generated template with the following code:
using Microsoft.Azure.WebJobs;
using Microsoft.Extensions.Logging;

namespace WebJobsSDKSample
{
    public static class Functions
    {
        public static void ProcessQueueMessage([QueueTrigger("queue")] string message, ILogger logger)
        {
            logger.LogInformation(message);
        }
    }
}
using Microsoft.Azure.WebJobs;
using Microsoft.Extensions.Logging;

namespace WebJobsSDKSample
{
    public static class Functions
    {
        public static void ProcessQueueMessage([QueueTrigger("queue")] string message, ILogger logger)
        {
            logger.LogInformation(message);
        }
    }
}
You should mark theFunctionsclass aspublic staticin order for the runtime to access and execute the method. In the above code sample, when a message is added to a queue namedqueue, the function executes and themessagestring is written to the logs. The queue being monitored is in the default Azure Storage account, which you create next.
public static
queue
message
Themessageparameter doesn't have to be a string. You can also bind to a JSON object, a byte array, or aCloudQueueMessageobject.See Queue trigger usage. Each binding type (such as queues, blobs, or tables) has a different set of parameter types that you can bind to.
message
Create an Azure storage account
The Azure Storage Emulator that runs locally doesn't have all of the features that the WebJobs SDK needs. You'll create a storage account in Azure and configure the project to use it.
To learn how to create a general-purpose v2 storage account, seeCreate an Azure Storage account.
Locate and copy your connection string
A connection string is required to configure storage. Keep this connection string for the next steps.
In theAzure portal, navigate to your storage account and selectSettings.
In theAzure portal, navigate to your storage account and selectSettings.
InSettings, selectAccess keys.
InSettings, selectAccess keys.
For theConnection stringunderkey1, select theCopy to clipboardicon.
For theConnection stringunderkey1, select theCopy to clipboardicon.

Configure storage to run locally
The WebJobs SDK looks for the storage connection string in the Application Settings in Azure. When you run locally, it looks for this value in the local configuration file or in environment variables.
Right-click the project, selectAdd>New Item, selectJavaScript JSON configuration file, name the new fileappsettings.jsonfile, and selectAdd.
Right-click the project, selectAdd>New Item, selectJavaScript JSON configuration file, name the new fileappsettings.jsonfile, and selectAdd.
In the new file, add aAzureWebJobsStoragefield, as in the following example:{
    "AzureWebJobsStorage": "{storage connection string}"
}
In the new file, add aAzureWebJobsStoragefield, as in the following example:
AzureWebJobsStorage
{
    "AzureWebJobsStorage": "{storage connection string}"
}
{
    "AzureWebJobsStorage": "{storage connection string}"
}
Replace{storage connection string}with the connection string that you copied previously.
Replace{storage connection string}with the connection string that you copied previously.
Select theappsettings.jsonfile in Solution Explorer and in thePropertieswindow, set theCopy to Output Directoryaction toCopy if newer.
Select theappsettings.jsonfile in Solution Explorer and in thePropertieswindow, set theCopy to Output Directoryaction toCopy if newer.
Because this file contains a connection string secret, you shouldn't store the file in a remote code repository. After publishing your project to Azure, you can add the same connection string app setting in your app in Azure App Service.
Test locally
Build and run the project locally and create a message queue to trigger the function.
In the Azure portal, navigate to your storage account and select theQueuestab (1). Select+ Queue(2) and enterqueueas the Queue name (3). Then, selectOK(4).
In the Azure portal, navigate to your storage account and select theQueuestab (1). Select+ Queue(2) and enterqueueas the Queue name (3). Then, selectOK(4).

Click the new queue and selectAdd message.
Click the new queue and selectAdd message.
In theAdd Messagedialog, enterHello World!as theMessage text, and then selectOK. There is now a message in the queue.
In theAdd Messagedialog, enterHello World!as theMessage text, and then selectOK. There is now a message in the queue.

PressCtrl+F5to run the project.The console shows that the runtime found your function. Because you used theQueueTriggerattribute in theProcessQueueMessagefunction, the WebJobs runtime listens for messages in the queue namedqueue. When it finds a new message in this queue, the runtime calls the function, passing in the message string value.
PressCtrl+F5to run the project.
The console shows that the runtime found your function. Because you used theQueueTriggerattribute in theProcessQueueMessagefunction, the WebJobs runtime listens for messages in the queue namedqueue. When it finds a new message in this queue, the runtime calls the function, passing in the message string value.
QueueTrigger
ProcessQueueMessage
queue
Go back to theQueuewindow and refresh it. The message is gone, since it has been processed by your function running locally.
Go back to theQueuewindow and refresh it. The message is gone, since it has been processed by your function running locally.
Close the console window or type Ctrl+C.
Close the console window or type Ctrl+C.
It's now time to publish your WebJobs SDK project to Azure.
Deploy to Azure
During deployment, you create an app service instance where you'll run your functions. When you publish a .NET console app to App Service in Azure, it automatically runs as a WebJob. To learn more about publishing, seeDevelop and deploy WebJobs using Visual Studio.
Create Azure resources
InSolution Explorer, right-click the project and selectPublish.
InSolution Explorer, right-click the project and selectPublish.
In thePublishdialog box, selectAzureforTarget, and then selectNext.
In thePublishdialog box, selectAzureforTarget, and then selectNext.
SelectAzure WebJobsforSpecific target, and then selectNext.
SelectAzure WebJobsforSpecific target, and then selectNext.
AboveApp Service instancesselect the plus (+) button toCreate a new Azure WebJob.
AboveApp Service instancesselect the plus (+) button toCreate a new Azure WebJob.
In theApp Service (Windows)dialog box, use the hosting settings in the following table.SettingSuggested valueDescriptionNameGlobally unique nameName that uniquely identifies your new function app.SubscriptionChoose your subscriptionThe Azure subscription to use.Resource groupmyResourceGroupName of the resource group in which to create your function app. ChooseNewto create a new resource group.Hosting PlanApp Service planAnApp Service planspecifies the location, size, and features of the web server farm that hosts your app. You can save money when hosting multiple apps by configuring the web apps to share a single App Service plan. App Service plans define the region, instance size, scale count, and SKU (Free, Shared, Basic, Standard, or Premium). ChooseNewto create a new App Service plan. Free and Basic tiers don't support the Always On option to keep your site running continuously.
In theApp Service (Windows)dialog box, use the hosting settings in the following table.

SelectCreateto create a WebJob and related resources in Azure with these settings and deploy your project code.
SelectCreateto create a WebJob and related resources in Azure with these settings and deploy your project code.
SelectFinishto return to thePublishpage.
SelectFinishto return to thePublishpage.
Enable Always On
For a continuous WebJob, you should enable the Always on setting in the site so that your WebJobs run correctly. If you don't enable Always on, the runtime goes idle after a few minutes of inactivity.
In thePublishpage, select the three dots aboveHostingto showHosting profile section actionsand chooseOpen in Azure portal.
In thePublishpage, select the three dots aboveHostingto showHosting profile section actionsand chooseOpen in Azure portal.
UnderSettings, chooseConfiguration>General settings, setAlways ontoOn, and then selectSaveandContinueto restart the site.
UnderSettings, chooseConfiguration>General settings, setAlways ontoOn, and then selectSaveandContinueto restart the site.
Publish the project
With the web app created in Azure, it's time to publish the WebJobs project.
In thePublishpage underHosting, select the edit button and change theWebJob TypetoContinuousand selectSave. This makes sure that the WebJob is running when messages are added to the queue. Triggered WebJobs are typically used only for manual webhooks.
In thePublishpage underHosting, select the edit button and change theWebJob TypetoContinuousand selectSave. This makes sure that the WebJob is running when messages are added to the queue. Triggered WebJobs are typically used only for manual webhooks.
Continuous

Select thePublishbutton at the top right corner of thePublishpage. When the operation completes, your WebJob is running on Azure.
Select thePublishbutton at the top right corner of thePublishpage. When the operation completes, your WebJob is running on Azure.
Create a storage connection app setting
You need to create the same storage connection string setting in Azure that you used locally in your appsettings.json config file. This lets you more securely store the connection string and
In yourPublishprofile page, select the three dots aboveHostingto showHosting profile section actionsand chooseManage Azure App Service settings.
In yourPublishprofile page, select the three dots aboveHostingto showHosting profile section actionsand chooseManage Azure App Service settings.
InApplication settings, choose+ Add setting.
InApplication settings, choose+ Add setting.
InNew app setting name, typeAzureWebJobsStorageand selectOK.
InNew app setting name, typeAzureWebJobsStorageand selectOK.
AzureWebJobsStorage
InRemote, paste in the connection string from your local setting and selectOK.
InRemote, paste in the connection string from your local setting and selectOK.
The connection string is now set in your app in Azure.
Trigger the function in Azure
Make sure you're not running locally. Close the console window if it's still open. Otherwise, the local instance might be the first to process any queue messages you create.
Make sure you're not running locally. Close the console window if it's still open. Otherwise, the local instance might be the first to process any queue messages you create.
In theQueuepage in Visual Studio, add a message to the queue as before.
In theQueuepage in Visual Studio, add a message to the queue as before.
Refresh theQueuepage, and the new message disappears because it has been processed by the function running in Azure.
Refresh theQueuepage, and the new message disappears because it has been processed by the function running in Azure.
Enable Application Insights logging
When the WebJob runs in Azure, you can't monitor function execution by viewing console output. To be able to monitor your WebJob, you should create an associatedApplication Insightsinstance when you publish your project.
Create an Application Insights instance
In yourPublishprofile page, select the three dots aboveHostingto showHosting profile section actionsand chooseOpen in Azure Portal.
In yourPublishprofile page, select the three dots aboveHostingto showHosting profile section actionsand chooseOpen in Azure Portal.
In the web app underMonitoring, chooseApplication Insights, and selectTurn on Application Insights.
In the web app underMonitoring, chooseApplication Insights, and selectTurn on Application Insights.
Verify the generatedResource namefor the instance and theLocation, and selectApplyand thenYes.
Verify the generatedResource namefor the instance and theLocation, and selectApplyand thenYes.
UnderSettings, chooseEnvironment variablesand verify that a newAPPINSIGHTS_INSTRUMENTATIONKEYwas created. This key is used to connect your WebJob instance to Application Insights.
UnderSettings, chooseEnvironment variablesand verify that a newAPPINSIGHTS_INSTRUMENTATIONKEYwas created. This key is used to connect your WebJob instance to Application Insights.
APPINSIGHTS_INSTRUMENTATIONKEY
To take advantage ofApplication Insightslogging, you need to update your logging code as well.
Install the Application Insights extension
Get the latest stable version of theMicrosoft.Azure.WebJobs.Logging.ApplicationInsightsNuGet package, version 3.x.
Get the latest stable version of theMicrosoft.Azure.WebJobs.Logging.ApplicationInsightsNuGet package, version 3.x.
In the following command, replace<3_X_VERSION>with the current version  number you found in step 1. Each type of NuGet Package has a unique version number.Install-Package Microsoft.Azure.WebJobs.Logging.ApplicationInsights -Version <3_X_VERSION>
In the following command, replace<3_X_VERSION>with the current version  number you found in step 1. Each type of NuGet Package has a unique version number.
<3_X_VERSION>
Install-Package Microsoft.Azure.WebJobs.Logging.ApplicationInsights -Version <3_X_VERSION>
Install-Package Microsoft.Azure.WebJobs.Logging.ApplicationInsights -Version <3_X_VERSION>
In thePackage Manager Console, execute the command with the current version number at thePM>entry point.
In thePackage Manager Console, execute the command with the current version number at thePM>entry point.
PM>
Initialize the Application Insights logging provider
OpenProgram.csand add the following initializer in theConfigureLoggingafter the call toAddConsole:
ConfigureLogging
AddConsole
// If the key exists in settings, use it to enable Application Insights.
string instrumentationKey = context.Configuration["APPINSIGHTS_INSTRUMENTATIONKEY"];
if (!string.IsNullOrEmpty(instrumentationKey))
{
    b.AddApplicationInsightsWebJobs(o => o.InstrumentationKey = instrumentationKey);
}
// If the key exists in settings, use it to enable Application Insights.
string instrumentationKey = context.Configuration["APPINSIGHTS_INSTRUMENTATIONKEY"];
if (!string.IsNullOrEmpty(instrumentationKey))
{
    b.AddApplicationInsightsWebJobs(o => o.InstrumentationKey = instrumentationKey);
}
TheMainmethod code should now look like the following example:
Main
static async Task Main()
{
    var builder = new HostBuilder();
    //builder.UseEnvironment(EnvironmentName.Development);
    builder.ConfigureWebJobs(b =>
    {
        b.AddAzureStorageCoreServices();
        b.AddAzureStorageQueues();
    });
    builder.ConfigureLogging((context, b) =>
    {
        b.SetMinimumLevel(LogLevel.Error);
        b.AddFilter("Function", LogLevel.Information);
        b.AddFilter("Host", LogLevel.Debug);
        b.AddConsole();

        // If the key exists in settings, use it to enable Application Insights.
        string? instrumentationKey = context.Configuration["APPINSIGHTS_INSTRUMENTATIONKEY"];
        if (!string.IsNullOrEmpty(instrumentationKey))
        {
            b.AddApplicationInsightsWebJobs(o => o.InstrumentationKey = instrumentationKey);
        }
    });
    var host = builder.Build();
    using (host)
    {
        await host.RunAsync();
    }
}
static async Task Main()
{
    var builder = new HostBuilder();
    //builder.UseEnvironment(EnvironmentName.Development);
    builder.ConfigureWebJobs(b =>
    {
        b.AddAzureStorageCoreServices();
        b.AddAzureStorageQueues();
    });
    builder.ConfigureLogging((context, b) =>
    {
        b.SetMinimumLevel(LogLevel.Error);
        b.AddFilter("Function", LogLevel.Information);
        b.AddFilter("Host", LogLevel.Debug);
        b.AddConsole();

        // If the key exists in settings, use it to enable Application Insights.
        string? instrumentationKey = context.Configuration["APPINSIGHTS_INSTRUMENTATIONKEY"];
        if (!string.IsNullOrEmpty(instrumentationKey))
        {
            b.AddApplicationInsightsWebJobs(o => o.InstrumentationKey = instrumentationKey);
        }
    });
    var host = builder.Build();
    using (host)
    {
        await host.RunAsync();
    }
}
This initializes the Application Insights logging provider with defaultfiltering. When running locally, all Information and higher-level logs are written to both the console and Application Insights. When running locally, Application Insights logging is only supported after you also add theAPPINSIGHTS_INSTRUMENTATIONKEYto theappsetting.jsonfile in the project.
APPINSIGHTS_INSTRUMENTATIONKEY
appsetting.json
Republish the project and trigger the function again
InSolution Explorer, right-click the project and selectPublish.
InSolution Explorer, right-click the project and selectPublish.
As before, use the Azure portal to create a queue message like you didearlier, except enterHello App Insights!as the message text.
As before, use the Azure portal to create a queue message like you didearlier, except enterHello App Insights!as the message text.
In yourPublishprofile page, select the three dots aboveHostingto showHosting profile section actionsand chooseOpen in Azure Portal.
In yourPublishprofile page, select the three dots aboveHostingto showHosting profile section actionsand chooseOpen in Azure Portal.
In the web app underSettings>Monitor, chooseApplication Insights, and selectView Application Insights data.
In the web app underSettings>Monitor, chooseApplication Insights, and selectView Application Insights data.
SelectSearchand then selectSee all data in the last 24 hours.
SelectSearchand then selectSee all data in the last 24 hours.

If you don't see theHello App Insights!message, selectRefreshperiodically for several minutes. Logs don't appear immediately, because it takes a while for the Application Insights client to flush the logs it processes.
If you don't see theHello App Insights!message, selectRefreshperiodically for several minutes. Logs don't appear immediately, because it takes a while for the Application Insights client to flush the logs it processes.

Add input/output bindings
Bindings simplify code that reads and writes data. Input bindings simplify code that reads data. Output bindings simplify code that writes data.
Add bindings
Input bindings simplify code that reads data. For this example, the queue message is the name of a blob, which you'll use to find and read a blob in Azure Storage. You will then use output bindings to write a copy of the file to the same container.
InFunctions.cs, add ausing:using System.IO;
InFunctions.cs, add ausing:
using
using System.IO;
using System.IO;
Replace theProcessQueueMessagemethod with the following code:public static void ProcessQueueMessage(
    [QueueTrigger("queue")] string message,
    [Blob("container/{queueTrigger}", FileAccess.Read)] Stream myBlob,
    [Blob("container/copy-{queueTrigger}", FileAccess.Write)] Stream outputBlob,
    ILogger logger)
{
    logger.LogInformation($"Blob name:{message} \n Size: {myBlob.Length} bytes");
    myBlob.CopyTo(outputBlob);
}In this code,queueTriggeris abinding expression, which means it resolves to a different value at runtime.  At runtime, it has the contents of the queue message.This code uses output bindings to create a copy of the file identified by the queue message. The file copy is prefixed withcopy-.
Replace theProcessQueueMessagemethod with the following code:
ProcessQueueMessage
public static void ProcessQueueMessage(
    [QueueTrigger("queue")] string message,
    [Blob("container/{queueTrigger}", FileAccess.Read)] Stream myBlob,
    [Blob("container/copy-{queueTrigger}", FileAccess.Write)] Stream outputBlob,
    ILogger logger)
{
    logger.LogInformation($"Blob name:{message} \n Size: {myBlob.Length} bytes");
    myBlob.CopyTo(outputBlob);
}
public static void ProcessQueueMessage(
    [QueueTrigger("queue")] string message,
    [Blob("container/{queueTrigger}", FileAccess.Read)] Stream myBlob,
    [Blob("container/copy-{queueTrigger}", FileAccess.Write)] Stream outputBlob,
    ILogger logger)
{
    logger.LogInformation($"Blob name:{message} \n Size: {myBlob.Length} bytes");
    myBlob.CopyTo(outputBlob);
}
In this code,queueTriggeris abinding expression, which means it resolves to a different value at runtime.  At runtime, it has the contents of the queue message.
queueTrigger
This code uses output bindings to create a copy of the file identified by the queue message. The file copy is prefixed withcopy-.
InProgram.cs, in theConfigureWebJobsextension method, add theAddAzureStorageBlobsmethod on theHostBuilderinstance (before theBuildcommand) to initialize the Storage extension. At this point, theConfigureWebJobsmethod looks like this:builder.ConfigureWebJobs(b =>
{
    b.AddAzureStorageCoreServices();
    b.AddAzureStorageQueues();
    b.AddAzureStorageBlobs();
});
InProgram.cs, in theConfigureWebJobsextension method, add theAddAzureStorageBlobsmethod on theHostBuilderinstance (before theBuildcommand) to initialize the Storage extension. At this point, theConfigureWebJobsmethod looks like this:
ConfigureWebJobs
AddAzureStorageBlobs
HostBuilder
Build
ConfigureWebJobs
builder.ConfigureWebJobs(b =>
{
    b.AddAzureStorageCoreServices();
    b.AddAzureStorageQueues();
    b.AddAzureStorageBlobs();
});
builder.ConfigureWebJobs(b =>
{
    b.AddAzureStorageCoreServices();
    b.AddAzureStorageQueues();
    b.AddAzureStorageBlobs();
});
Create a blob container in your storage account.a. In the Azure portal, navigate to theContainerstab belowData storageand select+ Containerb. In theNew containerdialog, entercontaineras the container name, and then selectCreate.
Create a blob container in your storage account.
a. In the Azure portal, navigate to theContainerstab belowData storageand select+ Container
b. In theNew containerdialog, entercontaineras the container name, and then selectCreate.
Upload theProgram.csfile to the blob container. (This file is used here as an example; you could upload any text file and create a queue message with the file's name.)a. Select the new container you createdb. Select theUploadbutton.c. Find and selectProgram.cs, and then selectOK.
Upload theProgram.csfile to the blob container. (This file is used here as an example; you could upload any text file and create a queue message with the file's name.)
a. Select the new container you created
b. Select theUploadbutton.

c. Find and selectProgram.cs, and then selectOK.
Republish the project
InSolution Explorer, right-click the project and selectPublish.
InSolution Explorer, right-click the project and selectPublish.
In thePublishdialog, make sure that the current profile is selected and then selectPublish. Results of the publish are detailed in theOutputwindow.
In thePublishdialog, make sure that the current profile is selected and then selectPublish. Results of the publish are detailed in theOutputwindow.
Create a queue message in the queue you created earlier, withProgram.csas the text of the message.
Create a queue message in the queue you created earlier, withProgram.csas the text of the message.

A copy of the file,copy-Program.cs, will appear in the blob container.
A copy of the file,copy-Program.cs, will appear in the blob container.
Next steps
This tutorial showed you how to create, run, and deploy a WebJobs SDK 3.x project.
Learn more about the WebJobs SDK
Feedback
Was this page helpful?
Additional resources