Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Quickstart: Send events to and receive events from Azure Event Hubs using .NET
Article
2025-03-25
27 contributors
In this article
In this quickstart, you learn how to send events to an event hub and then receive those events from the event hub using theAzure.Messaging.EventHubs.NET library.
Note
Quickstarts are for you to quickly ramp up on the service. If you're already familiar with the service, you might want to see .NET samples for Event Hubs in our .NET SDK repository on GitHub:Event Hubs samples on GitHub,Event processor samples on GitHub.
Prerequisites
If you're new to Azure Event Hubs, seeEvent Hubs overviewbefore you go through this quickstart.
To complete this quickstart, you need the following prerequisites:
Microsoft Azure subscription. To use Azure services, including Azure Event Hubs, you need a subscription. If you don't have an existing Azure account, you can sign up for afree trial.
Microsoft Visual Studio 2022. The Azure Event Hubs client library makes use of new features that were introduced in C# 8.0. You can still use the library with  previous C# language versions, but the new syntax isn't available. To make use of the full syntax, we recommend that you compile with the.NET Core SDK3.0 or higher andlanguage versionset tolatest. If you're using Visual Studio, versions before Visual Studio 2022 aren't compatible with the tools needed to build C# 8.0 projects. Visual Studio 2022, including the free Community edition, can be downloadedhere.
latest
Create an Event Hubs namespace and an event hub. The first step is to use the Azure portal to create an Event Hubs namespace and an event hub in the namespace. Then, obtain the management credentials that your application needs to communicate with the event hub. To create a namespace and an event hub, seeQuickstart: Create an event hub using Azure portal.
Authenticate the app to Azure
This quick start shows you two ways of connecting to Azure Event Hubs:
Passwordless (Microsoft Entra authentication)
Connection string
The first option shows you how to use your security principal in AzureMicrosoft Entra ID and role-based access control (RBAC)to connect to an Event Hubs namespace. You don't need to worry about having hard-coded connection strings in your code or in a configuration file or in a secure storage like Azure Key Vault.
The second option shows you how to use aconnection stringto connect to an Event Hubs namespace. If you're new to Azure, you may find the connection string option easier to follow. We recommend using the passwordless option in real-world applications and production environments. For more information, seeAuthentication and authorization. You can also read more about passwordless authentication on theoverview page.
Passwordless
Connection String

Assign roles to your Microsoft Entra user
When developing locally, make sure that the user account that connects to Azure Event Hubs has the correct permissions. You'll need theAzure Event Hubs Data Ownerrole in order to send and receive messages. To assign yourself this role, you'll need the User Access Administrator role, or another role that includes theMicrosoft.Authorization/roleAssignments/writeaction. You can assign Azure RBAC roles to a user using the Azure portal, Azure CLI, or Azure PowerShell. Learn more about the available scopes for role assignments on thescope overviewpage.
Microsoft.Authorization/roleAssignments/write
The following example assigns theAzure Event Hubs Data Ownerrole to your user account, which provides full access to Azure Event Hubs resources. In a real scenario, follow thePrinciple of Least Privilegeto give users only the minimum permissions needed for a more secure production environment.
Azure Event Hubs Data Owner
Azure built-in roles for Azure Event Hubs
For Azure Event Hubs, the management of namespaces and all related resources through the Azure portal and the Azure resource management API is already protected using the Azure RBAC model. Azure provides the below Azure built-in roles for authorizing access to an Event Hubs namespace:
Azure Event Hubs Data Owner: Enables data access to Event Hubs namespace and its entities (queues, topics, subscriptions, and filters)
Azure Event Hubs Data Sender: Use this role to give the sender access to Event Hubs namespace and its entities.
Azure Event Hubs Data Receiver: Use this role to give the receiver access to Event Hubs namespace and its entities.
If you want to create a custom role, seeRights required for Event Hubs operations.
Important
In most cases, it will take a minute or two for the role assignment to propagate in Azure. In rare cases, it may take up to eight minutes. If you receive authentication errors when you first run your code, wait a few moments and try again.
Azure portal
Azure CLI
PowerShell
In the Azure portal, locate your Event Hubs namespace using the main search bar or left navigation.
In the Azure portal, locate your Event Hubs namespace using the main search bar or left navigation.
On the overview page, selectAccess control (IAM)from the left-hand menu.
On the overview page, selectAccess control (IAM)from the left-hand menu.
On theAccess control (IAM)page, select theRole assignmentstab.
On theAccess control (IAM)page, select theRole assignmentstab.
Select+ Addfrom the top menu and thenAdd role assignmentfrom the resulting drop-down menu.
Select+ Addfrom the top menu and thenAdd role assignmentfrom the resulting drop-down menu.

Use the search box to filter the results to the desired role. For this example, search forAzure Event Hubs Data Ownerand select the matching result. Then chooseNext.
Use the search box to filter the results to the desired role. For this example, search forAzure Event Hubs Data Ownerand select the matching result. Then chooseNext.
Azure Event Hubs Data Owner
UnderAssign access to, selectUser, group, or service principal, and then choose+ Select members.
UnderAssign access to, selectUser, group, or service principal, and then choose+ Select members.
In the dialog, search for your Microsoft Entra username (usually youruser@domainemail address) and then chooseSelectat the bottom of the dialog.
In the dialog, search for your Microsoft Entra username (usually youruser@domainemail address) and then chooseSelectat the bottom of the dialog.
SelectReview + assignto go to the final page, and thenReview + assignagain to complete the process.
SelectReview + assignto go to the final page, and thenReview + assignagain to complete the process.
To assign a role at the resource level using the Azure CLI, you first must retrieve the resource ID using theaz eventhubs namespace showcommand. You can filter the output properties using the--queryparameter.
az eventhubs namespace show
--query
az eventhubs namespace show -g '<your-event-hub-resource-group>' -n '<your-event-hub-name> --query id
az eventhubs namespace show -g '<your-event-hub-resource-group>' -n '<your-event-hub-name> --query id
Copy the outputIdfrom the preceding command. You can then assign roles using theaz rolecommand of the Azure CLI.
Id
az role assignment create --assignee "<user@domain>" \
--role "Azure Event Hubs Data Owner" \
--scope "<your-resource-id>"
az role assignment create --assignee "<user@domain>" \
--role "Azure Event Hubs Data Owner" \
--scope "<your-resource-id>"
To assign a role at the resource level using Azure PowerShell, you first must retrieve the resource ID using theGet-AzResourcecommand.
Get-AzResource
Get-AzResource -ResourceGroupName "<your-event-hub-resource-group>" -Name "<your-event-hub-name>"
Get-AzResource -ResourceGroupName "<your-event-hub-resource-group>" -Name "<your-event-hub-name>"
Copy theIdvalue from the preceding command output. You can then assign roles using theNew-AzRoleAssignmentcommand in PowerShell.
Id
New-AzRoleAssignment -SignInName <user@domain> `
-RoleDefinitionName "Azure Event Hubs Data Owner" `
-Scope <yourResourceId>
New-AzRoleAssignment -SignInName <user@domain> `
-RoleDefinitionName "Azure Event Hubs Data Owner" `
-Scope <yourResourceId>
Launch Visual Studio and sign-in to Azure
You can authorize access to the service bus namespace using the following steps:
Launch Visual Studio. If you see theGet startedwindow, select theContinue without codelink in the right pane.
Launch Visual Studio. If you see theGet startedwindow, select theContinue without codelink in the right pane.
Select theSign inbutton in the top right of Visual Studio.
Select theSign inbutton in the top right of Visual Studio.

Sign-in using the Microsoft Entra account you assigned a role to previously.
Sign-in using the Microsoft Entra account you assigned a role to previously.

Get the connection string
Creating a new namespace automatically generates an initial Shared Access Signature (SAS) policy with primary and secondary keys and connection strings that each grant full control over all aspects of the namespace. SeeEvent Hubs authentication and authorizationfor information about how to create rules with more constrained rights for regular senders and receivers.
A client can use the connection string to connect to the Event Hubs namespace. To copy the primary connection string for your namespace, follow these steps:
On theEvent Hub Namespacepage, selectShared access policieson the left menu.
On theEvent Hub Namespacepage, selectShared access policieson the left menu.
On theShared access policiespage, selectRootManageSharedAccessKey.
On theShared access policiespage, selectRootManageSharedAccessKey.
In thePolicy: RootManageSharedAccessKeywindow, select the copy button next toPrimary Connection String, to copy the connection string to your clipboard for later use. Paste this value into Notepad or some other temporary location.You can use this page to copy primary key, secondary key, primary connection string, and secondary connection string.
In thePolicy: RootManageSharedAccessKeywindow, select the copy button next toPrimary Connection String, to copy the connection string to your clipboard for later use. Paste this value into Notepad or some other temporary location.

You can use this page to copy primary key, secondary key, primary connection string, and secondary connection string.
Send events to the event hub
This section shows you how to create a .NET Core console application to send events to the event hub you created.
Create a console application
If you have Visual Studio 2022 open already, selectFileon the menu, selectNew, and then selectProject. Otherwise, launch Visual Studio 2022 and selectCreate a new projectif you see a popup window.
If you have Visual Studio 2022 open already, selectFileon the menu, selectNew, and then selectProject. Otherwise, launch Visual Studio 2022 and selectCreate a new projectif you see a popup window.
On theCreate a new projectdialog box, do the following steps: If you don't see this dialog box, selectFileon the menu, selectNew, and then selectProject.SelectC#for the programming language.SelectConsolefor the type of the application.SelectConsole Applicationfrom the results list.Then, selectNext.
On theCreate a new projectdialog box, do the following steps: If you don't see this dialog box, selectFileon the menu, selectNew, and then selectProject.
SelectC#for the programming language.
SelectC#for the programming language.
SelectConsolefor the type of the application.
SelectConsolefor the type of the application.
SelectConsole Applicationfrom the results list.
SelectConsole Applicationfrom the results list.
Then, selectNext.
Then, selectNext.

EnterEventHubsSenderfor the project name,EventHubsQuickStartfor the solution name, and then selectNext.
EnterEventHubsSenderfor the project name,EventHubsQuickStartfor the solution name, and then selectNext.

On theAdditional informationpage, selectCreate.
On theAdditional informationpage, selectCreate.
Add the NuGet packages to the project
Passwordless (Recommended)
Connection String
SelectTools>NuGet Package Manager>Package Manager Consolefrom the menu.
SelectTools>NuGet Package Manager>Package Manager Consolefrom the menu.
Run the following commands to installAzure.Messaging.EventHubsandAzure.IdentityNuGet packages. PressENTERto run the second command.Install-Package Azure.Messaging.EventHubs
Install-Package Azure.Identity
Run the following commands to installAzure.Messaging.EventHubsandAzure.IdentityNuGet packages. PressENTERto run the second command.
Install-Package Azure.Messaging.EventHubs
Install-Package Azure.Identity
Install-Package Azure.Messaging.EventHubs
Install-Package Azure.Identity
SelectTools>NuGet Package Manager>Package Manager Consolefrom the menu.
SelectTools>NuGet Package Manager>Package Manager Consolefrom the menu.
Run the following command to install theAzure.Messaging.EventHubsNuGet package:Install-Package Azure.Messaging.EventHubs
Run the following command to install theAzure.Messaging.EventHubsNuGet package:
Install-Package Azure.Messaging.EventHubs
Install-Package Azure.Messaging.EventHubs
Write code to send events to the event hub
Passwordless (Recommended)
Connection String
Replace the existing code in theProgram.csfile with the following sample code. Then, replace<EVENT_HUB_NAMESPACE>and<HUB_NAME>placeholder values for theEventHubProducerClientparameters with the names of your Event Hubs namespace and the event hub. For example:"spehubns0309.servicebus.windows.net"and"spehub".Here are the important steps from the code:Creates anEventHubProducerClientobject using the namespace and the event hub name.Invokes theCreateBatchAsyncmethod on theEventHubProducerClientobject to create anEventDataBatchobject.Add events to the batch using theEventDataBatch.TryAddmethod.Sends the batch of messages to the event hub using theEventHubProducerClient.SendAsyncmethod.using Azure.Identity;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Producer;
using System.Text;

// number of events to be sent to the event hub
int numOfEvents = 3;

// The Event Hubs client types are safe to cache and use as a singleton for the lifetime
// of the application, which is best practice when events are being published or read regularly.
// TODO: Replace the <EVENT_HUB_NAMESPACE> and <HUB_NAME> placeholder values
EventHubProducerClient producerClient = new EventHubProducerClient(
    "<EVENT_HUB_NAMESPACE>.servicebus.windows.net",
    "<HUB_NAME>",
    new DefaultAzureCredential());

// Create a batch of events 
using EventDataBatch eventBatch = await producerClient.CreateBatchAsync();

for (int i = 1; i <= numOfEvents; i++)
{
    if (!eventBatch.TryAdd(new EventData(Encoding.UTF8.GetBytes($"Event {i}"))))
    {
        // if it is too large for the batch
        throw new Exception($"Event {i} is too large for the batch and cannot be sent.");
    }
}

try
{
    // Use the producer client to send the batch of events to the event hub
    await producerClient.SendAsync(eventBatch);
    Console.WriteLine($"A batch of {numOfEvents} events has been published.");
    Console.ReadLine();
}
finally
{
    await producerClient.DisposeAsync();
}
Replace the existing code in theProgram.csfile with the following sample code. Then, replace<EVENT_HUB_NAMESPACE>and<HUB_NAME>placeholder values for theEventHubProducerClientparameters with the names of your Event Hubs namespace and the event hub. For example:"spehubns0309.servicebus.windows.net"and"spehub".
Program.cs
<EVENT_HUB_NAMESPACE>
<HUB_NAME>
EventHubProducerClient
"spehubns0309.servicebus.windows.net"
"spehub"
Here are the important steps from the code:
Creates anEventHubProducerClientobject using the namespace and the event hub name.
Invokes theCreateBatchAsyncmethod on theEventHubProducerClientobject to create anEventDataBatchobject.
Add events to the batch using theEventDataBatch.TryAddmethod.
Sends the batch of messages to the event hub using theEventHubProducerClient.SendAsyncmethod.
using Azure.Identity;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Producer;
using System.Text;

// number of events to be sent to the event hub
int numOfEvents = 3;

// The Event Hubs client types are safe to cache and use as a singleton for the lifetime
// of the application, which is best practice when events are being published or read regularly.
// TODO: Replace the <EVENT_HUB_NAMESPACE> and <HUB_NAME> placeholder values
EventHubProducerClient producerClient = new EventHubProducerClient(
    "<EVENT_HUB_NAMESPACE>.servicebus.windows.net",
    "<HUB_NAME>",
    new DefaultAzureCredential());

// Create a batch of events 
using EventDataBatch eventBatch = await producerClient.CreateBatchAsync();

for (int i = 1; i <= numOfEvents; i++)
{
    if (!eventBatch.TryAdd(new EventData(Encoding.UTF8.GetBytes($"Event {i}"))))
    {
        // if it is too large for the batch
        throw new Exception($"Event {i} is too large for the batch and cannot be sent.");
    }
}

try
{
    // Use the producer client to send the batch of events to the event hub
    await producerClient.SendAsync(eventBatch);
    Console.WriteLine($"A batch of {numOfEvents} events has been published.");
    Console.ReadLine();
}
finally
{
    await producerClient.DisposeAsync();
}
using Azure.Identity;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Producer;
using System.Text;

// number of events to be sent to the event hub
int numOfEvents = 3;

// The Event Hubs client types are safe to cache and use as a singleton for the lifetime
// of the application, which is best practice when events are being published or read regularly.
// TODO: Replace the <EVENT_HUB_NAMESPACE> and <HUB_NAME> placeholder values
EventHubProducerClient producerClient = new EventHubProducerClient(
    "<EVENT_HUB_NAMESPACE>.servicebus.windows.net",
    "<HUB_NAME>",
    new DefaultAzureCredential());

// Create a batch of events 
using EventDataBatch eventBatch = await producerClient.CreateBatchAsync();

for (int i = 1; i <= numOfEvents; i++)
{
    if (!eventBatch.TryAdd(new EventData(Encoding.UTF8.GetBytes($"Event {i}"))))
    {
        // if it is too large for the batch
        throw new Exception($"Event {i} is too large for the batch and cannot be sent.");
    }
}

try
{
    // Use the producer client to send the batch of events to the event hub
    await producerClient.SendAsync(eventBatch);
    Console.WriteLine($"A batch of {numOfEvents} events has been published.");
    Console.ReadLine();
}
finally
{
    await producerClient.DisposeAsync();
}
Replace the existing code in theProgram.csfile with the following sample code. Then, replace the<CONNECTION_STRING>and<HUB_NAME>placeholder values for theEventHubProducerClientparameters.Here are the important steps from the code:Creates aEventHubProducerClientobject using the primary connection string to the namespace and the event hub name.Invokes theCreateBatchAsyncmethod on theEventHubProducerClientobject to create aEventDataBatchobject.Add events to the batch using theEventDataBatch.TryAddmethod.Sends the batch of messages to the event hub using theEventHubProducerClient.SendAsyncmethod.using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Producer;
using System.Text;

// number of events to be sent to the event hub
int numOfEvents = 3;

// The Event Hubs client types are safe to cache and use as a singleton for the lifetime
// of the application, which is best practice when events are being published or read regularly.
// TODO: Replace the <CONNECTION_STRING> and <HUB_NAME> placeholder values
EventHubProducerClient producerClient = new EventHubProducerClient(
    "<CONNECTION_STRING>",
    "<HUB_NAME>");

// Create a batch of events 
using EventDataBatch eventBatch = await producerClient.CreateBatchAsync();

for (int i = 1; i <= numOfEvents; i++)
{
    if (!eventBatch.TryAdd(new EventData(Encoding.UTF8.GetBytes($"Event {i}"))))
    {
        // if it is too large for the batch
        throw new Exception($"Event {i} is too large for the batch and cannot be sent.");
    }
}

try
{
    // Use the producer client to send the batch of events to the event hub
    await producerClient.SendAsync(eventBatch);
    Console.WriteLine($"A batch of {numOfEvents} events has been published.");
    Console.ReadLine();
}
finally
{
    await producerClient.DisposeAsync();
}
Replace the existing code in theProgram.csfile with the following sample code. Then, replace the<CONNECTION_STRING>and<HUB_NAME>placeholder values for theEventHubProducerClientparameters.
Program.cs
<CONNECTION_STRING>
<HUB_NAME>
EventHubProducerClient
Here are the important steps from the code:
Creates aEventHubProducerClientobject using the primary connection string to the namespace and the event hub name.
Invokes theCreateBatchAsyncmethod on theEventHubProducerClientobject to create aEventDataBatchobject.
Add events to the batch using theEventDataBatch.TryAddmethod.
Sends the batch of messages to the event hub using theEventHubProducerClient.SendAsyncmethod.
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Producer;
using System.Text;

// number of events to be sent to the event hub
int numOfEvents = 3;

// The Event Hubs client types are safe to cache and use as a singleton for the lifetime
// of the application, which is best practice when events are being published or read regularly.
// TODO: Replace the <CONNECTION_STRING> and <HUB_NAME> placeholder values
EventHubProducerClient producerClient = new EventHubProducerClient(
    "<CONNECTION_STRING>",
    "<HUB_NAME>");

// Create a batch of events 
using EventDataBatch eventBatch = await producerClient.CreateBatchAsync();

for (int i = 1; i <= numOfEvents; i++)
{
    if (!eventBatch.TryAdd(new EventData(Encoding.UTF8.GetBytes($"Event {i}"))))
    {
        // if it is too large for the batch
        throw new Exception($"Event {i} is too large for the batch and cannot be sent.");
    }
}

try
{
    // Use the producer client to send the batch of events to the event hub
    await producerClient.SendAsync(eventBatch);
    Console.WriteLine($"A batch of {numOfEvents} events has been published.");
    Console.ReadLine();
}
finally
{
    await producerClient.DisposeAsync();
}
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Producer;
using System.Text;

// number of events to be sent to the event hub
int numOfEvents = 3;

// The Event Hubs client types are safe to cache and use as a singleton for the lifetime
// of the application, which is best practice when events are being published or read regularly.
// TODO: Replace the <CONNECTION_STRING> and <HUB_NAME> placeholder values
EventHubProducerClient producerClient = new EventHubProducerClient(
    "<CONNECTION_STRING>",
    "<HUB_NAME>");

// Create a batch of events 
using EventDataBatch eventBatch = await producerClient.CreateBatchAsync();

for (int i = 1; i <= numOfEvents; i++)
{
    if (!eventBatch.TryAdd(new EventData(Encoding.UTF8.GetBytes($"Event {i}"))))
    {
        // if it is too large for the batch
        throw new Exception($"Event {i} is too large for the batch and cannot be sent.");
    }
}

try
{
    // Use the producer client to send the batch of events to the event hub
    await producerClient.SendAsync(eventBatch);
    Console.WriteLine($"A batch of {numOfEvents} events has been published.");
    Console.ReadLine();
}
finally
{
    await producerClient.DisposeAsync();
}
Build the project, and ensure that there are no errors.
Build the project, and ensure that there are no errors.
Run the program and wait for the confirmation message.A batch of 3 events has been published.NoteIf you get an error "InvalidIssuer: Token issuer is invalid" when using Microsoft Entra authentication, it might be because the wrong Microsoft Entra Tenant ID is being used. In your code, replace 'new DefaultAzureCredential()' with 'new DefaultAzureCredential(new DefaultAzureCredentialOptions {TenantId = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"})' to explicitly specify Microsoft Entra Tenant ID.ImportantIf you're using the Passwordless (Microsoft Entra's Role-based Access Control) authentication, selectTools, then selectOptions. In theOptionswindow, expandAzure Service Authentication, and selectAccount Selection. Confirm that you're using the account that was added to theAzure Event Hubs Data Ownerrole on the Event Hubs namespace.
Run the program and wait for the confirmation message.
A batch of 3 events has been published.
A batch of 3 events has been published.
Note
If you get an error "InvalidIssuer: Token issuer is invalid" when using Microsoft Entra authentication, it might be because the wrong Microsoft Entra Tenant ID is being used. In your code, replace 'new DefaultAzureCredential()' with 'new DefaultAzureCredential(new DefaultAzureCredentialOptions {TenantId = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"})' to explicitly specify Microsoft Entra Tenant ID.
Important
If you're using the Passwordless (Microsoft Entra's Role-based Access Control) authentication, selectTools, then selectOptions. In theOptionswindow, expandAzure Service Authentication, and selectAccount Selection. Confirm that you're using the account that was added to theAzure Event Hubs Data Ownerrole on the Event Hubs namespace.
On theEvent Hubs namespacepage in the Azure portal, you see three incoming messages in theMessageschart. Refresh the page to update the chart if needed. It might take a few seconds for it to show that the messages have been received.NoteFor the complete source code with more informational comments, seethis file on the GitHub
On theEvent Hubs namespacepage in the Azure portal, you see three incoming messages in theMessageschart. Refresh the page to update the chart if needed. It might take a few seconds for it to show that the messages have been received.

Note
For the complete source code with more informational comments, seethis file on the GitHub
Receive events from the event hub
This section shows how to write a .NET Core console application that receives events from an event hub using an event processor. The event processor simplifies receiving events from event hubs.
Create an Azure Storage Account and a blob container
In this quickstart, you use Azure Storage as the checkpoint store. Follow these steps to create an Azure Storage account.
Create an Azure Storage account
Create a blob container
Authenticate to the blob container using either Microsoft Entra ID (passwordless) authentication or a connection string to the namespace.
Follow these recommendations when using Azure Blob Storage as a checkpoint store:
Use a separate container for each consumer group. You can use the same storage account, but use one container per each group.
Don't use the container for anything else, and don't use the storage account for anything else.
Storage account should be in the same region as the deployed application is located in. If the application is on-premises, try to choose the closest region possible.
On theStorage accountpage in the Azure portal, in theBlob servicesection, ensure that the following settings are disabled.
Hierarchical namespace
Blob soft delete
Versioning
Passwordless (Recommended)
Connection String
When developing locally, make sure that the user account that is accessing blob data has the correct permissions. You'll needStorage Blob Data Contributorto read and write blob data. To assign yourself this role, you'll need to be assigned theUser Access Administratorrole, or another role that includes theMicrosoft.Authorization/roleAssignments/writeaction. You can assign Azure RBAC roles to a user using the Azure portal, Azure CLI, or Azure PowerShell. You can learn more about the available scopes for role assignments on thescope overviewpage.
In this scenario, you'll assign permissions to your user account, scoped to the storage account, to follow thePrinciple of Least Privilege. This practice gives users only the minimum permissions needed and creates more secure production environments.
The following example will assign theStorage Blob Data Contributorrole to your user account, which provides both read and write access to blob data in your storage account.
Important
In most cases it will take a minute or two for the role assignment to propagate in Azure, but in rare cases it may take up to eight minutes. If you receive authentication errors when you first run your code, wait a few moments and try again.
Azure portal
Azure CLI
PowerShell
In the Azure portal, locate your storage account using the main search bar or left navigation.
In the Azure portal, locate your storage account using the main search bar or left navigation.
On the storage account overview page, selectAccess control (IAM)from the left-hand menu.
On the storage account overview page, selectAccess control (IAM)from the left-hand menu.
On theAccess control (IAM)page, select theRole assignmentstab.
On theAccess control (IAM)page, select theRole assignmentstab.
Select+ Addfrom the top menu and thenAdd role assignmentfrom the resulting drop-down menu.
Select+ Addfrom the top menu and thenAdd role assignmentfrom the resulting drop-down menu.

Use the search box to filter the results to the desired role. For this example, search forStorage Blob Data Contributorand select the matching result and then chooseNext.
Use the search box to filter the results to the desired role. For this example, search forStorage Blob Data Contributorand select the matching result and then chooseNext.
UnderAssign access to, selectUser, group, or service principal, and then choose+ Select members.
UnderAssign access to, selectUser, group, or service principal, and then choose+ Select members.
In the dialog, search for your Microsoft Entra username (usually youruser@domainemail address) and then chooseSelectat the bottom of the dialog.
In the dialog, search for your Microsoft Entra username (usually youruser@domainemail address) and then chooseSelectat the bottom of the dialog.
SelectReview + assignto go to the final page, and thenReview + assignagain to complete the process.
SelectReview + assignto go to the final page, and thenReview + assignagain to complete the process.
To assign a role at the resource level using the Azure CLI, you first must retrieve the resource ID using theaz storage account showcommand. You can filter the output properties using the--queryparameter.
az storage account show
--query
az storage account show --resource-group '<your-resource-group-name>' --name '<your-storage-account-name>' --query id
az storage account show --resource-group '<your-resource-group-name>' --name '<your-storage-account-name>' --query id
Copy the outputIdfrom the preceding command. You can then assign roles using theaz rolecommand of the Azure CLI.
Id
az role assignment create --assignee "<user@domain>" \
    --role "Storage Blob Data Contributor" \
    --scope "<your-resource-id>"
az role assignment create --assignee "<user@domain>" \
    --role "Storage Blob Data Contributor" \
    --scope "<your-resource-id>"
To assign a role at the resource level using Azure PowerShell, you first must retrieve the resource ID using theGet-AzResourcecommand.
Get-AzResource
Get-AzResource -ResourceGroupName "<yourResourceGroupname>" -Name "<yourStorageAccountName>"
Get-AzResource -ResourceGroupName "<yourResourceGroupname>" -Name "<yourStorageAccountName>"
Copy theIdvalue from the preceding command output. You can then assign roles using theNew-AzRoleAssignmentcommand in PowerShell.
Id
New-AzRoleAssignment -SignInName <user@domain> `
    -RoleDefinitionName "Storage Blob Data Contributor" `
    -Scope <yourStorageAccountId>
New-AzRoleAssignment -SignInName <user@domain> `
    -RoleDefinitionName "Storage Blob Data Contributor" `
    -Scope <yourStorageAccountId>
Get the connection string to the storage account
Note down the connection string and the container name. You use them in the code to receive events from the event hub.
Create a project for the receiver
In the Solution Explorer window, right-click theEventHubQuickStartsolution, point toAdd, and selectNew Project.
SelectConsole application, and selectNext.
EnterEventHubsReceiverfor theProject name, and selectCreate.
In theSolution Explorerwindow, right-clickEventHubsReceiver, and selectSet as a Startup Project.
Add the NuGet packages to the project
Passwordless (Recommended)
Connection String
SelectTools>NuGet Package Manager>Package Manager Consolefrom the menu.
SelectTools>NuGet Package Manager>Package Manager Consolefrom the menu.
In thePackage Manager Consolewindow, confirm thatEventHubsReceiveris selected for theDefault project. If not, use the drop-down list to selectEventHubsReceiver.
In thePackage Manager Consolewindow, confirm thatEventHubsReceiveris selected for theDefault project. If not, use the drop-down list to selectEventHubsReceiver.
Run the following command to install theAzure.Messaging.EventHubsand theAzure.IdentityNuGet packages. PressENTERto run the last command.Install-Package Azure.Messaging.EventHubs
Install-Package Azure.Messaging.EventHubs.Processor
Install-Package Azure.Identity
Run the following command to install theAzure.Messaging.EventHubsand theAzure.IdentityNuGet packages. PressENTERto run the last command.
Install-Package Azure.Messaging.EventHubs
Install-Package Azure.Messaging.EventHubs.Processor
Install-Package Azure.Identity
Install-Package Azure.Messaging.EventHubs
Install-Package Azure.Messaging.EventHubs.Processor
Install-Package Azure.Identity
SelectTools>NuGet Package Manager>Package Manager Consolefrom the menu.
SelectTools>NuGet Package Manager>Package Manager Consolefrom the menu.
In thePackage Manager Consolewindow, confirm thatEventHubsReceiveris selected for theDefault project. If not, use the drop-down list to selectEventHubsReceiver.
In thePackage Manager Consolewindow, confirm thatEventHubsReceiveris selected for theDefault project. If not, use the drop-down list to selectEventHubsReceiver.
Run the following command to install theAzure.Messaging.EventHubsNuGet package:Install-Package Azure.Messaging.EventHubs
Install-Package Azure.Messaging.EventHubs.Processor
Run the following command to install theAzure.Messaging.EventHubsNuGet package:
Install-Package Azure.Messaging.EventHubs
Install-Package Azure.Messaging.EventHubs.Processor
Install-Package Azure.Messaging.EventHubs
Install-Package Azure.Messaging.EventHubs.Processor
Update the code
Replace the contents ofProgram.cswith the following code:
Passwordless (Recommended)
Connection String
Replace the existing code in theProgram.csfile with the following sample code. Then, replace the<STORAGE_ACCOUNT_NAME>and<BLOB_CONTAINER_NAME>placeholder values for theBlobContainerClientURI. Replace the<EVENT_HUB_NAMESPACE>and<HUB_NAME>placeholder values for theEventProcessorClientas well.Here are the important steps from the code:Creates anEventProcessorClientobject using the Event Hubs namespace and the event hub name. You need to buildBlobContainerClientobject for the container in the Azure storage you created earlier.Specifies handlers for theProcessEventAsyncandProcessErrorAsyncevents of theEventProcessorClientobject.Starts processing events by invoking theStartProcessingAsyncon theEventProcessorClientobject.Stops processing events after 30 seconds by invokingStopProcessingAsyncon theEventProcessorClientobject.using Azure.Identity;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Consumer;
using Azure.Messaging.EventHubs.Processor;
using Azure.Storage.Blobs;
using System.Text;

// Create a blob container client that the event processor will use
// TODO: Replace <STORAGE_ACCOUNT_NAME> and <BLOB_CONTAINER_NAME> with actual names
BlobContainerClient storageClient = new BlobContainerClient(
    new Uri("https://<STORAGE_ACCOUNT_NAME>.blob.core.windows.net/<BLOB_CONTAINER_NAME>"),
    new DefaultAzureCredential());

// Create an event processor client to process events in the event hub
// TODO: Replace the <EVENT_HUBS_NAMESPACE> and <HUB_NAME> placeholder values
var processor = new EventProcessorClient(
    storageClient,
    EventHubConsumerClient.DefaultConsumerGroupName,
    "<EVENT_HUB_NAMESPACE>.servicebus.windows.net",
    "<HUB_NAME>",
    new DefaultAzureCredential());

// Register handlers for processing events and handling errors
processor.ProcessEventAsync += ProcessEventHandler;
processor.ProcessErrorAsync += ProcessErrorHandler;

// Start the processing
await processor.StartProcessingAsync();

// Wait for 30 seconds for the events to be processed
await Task.Delay(TimeSpan.FromSeconds(30));

// Stop the processing
await processor.StopProcessingAsync();

Task ProcessEventHandler(ProcessEventArgs eventArgs)
{
    // Write the body of the event to the console window
    Console.WriteLine("\tReceived event: {0}", Encoding.UTF8.GetString(eventArgs.Data.Body.ToArray()));
    Console.ReadLine();
    return Task.CompletedTask;
}

Task ProcessErrorHandler(ProcessErrorEventArgs eventArgs)
{
    // Write details about the error to the console window
    Console.WriteLine($"\tPartition '{eventArgs.PartitionId}': an unhandled exception was encountered. This was not expected to happen.");
    Console.WriteLine(eventArgs.Exception.Message);
    Console.ReadLine();
    return Task.CompletedTask;
}
Replace the existing code in theProgram.csfile with the following sample code. Then, replace the<STORAGE_ACCOUNT_NAME>and<BLOB_CONTAINER_NAME>placeholder values for theBlobContainerClientURI. Replace the<EVENT_HUB_NAMESPACE>and<HUB_NAME>placeholder values for theEventProcessorClientas well.
Program.cs
<STORAGE_ACCOUNT_NAME>
<BLOB_CONTAINER_NAME>
BlobContainerClient
<EVENT_HUB_NAMESPACE>
<HUB_NAME>
EventProcessorClient
Here are the important steps from the code:
Creates anEventProcessorClientobject using the Event Hubs namespace and the event hub name. You need to buildBlobContainerClientobject for the container in the Azure storage you created earlier.
Specifies handlers for theProcessEventAsyncandProcessErrorAsyncevents of theEventProcessorClientobject.
Starts processing events by invoking theStartProcessingAsyncon theEventProcessorClientobject.
Stops processing events after 30 seconds by invokingStopProcessingAsyncon theEventProcessorClientobject.
using Azure.Identity;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Consumer;
using Azure.Messaging.EventHubs.Processor;
using Azure.Storage.Blobs;
using System.Text;

// Create a blob container client that the event processor will use
// TODO: Replace <STORAGE_ACCOUNT_NAME> and <BLOB_CONTAINER_NAME> with actual names
BlobContainerClient storageClient = new BlobContainerClient(
    new Uri("https://<STORAGE_ACCOUNT_NAME>.blob.core.windows.net/<BLOB_CONTAINER_NAME>"),
    new DefaultAzureCredential());

// Create an event processor client to process events in the event hub
// TODO: Replace the <EVENT_HUBS_NAMESPACE> and <HUB_NAME> placeholder values
var processor = new EventProcessorClient(
    storageClient,
    EventHubConsumerClient.DefaultConsumerGroupName,
    "<EVENT_HUB_NAMESPACE>.servicebus.windows.net",
    "<HUB_NAME>",
    new DefaultAzureCredential());

// Register handlers for processing events and handling errors
processor.ProcessEventAsync += ProcessEventHandler;
processor.ProcessErrorAsync += ProcessErrorHandler;

// Start the processing
await processor.StartProcessingAsync();

// Wait for 30 seconds for the events to be processed
await Task.Delay(TimeSpan.FromSeconds(30));

// Stop the processing
await processor.StopProcessingAsync();

Task ProcessEventHandler(ProcessEventArgs eventArgs)
{
    // Write the body of the event to the console window
    Console.WriteLine("\tReceived event: {0}", Encoding.UTF8.GetString(eventArgs.Data.Body.ToArray()));
    Console.ReadLine();
    return Task.CompletedTask;
}

Task ProcessErrorHandler(ProcessErrorEventArgs eventArgs)
{
    // Write details about the error to the console window
    Console.WriteLine($"\tPartition '{eventArgs.PartitionId}': an unhandled exception was encountered. This was not expected to happen.");
    Console.WriteLine(eventArgs.Exception.Message);
    Console.ReadLine();
    return Task.CompletedTask;
}
using Azure.Identity;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Consumer;
using Azure.Messaging.EventHubs.Processor;
using Azure.Storage.Blobs;
using System.Text;

// Create a blob container client that the event processor will use
// TODO: Replace <STORAGE_ACCOUNT_NAME> and <BLOB_CONTAINER_NAME> with actual names
BlobContainerClient storageClient = new BlobContainerClient(
    new Uri("https://<STORAGE_ACCOUNT_NAME>.blob.core.windows.net/<BLOB_CONTAINER_NAME>"),
    new DefaultAzureCredential());

// Create an event processor client to process events in the event hub
// TODO: Replace the <EVENT_HUBS_NAMESPACE> and <HUB_NAME> placeholder values
var processor = new EventProcessorClient(
    storageClient,
    EventHubConsumerClient.DefaultConsumerGroupName,
    "<EVENT_HUB_NAMESPACE>.servicebus.windows.net",
    "<HUB_NAME>",
    new DefaultAzureCredential());

// Register handlers for processing events and handling errors
processor.ProcessEventAsync += ProcessEventHandler;
processor.ProcessErrorAsync += ProcessErrorHandler;

// Start the processing
await processor.StartProcessingAsync();

// Wait for 30 seconds for the events to be processed
await Task.Delay(TimeSpan.FromSeconds(30));

// Stop the processing
await processor.StopProcessingAsync();

Task ProcessEventHandler(ProcessEventArgs eventArgs)
{
    // Write the body of the event to the console window
    Console.WriteLine("\tReceived event: {0}", Encoding.UTF8.GetString(eventArgs.Data.Body.ToArray()));
    Console.ReadLine();
    return Task.CompletedTask;
}

Task ProcessErrorHandler(ProcessErrorEventArgs eventArgs)
{
    // Write details about the error to the console window
    Console.WriteLine($"\tPartition '{eventArgs.PartitionId}': an unhandled exception was encountered. This was not expected to happen.");
    Console.WriteLine(eventArgs.Exception.Message);
    Console.ReadLine();
    return Task.CompletedTask;
}
Replace the existing code in theProgram.csfile with the following sample code. Then, replace the<AZURE_STORAGE_CONNECTION_STRING>and<BLOB_CONTAINER_NAME>placeholder values for theBlobContainerClientURI. Replace the<EVENT_HUB_NAMESPACE_CONNECTION_STRING>and<HUB_NAME>placeholder values for theEventProcessorClientas well.Here are the important steps from the code:Creates anEventProcessorClientobject using the primary connection string to the namespace and the event hub. You need to buildBlobContainerClientobject for the container in the Azure storage you created earlier.Specifies handlers for theProcessEventAsyncandProcessErrorAsyncevents of theEventProcessorClientobject.Starts processing events by invoking theStartProcessingAsyncon theEventProcessorClientobject.Stops processing events after 30 seconds by invokingStopProcessingAsyncon theEventProcessorClientobject.using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Consumer;
using Azure.Messaging.EventHubs.Processor;
using Azure.Storage.Blobs;
using System.Text;

// Create a blob container client that the event processor will use 
BlobContainerClient storageClient = new BlobContainerClient(
    "<AZURE_STORAGE_CONNECTION_STRING>", "<BLOB_CONTAINER_NAME>");

// Create an event processor client to process events in the event hub
var processor = new EventProcessorClient(
    storageClient,
    EventHubConsumerClient.DefaultConsumerGroupName,
    "<EVENT_HUBS_NAMESPACE_CONNECTION_STRING>",
    "<HUB_NAME>");

// Register handlers for processing events and handling errors
processor.ProcessEventAsync += ProcessEventHandler;
processor.ProcessErrorAsync += ProcessErrorHandler;

// Start the processing
await processor.StartProcessingAsync();

// Wait for 30 seconds for the events to be processed
await Task.Delay(TimeSpan.FromSeconds(30));

// Stop the processing
await processor.StopProcessingAsync();

Task ProcessEventHandler(ProcessEventArgs eventArgs)
{
    // Write the body of the event to the console window
    Console.WriteLine("\tReceived event: {0}", Encoding.UTF8.GetString(eventArgs.Data.Body.ToArray()));
    return Task.CompletedTask;
}

Task ProcessErrorHandler(ProcessErrorEventArgs eventArgs)
{
    // Write details about the error to the console window
    Console.WriteLine($"\tPartition '{eventArgs.PartitionId}': an unhandled exception was encountered. This was not expected to happen.");
    Console.WriteLine(eventArgs.Exception.Message);
    return Task.CompletedTask;
}
Replace the existing code in theProgram.csfile with the following sample code. Then, replace the<AZURE_STORAGE_CONNECTION_STRING>and<BLOB_CONTAINER_NAME>placeholder values for theBlobContainerClientURI. Replace the<EVENT_HUB_NAMESPACE_CONNECTION_STRING>and<HUB_NAME>placeholder values for theEventProcessorClientas well.
Program.cs
<AZURE_STORAGE_CONNECTION_STRING>
<BLOB_CONTAINER_NAME>
BlobContainerClient
<EVENT_HUB_NAMESPACE_CONNECTION_STRING>
<HUB_NAME>
EventProcessorClient
Here are the important steps from the code:
Creates anEventProcessorClientobject using the primary connection string to the namespace and the event hub. You need to buildBlobContainerClientobject for the container in the Azure storage you created earlier.
Specifies handlers for theProcessEventAsyncandProcessErrorAsyncevents of theEventProcessorClientobject.
Starts processing events by invoking theStartProcessingAsyncon theEventProcessorClientobject.
Stops processing events after 30 seconds by invokingStopProcessingAsyncon theEventProcessorClientobject.
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Consumer;
using Azure.Messaging.EventHubs.Processor;
using Azure.Storage.Blobs;
using System.Text;

// Create a blob container client that the event processor will use 
BlobContainerClient storageClient = new BlobContainerClient(
    "<AZURE_STORAGE_CONNECTION_STRING>", "<BLOB_CONTAINER_NAME>");

// Create an event processor client to process events in the event hub
var processor = new EventProcessorClient(
    storageClient,
    EventHubConsumerClient.DefaultConsumerGroupName,
    "<EVENT_HUBS_NAMESPACE_CONNECTION_STRING>",
    "<HUB_NAME>");

// Register handlers for processing events and handling errors
processor.ProcessEventAsync += ProcessEventHandler;
processor.ProcessErrorAsync += ProcessErrorHandler;

// Start the processing
await processor.StartProcessingAsync();

// Wait for 30 seconds for the events to be processed
await Task.Delay(TimeSpan.FromSeconds(30));

// Stop the processing
await processor.StopProcessingAsync();

Task ProcessEventHandler(ProcessEventArgs eventArgs)
{
    // Write the body of the event to the console window
    Console.WriteLine("\tReceived event: {0}", Encoding.UTF8.GetString(eventArgs.Data.Body.ToArray()));
    return Task.CompletedTask;
}

Task ProcessErrorHandler(ProcessErrorEventArgs eventArgs)
{
    // Write details about the error to the console window
    Console.WriteLine($"\tPartition '{eventArgs.PartitionId}': an unhandled exception was encountered. This was not expected to happen.");
    Console.WriteLine(eventArgs.Exception.Message);
    return Task.CompletedTask;
}
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Consumer;
using Azure.Messaging.EventHubs.Processor;
using Azure.Storage.Blobs;
using System.Text;

// Create a blob container client that the event processor will use 
BlobContainerClient storageClient = new BlobContainerClient(
    "<AZURE_STORAGE_CONNECTION_STRING>", "<BLOB_CONTAINER_NAME>");

// Create an event processor client to process events in the event hub
var processor = new EventProcessorClient(
    storageClient,
    EventHubConsumerClient.DefaultConsumerGroupName,
    "<EVENT_HUBS_NAMESPACE_CONNECTION_STRING>",
    "<HUB_NAME>");

// Register handlers for processing events and handling errors
processor.ProcessEventAsync += ProcessEventHandler;
processor.ProcessErrorAsync += ProcessErrorHandler;

// Start the processing
await processor.StartProcessingAsync();

// Wait for 30 seconds for the events to be processed
await Task.Delay(TimeSpan.FromSeconds(30));

// Stop the processing
await processor.StopProcessingAsync();

Task ProcessEventHandler(ProcessEventArgs eventArgs)
{
    // Write the body of the event to the console window
    Console.WriteLine("\tReceived event: {0}", Encoding.UTF8.GetString(eventArgs.Data.Body.ToArray()));
    return Task.CompletedTask;
}

Task ProcessErrorHandler(ProcessErrorEventArgs eventArgs)
{
    // Write details about the error to the console window
    Console.WriteLine($"\tPartition '{eventArgs.PartitionId}': an unhandled exception was encountered. This was not expected to happen.");
    Console.WriteLine(eventArgs.Exception.Message);
    return Task.CompletedTask;
}
Build the project, and ensure that there are no errors.NoteFor the complete source code with more informational comments, seethis file on the GitHub.
Build the project, and ensure that there are no errors.
Note
For the complete source code with more informational comments, seethis file on the GitHub.
Run the receiver application.
Run the receiver application.
You should see a message that the events have been received. Press ENTER after you see a received event message.Received event: Event 1
Received event: Event 2
Received event: Event 3These events are the three events you sent to the event hub earlier by running the sender program.
You should see a message that the events have been received. Press ENTER after you see a received event message.
Received event: Event 1
Received event: Event 2
Received event: Event 3
Received event: Event 1
Received event: Event 2
Received event: Event 3
These events are the three events you sent to the event hub earlier by running the sender program.
In the Azure portal, you can verify that there are three outgoing messages, which Event Hubs sent to the receiving application. Refresh the page to update the chart. It might take a few seconds for it to show that the messages have been received.
In the Azure portal, you can verify that there are three outgoing messages, which Event Hubs sent to the receiving application. Refresh the page to update the chart. It might take a few seconds for it to show that the messages have been received.

Schema validation for Event Hubs SDK based applications
You can use Azure Schema Registry to perform schema validation when you stream data with your Event Hubs SDK-based applications.
Azure Schema Registry of Event Hubs provides a centralized repository for managing schemas and you can seamlessly connect your new or existing applications with Schema Registry.
To learn more, seeValidate schemas with Event Hubs SDK.
Samples and reference
This quick start provides step-by-step instructions to implement a scenario of sending a batch of events to an event hub and then receiving them. For more samples, select the following links.
Event Hubs samples on GitHub
Event processor samples on GitHub
Azure role-based access control (Azure RBAC) sample
For complete .NET library reference, see ourSDK documentation.
Clean up resources
Delete the resource group that has the Event Hubs namespace or delete only the namespace if you want to keep the resource group.
Related content
See the following tutorial:
Tutorial: Visualize data anomalies in real-time events sent to Azure Event Hubs
Feedback
Was this page helpful?
Additional resources