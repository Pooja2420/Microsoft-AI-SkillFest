Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
Expressions
Article
2025-01-31
33 contributors
In this article
Azure DevOps Services | Azure DevOps Server 2022 - Azure DevOps Server 2019
Important

Select the version of this article that corresponds to your platform and version. The version selector is above the table of contents.Look up your Azure DevOps platform and version.
Expressions can be used in many places where you need to specify a string, boolean, or number value when authoring a pipeline. When an expression returns an array, normal indexing rules apply and the index starts with0.
0
The most common use of expressions is inconditionsto determine whether a job or step should run.
# Expressions are used to define conditions for a step, job, or stage
steps:
- task: ...
  condition: <expression>
# Expressions are used to define conditions for a step, job, or stage
steps:
- task: ...
  condition: <expression>
Another common use of expressions is in defining variables.
Expressions can be evaluated atcompile timeor atrun time.
Compile time expressions can be used anywhere; runtime expressions can be used in variables and conditions. Runtime expressions are intended as a way to compute the contents of variables and state (example:condition).
condition
# Two examples of expressions used to define variables
# The first one, a, is evaluated when the YAML file is compiled into a plan.
# The second one, b, is evaluated at runtime.
# Note the syntax ${{}} for compile time and $[] for runtime expressions.
variables:
  a: ${{ <expression> }}
  b: $[ <expression> ]
# Two examples of expressions used to define variables
# The first one, a, is evaluated when the YAML file is compiled into a plan.
# The second one, b, is evaluated at runtime.
# Note the syntax ${{}} for compile time and $[] for runtime expressions.
variables:
  a: ${{ <expression> }}
  b: $[ <expression> ]
The difference between runtime and compile time expression syntaxes is primarily what context is available.
In a compile-time expression (${{ <expression> }}), you have access toparametersand statically definedvariables.
In a runtime expression ($[ <expression> ]), you have access to morevariablesbut no parameters.
${{ <expression> }}
parameters
variables
$[ <expression> ]
variables
In this example, a runtime expression sets the  value of$(isMain). A static variable in a compile expression sets the value of$(compileVar).
$(isMain)
$(compileVar)
variables:
  staticVar: 'my value' # static variable
  compileVar: ${{ variables.staticVar }} # compile time expression
  isMain: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')] # runtime expression

steps:
  - script: |
      echo ${{variables.staticVar}} # outputs my value
      echo $(compileVar) # outputs my value
      echo $(isMain) # outputs True
variables:
  staticVar: 'my value' # static variable
  compileVar: ${{ variables.staticVar }} # compile time expression
  isMain: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')] # runtime expression

steps:
  - script: |
      echo ${{variables.staticVar}} # outputs my value
      echo $(compileVar) # outputs my value
      echo $(isMain) # outputs True
An expression can be a literal, a reference to a variable, a reference to a dependency, a function, or a valid nested combination of these.
Literals
As part of an expression, you can use boolean, null, number, string, or version literals.
# Examples
variables:
  someBoolean: ${{ true }} # case insensitive, so True or TRUE also works
  someNumber: ${{ -1.2 }}
  someString: ${{ 'a b c' }}
  someVersion: ${{ 1.2.3 }}
# Examples
variables:
  someBoolean: ${{ true }} # case insensitive, so True or TRUE also works
  someNumber: ${{ -1.2 }}
  someString: ${{ 'a b c' }}
  someVersion: ${{ 1.2.3 }}
Boolean
TrueandFalseare boolean literal expressions.
True
False
Null
Null is a special literal expression that's returned from a dictionary miss, for example (variables['noSuch']). Null can be the output of an expression but can't be called directly within an expression.
variables['noSuch']
Number
Starts with '-', '.', or '0' through '9'.
String
Must be single-quoted. For example:'this is a string'.
'this is a string'
To express a literal single-quote, escape it with a single quote.
For example:'It''s OK if they''re using contractions.'.
'It''s OK if they''re using contractions.'
You can use a pipe character (|) for multiline strings.
|
myKey: |
  one
  two
  three
myKey: |
  one
  two
  three
Version
A version number with up to four segments.
Must start with a number and contain two or three period (.) characters.
For example:1.2.3.4.
.
1.2.3.4
Variables
As part of an expression, you may access variables using one of two syntaxes:
Index syntax:variables['MyVar']
variables['MyVar']
Property dereference syntax:variables.MyVar
variables.MyVar
In order to use property dereference syntax, the property name must:
Start witha-Zor_
a-Z
_
Be followed bya-Z0-9or_
a-Z
0-9
_
Depending on the execution context, different variables are available.
If you create pipelines using YAML, thenpipeline variablesare available.
If you create build pipelines using classic editor, thenbuild variablesare available.
If you create release pipelines using classic editor, thenrelease variablesare available.
Variables are always strings. If you want to use typed values, then you should useparametersinstead.
Note
There is a limitation for using variables with expressions for both Classical and YAML pipelines when setting up such variables via variables tab UI. Variables that are defined as expressions shouldn't depend on another variable with expression in value sinceit isn't guaranteedthat both expressions will be evaluated properly. For example we have variableawhose value$[ <expression> ]is used as a part for the value of variableb. Since the order of processing variables isn't guaranteed variablebcould have an incorrect value of variableaafter evaluation.
a
$[ <expression> ]
b
b
a
Described constructions are only allowed while setup variables throughvariables keywordin YAML pipeline. It is required to place the variables in the order they should be processed to get the correct values after processing.
Functions
The following built-in functions can be used in expressions.
and
Evaluates toTrueif all parameters areTrue
True
True
Min parameters: 2. Max parameters: N
Casts parameters to Boolean for evaluation
Short-circuits after firstFalse
False
Example:and(eq(variables.letters, 'ABC'), eq(variables.numbers, 123))
and(eq(variables.letters, 'ABC'), eq(variables.numbers, 123))
coalesce
Evaluates the parameters in order (left to right), and returns the first value that doesn't equal null or empty-string.
No value is returned if the parameter values all are null or empty strings.
Min parameters: 2. Max parameters: N
Example:coalesce(variables.couldBeNull, variables.couldAlsoBeNull, 'literal so it always works')
coalesce(variables.couldBeNull, variables.couldAlsoBeNull, 'literal so it always works')
contains
EvaluatesTrueif left parameter String contains right parameter
True
Min parameters: 2. Max parameters: 2
Casts parameters to String for evaluation
Performs ordinal ignore-case comparison
Example:contains('ABCDE', 'BCD')(returns True)
contains('ABCDE', 'BCD')
containsValue
EvaluatesTrueif the left parameter is an array, and any item equals the right parameter. Also evaluatesTrueif the left parameter is an object, and the value of any property equals the right parameter.
True
True
Min parameters: 2. Max parameters: 2
If the left parameter is an array, convert each item to match the type of the right parameter. If the left parameter is an object, convert the value of each property to match the type of the right parameter.  The equality comparison for each specific item evaluatesFalseif the conversion fails.
False
Ordinal ignore-case comparison for Strings
Short-circuits after the first match
Note
There is no literal syntax in a YAML pipeline for specifying an array.
This function is of limited use in general pipelines.
It's intended for use in thepipeline decorator contextwith system-provided arrays such as the list of steps.
You can use thecontainsValueexpression to find a matching value in an object. Here's an example that demonstrates looking in list of source branches for a match forBuild.SourceBranch.
containsValue
Build.SourceBranch
parameters:
- name: branchOptions
  displayName: Source branch options
  type: object
  default:
    - refs/heads/main
    - refs/heads/test

jobs:
  - job: A1 
    steps:
    - ${{ each value in parameters.branchOptions }}:
      - script: echo ${{ value }}

  - job: B1 
    condition: ${{ containsValue(parameters.branchOptions, variables['Build.SourceBranch']) }}
    steps:
      - script: echo "Matching branch found"
parameters:
- name: branchOptions
  displayName: Source branch options
  type: object
  default:
    - refs/heads/main
    - refs/heads/test

jobs:
  - job: A1 
    steps:
    - ${{ each value in parameters.branchOptions }}:
      - script: echo ${{ value }}

  - job: B1 
    condition: ${{ containsValue(parameters.branchOptions, variables['Build.SourceBranch']) }}
    steps:
      - script: echo "Matching branch found"
convertToJson
Take a complex object and outputs it as JSON.
Min parameters: 1. Max parameters: 1.
parameters:
  - name: listOfValues
    type: object
    default:
      this_is:
        a_complex: object
        with:
          - one
          - two

steps:
- script: |
    echo "${MY_JSON}"
  env:
    MY_JSON: ${{ convertToJson(parameters.listOfValues) }}
parameters:
  - name: listOfValues
    type: object
    default:
      this_is:
        a_complex: object
        with:
          - one
          - two

steps:
- script: |
    echo "${MY_JSON}"
  env:
    MY_JSON: ${{ convertToJson(parameters.listOfValues) }}
Script output:
{
  "this_is": {
    "a_complex": "object",
    "with": [
      "one",
      "two"
    ]
  }
}
{
  "this_is": {
    "a_complex": "object",
    "with": [
      "one",
      "two"
    ]
  }
}
counter
This function can only be used in an expression that defines a variable. It can't be used as part of a condition for a step, job, or stage.
Evaluates a number that is incremented with each run of a pipeline.
Parameters: 2.prefixandseed.
prefix
seed
Prefix is a string expression. A separate value of counter is tracked for each unique value of prefix. Theprefixshould use UTF-16 characters.
prefix
Seed is the starting value of the counter
You can create a counter that is automatically incremented by one in each execution of your pipeline. When you define a counter, you provide aprefixand aseed. Here's an example that demonstrates this.
prefix
seed
variables:
  major: 1
  # define minor as a counter with the prefix as variable major, and seed as 100.
  minor: $[counter(variables['major'], 100)]

steps:
- bash: echo $(minor)
variables:
  major: 1
  # define minor as a counter with the prefix as variable major, and seed as 100.
  minor: $[counter(variables['major'], 100)]

steps:
- bash: echo $(minor)
The value ofminorin the above example in the first run of the pipeline is 100. In the second run it is 101, provided the value ofmajoris still 1.
minor
major
If you edit the YAML file, and update the value of the variablemajorto be 2, then in the next run of the pipeline, the value ofminorwill be 100. Subsequent runs increment the counter to 101, 102, 103, ...
major
minor
Later, if you edit the YAML file, and set the value ofmajorback to 1, then the value of the counter resumes where it left off for that prefix. In this example, it resumes at 102.
major
Here's another example of setting a variable to act as a counter that starts at 100, gets incremented by 1 for every run, and gets reset to 100 every day.
Note
pipeline.startTimeis not available outside of expressions.pipeline.startTimeformatssystem.pipelineStartTimeinto a date and time object so that it is available to work with expressions.
The default time zone forpipeline.startTimeis UTC. You canchange the time zonefor your organization.
pipeline.startTime
pipeline.startTime
system.pipelineStartTime
pipeline.startTime
jobs:
- job:
  variables:
    a: $[counter(format('{0:yyyyMMdd}', pipeline.startTime), 100)]
  steps:
  - bash: echo $(a)
jobs:
- job:
  variables:
    a: $[counter(format('{0:yyyyMMdd}', pipeline.startTime), 100)]
  steps:
  - bash: echo $(a)
Here's an example of having a counter that maintains a separate value for PRs and CI runs.
variables:
  patch: $[counter(variables['build.reason'], 0)]
variables:
  patch: $[counter(variables['build.reason'], 0)]
Counters are scoped to a pipeline. In other words, its value is incremented for each run of that pipeline. There are no project-scoped counters.
endsWith
EvaluatesTrueif left parameter String ends with right parameter
True
Min parameters: 2. Max parameters: 2
Casts parameters to String for evaluation
Performs ordinal ignore-case comparison
Example:endsWith('ABCDE', 'DE')(returns True)
endsWith('ABCDE', 'DE')
eq
EvaluatesTrueif parameters are equal
True
Min parameters: 2. Max parameters: 2
Converts right parameter to match type of left parameter. ReturnsFalseif conversion fails.
False
Ordinal ignore-case comparison for Strings
Example:eq(variables.letters, 'ABC')
eq(variables.letters, 'ABC')
format
Evaluates the trailing parameters and inserts them into the leading parameter string
Min parameters: 1. Max parameters: N
Example:format('Hello {0} {1}', 'John', 'Doe')
format('Hello {0} {1}', 'John', 'Doe')
Uses.NET custom date and time format specifiersfor date formatting (yyyy,yy,MM,M,dd,d,HH,H,m,mm,ss,s,f,ff,ffff,K)
yyyy
yy
MM
M
dd
d
HH
H
m
mm
ss
s
f
ff
ffff
K
Example:format('{0:yyyyMMdd}', pipeline.startTime). In this casepipeline.startTimeis a special date time object variable.
format('{0:yyyyMMdd}', pipeline.startTime)
pipeline.startTime
Escape by doubling braces. For example:format('literal left brace {{ and literal right brace }}')
format('literal left brace {{ and literal right brace }}')
ge
EvaluatesTrueif left parameter is greater than or equal to the right parameter
True
Min parameters: 2. Max parameters: 2
Converts right parameter to match type of left parameter. Errors if conversion fails.
Ordinal ignore-case comparison for Strings
Example:ge(5, 5)(returns True)
ge(5, 5)
gt
EvaluatesTrueif left parameter is greater than the right parameter
True
Min parameters: 2. Max parameters: 2
Converts right parameter to match type of left parameter. Errors if conversion fails.
Ordinal ignore-case comparison for Strings
Example:gt(5, 2)(returns True)
gt(5, 2)
in
EvaluatesTrueif left parameter is equal to any right parameter
True
Min parameters: 1. Max parameters: N
Converts right parameters to match type of left parameter. Equality comparison evaluatesFalseif conversion fails.
False
Ordinal ignore-case comparison for Strings
Short-circuits after first match
Example:in('B', 'A', 'B', 'C')(returns True)
in('B', 'A', 'B', 'C')
iif
Returns the second parameter if the first parameter evaluates toTrue, and the third parameter otherwise
True
Min parameters: 1. Max parameters: 3
The first parameter must be a condition
Example:iif(eq(variables['Build.Reason'], 'PullRequest'), 'ManagedDevOpsPool', 'Azure Pipelines')returns 'ManagedDevOpsPool' when the pipeline runs in response to a PR.
iif(eq(variables['Build.Reason'], 'PullRequest'), 'ManagedDevOpsPool', 'Azure Pipelines')
join
Concatenates all elements in the right parameter array, separated by the left parameter string.
Min parameters: 2. Max parameters: 2
Each element in the array is converted to a string. Complex objects are converted to empty string.
If the right parameter isn't an array, the result is the right parameter converted to a string.
In this example, a semicolon gets added between each item in the array. The parameter type is an object.
parameters:
- name: myArray
  type: object
  default:
    - FOO
    - BAR
    - ZOO

variables:
   A: ${{ join(';',parameters.myArray) }}

steps:
  - script: echo $A # outputs FOO;BAR;ZOO
parameters:
- name: myArray
  type: object
  default:
    - FOO
    - BAR
    - ZOO

variables:
   A: ${{ join(';',parameters.myArray) }}

steps:
  - script: echo $A # outputs FOO;BAR;ZOO
le
EvaluatesTrueif left parameter is less than or equal to the right parameter
True
Min parameters: 2. Max parameters: 2
Converts right parameter to match type of left parameter. Errors if conversion fails.
Ordinal ignore-case comparison for Strings
Example:le(2, 2)(returns True)
le(2, 2)
length
Returns the length of a string or an array, either one that comes from the system or that comes from a parameter
Min parameters: 1. Max parameters 1
Example:length('fabrikam')returns 8
length('fabrikam')
lower
Converts a string or variable value to all lowercase characters
Min parameters: 1. Max parameters 1
Returns the lowercase equivalent of a string
Example:lower('FOO')returnsfoo
lower('FOO')
foo
lt
EvaluatesTrueif left parameter is less than the right parameter
True
Min parameters: 2. Max parameters: 2
Converts right parameter to match type of left parameter. Errors if conversion fails.
Ordinal ignore-case comparison for Strings
Example:lt(2, 5)(returns True)
lt(2, 5)
ne
EvaluatesTrueif parameters are not equal
True
Min parameters: 2. Max parameters: 2
Converts right parameter to match type of left parameter. ReturnsTrueif conversion fails.
True
Ordinal ignore-case comparison for Strings
Example:ne(1, 2)(returns True)
ne(1, 2)
not
EvaluatesTrueif parameter isFalse
True
False
Min parameters: 1. Max parameters: 1
Converts value to Boolean for evaluation
Example:not(eq(1, 2))(returns True)
not(eq(1, 2))
notIn
EvaluatesTrueif left parameter isn't equal to any right parameter
True
Min parameters: 1. Max parameters: N
Converts right parameters to match type of left parameter. Equality comparison evaluatesFalseif conversion fails.
False
Ordinal ignore-case comparison for Strings
Short-circuits after first match
Example:notIn('D', 'A', 'B', 'C')(returns True)
notIn('D', 'A', 'B', 'C')
or
EvaluatesTrueif any parameter isTrue
True
True
Min parameters: 2. Max parameters: N
Casts parameters to Boolean for evaluation
Short-circuits after firstTrue
True
Example:or(eq(1, 1), eq(2, 3))(returns True, short-circuits)
or(eq(1, 1), eq(2, 3))
replace
Returns a new string in which all instances of a string in the current instance are replaced with another string
Min parameters: 3. Max parameters: 3
replace(a, b, c): returns a, with all instances of b replaced by c
replace(a, b, c)
Example:replace('https://www.tinfoilsecurity.com/saml/consume','https://www.tinfoilsecurity.com','http://server')(returnshttp://server/saml/consume)
replace('https://www.tinfoilsecurity.com/saml/consume','https://www.tinfoilsecurity.com','http://server')
http://server/saml/consume
split
Splits a string into substrings based on the specified delimiting characters
Min parameters: 2. Max parameters: 2
The first parameter is the string to split
The second parameter is the delimiting characters
Returns an array of substrings. The array includes empty strings when the delimiting characters appear consecutively or at the end of the string
Example:variables:
- name: environments
  value: prod1,prod2
steps:
  - ${{ each env in split(variables.environments, ',')}}:
    - script: ./deploy.sh --environment ${{ env }}
variables:
- name: environments
  value: prod1,prod2
steps:
  - ${{ each env in split(variables.environments, ',')}}:
    - script: ./deploy.sh --environment ${{ env }}
variables:
- name: environments
  value: prod1,prod2
steps:
  - ${{ each env in split(variables.environments, ',')}}:
    - script: ./deploy.sh --environment ${{ env }}
Example of using split() with replace():parameters:
- name: resourceIds
  type: object
  default:
  - /subscriptions/mysubscription/resourceGroups/myResourceGroup/providers/Microsoft.Network/loadBalancers/kubernetes-internal
  - /subscriptions/mysubscription02/resourceGroups/myResourceGroup02/providers/Microsoft.Network/loadBalancers/kubernetes
- name: environments
  type: object
  default:
  - prod1
  - prod2

trigger:
- main

steps:
- ${{ each env in parameters.environments }}:
  - ${{ each resourceId in parameters.resourceIds }}:
      - script: echo ${{ replace(split(resourceId, '/')[8], '-', '_') }}_${{ env }}
parameters:
- name: resourceIds
  type: object
  default:
  - /subscriptions/mysubscription/resourceGroups/myResourceGroup/providers/Microsoft.Network/loadBalancers/kubernetes-internal
  - /subscriptions/mysubscription02/resourceGroups/myResourceGroup02/providers/Microsoft.Network/loadBalancers/kubernetes
- name: environments
  type: object
  default:
  - prod1
  - prod2

trigger:
- main

steps:
- ${{ each env in parameters.environments }}:
  - ${{ each resourceId in parameters.resourceIds }}:
      - script: echo ${{ replace(split(resourceId, '/')[8], '-', '_') }}_${{ env }}
parameters:
- name: resourceIds
  type: object
  default:
  - /subscriptions/mysubscription/resourceGroups/myResourceGroup/providers/Microsoft.Network/loadBalancers/kubernetes-internal
  - /subscriptions/mysubscription02/resourceGroups/myResourceGroup02/providers/Microsoft.Network/loadBalancers/kubernetes
- name: environments
  type: object
  default:
  - prod1
  - prod2

trigger:
- main

steps:
- ${{ each env in parameters.environments }}:
  - ${{ each resourceId in parameters.resourceIds }}:
      - script: echo ${{ replace(split(resourceId, '/')[8], '-', '_') }}_${{ env }}
startsWith
EvaluatesTrueif left parameter string starts with right parameter
True
Min parameters: 2. Max parameters: 2
Casts parameters to String for evaluation
Performs ordinal ignore-case comparison
Example:startsWith('ABCDE', 'AB')(returns True)
startsWith('ABCDE', 'AB')
trim
Returns the parameter without leading and trailing white spaces
Min parameters: 1. Max parameters: 1
Example:trim('  variable  ')returns 'variable'
trim('  variable  ')
upper
Converts a string or variable value to all uppercase characters
Min parameters: 1. Max parameters 1
Returns the uppercase equivalent of a string
Example:upper('bah')returnsBAH
upper('bah')
BAH
xor
EvaluatesTrueif exactly one parameter isTrue
True
True
Min parameters: 2. Max parameters: 2
Casts parameters to Boolean for evaluation
Example:xor(True, False)(returns True)
xor(True, False)
Job status check functions
You can use the following status check functions as expressions in conditions, but not in variable definitions.
always
Always evaluates toTrue(even when canceled). Note: A critical failure may still prevent a task from running. For example, if getting sources failed.
True
canceled
Evaluates toTrueif the pipeline was canceled.
True
failed
For a step, equivalent toeq(variables['Agent.JobStatus'], 'Failed').
eq(variables['Agent.JobStatus'], 'Failed')
For a job:With no arguments, evaluates toTrueonly if any previous job in the dependency graph failed.With job names as arguments, evaluates toTrueonly if any of those jobs failed.
With no arguments, evaluates toTrueonly if any previous job in the dependency graph failed.
True
With job names as arguments, evaluates toTrueonly if any of those jobs failed.
True
succeeded
For a step, equivalent toin(variables['Agent.JobStatus'], 'Succeeded', 'SucceededWithIssues')
in(variables['Agent.JobStatus'], 'Succeeded', 'SucceededWithIssues')
Use withdependsOnwhen working with jobs and you want to evaluate whether a previous job was successful. Jobs are designed to run in parallel while stages run sequentially.
dependsOn
For a job:With no arguments, evaluates toTrueonly if all previous jobs in the dependency graph succeeded or partially succeeded.With job names as arguments, evaluates toTrueif all of those jobs succeeded or partially succeeded.Evaluates toFalseif the pipeline is canceled.
With no arguments, evaluates toTrueonly if all previous jobs in the dependency graph succeeded or partially succeeded.
True
With job names as arguments, evaluates toTrueif all of those jobs succeeded or partially succeeded.
True
Evaluates toFalseif the pipeline is canceled.
False
succeededOrFailed
For a step, equivalent toin(variables['Agent.JobStatus'], 'Succeeded', 'SucceededWithIssues', 'Failed')
For a step, equivalent toin(variables['Agent.JobStatus'], 'Succeeded', 'SucceededWithIssues', 'Failed')
in(variables['Agent.JobStatus'], 'Succeeded', 'SucceededWithIssues', 'Failed')
For a job:With no arguments, evaluates toTrueregardless of whether any jobs in the dependency graph succeeded or failed.With job names as arguments, evaluates toTruewhether any of those jobs succeeded or failed.You may want to usenot(canceled())instead when there are previous skipped jobs in the dependency graph.This is likealways(), except it will evaluateFalsewhen the pipeline is canceled.
For a job:
With no arguments, evaluates toTrueregardless of whether any jobs in the dependency graph succeeded or failed.
True
With job names as arguments, evaluates toTruewhether any of those jobs succeeded or failed.
True
You may want to usenot(canceled())instead when there are previous skipped jobs in the dependency graph.
not(canceled())
This is likealways(), except it will evaluateFalsewhen the pipeline is canceled.
always()
False
Conditional insertion
You can useif,elseif, andelseclauses to conditionally assign variable values or set inputs for tasks. You can also conditionally run a step when a condition is met.
if
elseif
else
You can useifto conditionally assign variable values or set inputs for tasks. You can also conditionally run a step when a condition is met.
if
Theelseifandelseclauses are available starting with Azure DevOps 2022 and aren't available for Azure DevOps Server 2020 and earlier versions of Azure DevOps.
elseif
else
Conditionals only work when using template syntax. Learn more aboutvariable syntax.
For templates, you can use conditional insertion when adding a sequence or mapping. Learn more aboutconditional insertion in templates.
Conditionally assign a variable
variables:
  ${{ if eq(variables['Build.SourceBranchName'], 'main') }}: # only works if you have a main branch
    stageName: prod

pool:
  vmImage: 'ubuntu-latest'

steps:
- script: echo ${{variables.stageName}}
variables:
  ${{ if eq(variables['Build.SourceBranchName'], 'main') }}: # only works if you have a main branch
    stageName: prod

pool:
  vmImage: 'ubuntu-latest'

steps:
- script: echo ${{variables.stageName}}
Conditionally set a task input
pool:
  vmImage: 'ubuntu-latest'

steps:
- task: PublishPipelineArtifact@1
  inputs:
    targetPath: '$(Pipeline.Workspace)'
    ${{ if eq(variables['Build.SourceBranchName'], 'main') }}:
      artifact: 'prod'
    ${{ else }}:
      artifact: 'dev'
    publishLocation: 'pipeline'
pool:
  vmImage: 'ubuntu-latest'

steps:
- task: PublishPipelineArtifact@1
  inputs:
    targetPath: '$(Pipeline.Workspace)'
    ${{ if eq(variables['Build.SourceBranchName'], 'main') }}:
      artifact: 'prod'
    ${{ else }}:
      artifact: 'dev'
    publishLocation: 'pipeline'
Conditionally run a step
If there's no variable set, or the value offoodoesn't match theifconditions, theelsestatement runs. Here the value offooreturns true in theelseifcondition.
foo
if
else
foo
elseif
variables:
  - name: foo
    value: contoso # triggers elseif condition

pool:
  vmImage: 'ubuntu-latest'

steps:
- script: echo "start"
- ${{ if eq(variables.foo, 'adaptum') }}:
  - script: echo "this is adaptum"
- ${{ elseif eq(variables.foo, 'contoso') }}: # true
  - script: echo "this is contoso"
- ${{ else }}:
  - script: echo "the value is not adaptum or contoso"
variables:
  - name: foo
    value: contoso # triggers elseif condition

pool:
  vmImage: 'ubuntu-latest'

steps:
- script: echo "start"
- ${{ if eq(variables.foo, 'adaptum') }}:
  - script: echo "this is adaptum"
- ${{ elseif eq(variables.foo, 'contoso') }}: # true
  - script: echo "this is contoso"
- ${{ else }}:
  - script: echo "the value is not adaptum or contoso"
Each keyword
You can use theeachkeyword to loop through parameters with the object type.
each
parameters:
- name: listOfStrings
  type: object
  default:
  - one
  - two

steps:
- ${{ each value in parameters.listOfStrings }}:
  - script: echo ${{ value }}
parameters:
- name: listOfStrings
  type: object
  default:
  - one
  - two

steps:
- ${{ each value in parameters.listOfStrings }}:
  - script: echo ${{ value }}
Additionally, you can iterate through nested elements within an object.
parameters:
- name: listOfFruits
  type: object
  default:
  - fruitName: 'apple'
    colors: ['red','green']
  - fruitName: 'lemon'
    colors: ['yellow']
steps:
- ${{ each fruit in parameters.listOfFruits }} :
  - ${{ each fruitColor in fruit.colors}} :
    - script: echo ${{ fruit.fruitName}} ${{ fruitColor }}
parameters:
- name: listOfFruits
  type: object
  default:
  - fruitName: 'apple'
    colors: ['red','green']
  - fruitName: 'lemon'
    colors: ['yellow']
steps:
- ${{ each fruit in parameters.listOfFruits }} :
  - ${{ each fruitColor in fruit.colors}} :
    - script: echo ${{ fruit.fruitName}} ${{ fruitColor }}
Dependencies
Expressions can use the dependencies context to reference previous jobs or stages. You can use dependencies to:
Reference the job status of a previous job
Reference the stage status of a previous stage
Reference output variables in the previous job in the same stage
Reference output variables in the previous stage in a stage
Reference output variables in a job in a previous stage in the following stage
The context is calleddependenciesfor jobs and stages and works much like variables.
If you refer to an output variable from a job in another stage, the context is calledstageDependencies.
dependencies
stageDependencies
If you experience issues with output variables having quote characters ('or") in them, seethis troubleshooting guide.
'
"
Dependency syntax overview
The syntax of referencing output variables with dependencies varies depending on the circumstances. Here's an overview of the most common scenarios. There might be times when alternate syntax also works.
Type
Description
stage to stage dependency(different stages)
Reference an output variable from a previous stage in a job in a different stage in a condition instages.
stages
Syntax:and(succeeded(), eq(stageDependencies.<stage-name>.outputs['<job-name>.<step-name>.<variable-name>'], 'true'))
and(succeeded(), eq(stageDependencies.<stage-name>.outputs['<job-name>.<step-name>.<variable-name>'], 'true'))
Example:and(succeeded(), eq(stageDependencies.A.outputs['A1.printvar.shouldrun'], 'true'))
and(succeeded(), eq(stageDependencies.A.outputs['A1.printvar.shouldrun'], 'true'))
job to job dependency(same stage)
Reference an output variable in a different job in the same stage instages.
stages
Syntax:and(succeeded(), eq(dependencies.<job-name>.outputs['<step-name>.<variable-name>'], 'true'))
and(succeeded(), eq(dependencies.<job-name>.outputs['<step-name>.<variable-name>'], 'true'))
Example:and(succeeded(), eq(dependencies.A.outputs['printvar.shouldrun'], 'true'))
and(succeeded(), eq(dependencies.A.outputs['printvar.shouldrun'], 'true'))
Job to stage dependency(different stages)
Reference an output variable in a different stage in ajob.
job
Syntax:eq(stageDependencies.<stage-name>.<job-name>.outputs['<step-name>.<variable-name>'], 'true')
eq(stageDependencies.<stage-name>.<job-name>.outputs['<step-name>.<variable-name>'], 'true')
Example:eq(stageDependencies.A.A1.outputs['printvar.shouldrun'], 'true')
eq(stageDependencies.A.A1.outputs['printvar.shouldrun'], 'true')
Stage to stage dependency(deployment job)
Reference output variable in a deployment job in a different stage instages.
stages
Syntax:eq(dependencies.<stage-name>.outputs['<deployment-job-name>.<deployment-job-name>.<step-name>.<variable-name>'], 'true')
eq(dependencies.<stage-name>.outputs['<deployment-job-name>.<deployment-job-name>.<step-name>.<variable-name>'], 'true')
Example:eq(dependencies.build.outputs['build_job.build_job.setRunTests.runTests'], 'true')
eq(dependencies.build.outputs['build_job.build_job.setRunTests.runTests'], 'true')
Stage to stage dependency(deployment job with resource)
Reference an output variable in a deployment job that includes a resource in different stage instages.
stages
Syntax:eq(dependencies.<stage-name>.outputs['<deployment-job-name>.<Deploy_resource-name>.<step-name>.<variable-name>'], 'true')
eq(dependencies.<stage-name>.outputs['<deployment-job-name>.<Deploy_resource-name>.<step-name>.<variable-name>'], 'true')
Example:eq(dependencies.build.outputs['build_job.Deploy_winVM.setRunTests.runTests'], 'true')
eq(dependencies.build.outputs['build_job.Deploy_winVM.setRunTests.runTests'], 'true')
There are also different syntaxes for output variables in deployment jobs depending on the deployment strategy. For more information, seeDeployment jobs.
Stage to stage dependencies
Structurally, thedependenciesobject is a map of job and stage names toresultsandoutputs.
Expressed as JSON, it would look like:
dependencies
results
outputs
"dependencies": {
  "<STAGE_NAME>" : {
    "result": "Succeeded|SucceededWithIssues|Skipped|Failed|Canceled",
    "outputs": {
        "jobName.stepName.variableName": "value"
    }
  },
  "...": {
    // another stage
  }
}
"dependencies": {
  "<STAGE_NAME>" : {
    "result": "Succeeded|SucceededWithIssues|Skipped|Failed|Canceled",
    "outputs": {
        "jobName.stepName.variableName": "value"
    }
  },
  "...": {
    // another stage
  }
}
Note
The following examples use standard pipeline syntax. If you're using deployment pipelines, both variable and conditional variable syntax will differ. For information about the specific syntax to use, seeDeployment jobs.
Use this form ofdependenciesto map in variables or check conditions at a stage level.
dependencies
In this example, there are two stages, A and B. Stage A has the conditionfalseand won't ever run as a result. Stage B runs if the result of Stage A isSucceeded,SucceededWithIssues, orSkipped. Stage B runs because Stage A was skipped.
false
Succeeded
SucceededWithIssues
Skipped
stages:
- stage: A
  condition: false
  jobs:
  - job: A1
    steps:
    - script: echo Job A1
- stage: B
  condition: in(dependencies.A.result, 'Succeeded', 'SucceededWithIssues', 'Skipped')
  jobs:
  - job: B1
    steps:
    - script: echo Job B1
stages:
- stage: A
  condition: false
  jobs:
  - job: A1
    steps:
    - script: echo Job A1
- stage: B
  condition: in(dependencies.A.result, 'Succeeded', 'SucceededWithIssues', 'Skipped')
  jobs:
  - job: B1
    steps:
    - script: echo Job B1
Stages can also use output variables from another stage.
In this example, there are also two stages. Stage A includes a job, A1, that sets an output variableshouldruntotrue. Stage B runs whenshouldrunistrue. Becauseshouldrunistrue, Stage B runs.
shouldrun
true
shouldrun
true
shouldrun
true
stages:
- stage: A
  jobs:
  - job: A1
    steps:
     - bash: echo "##vso[task.setvariable variable=shouldrun;isOutput=true]true"
     # or on Windows:
     # - script: echo ##vso[task.setvariable variable=shouldrun;isOutput=true]true
       name: printvar

- stage: B
  condition: and(succeeded(), eq(dependencies.A.outputs['A1.printvar.shouldrun'], 'true'))
  dependsOn: A
  jobs:
  - job: B1
    steps:
    - script: echo hello from Stage B
stages:
- stage: A
  jobs:
  - job: A1
    steps:
     - bash: echo "##vso[task.setvariable variable=shouldrun;isOutput=true]true"
     # or on Windows:
     # - script: echo ##vso[task.setvariable variable=shouldrun;isOutput=true]true
       name: printvar

- stage: B
  condition: and(succeeded(), eq(dependencies.A.outputs['A1.printvar.shouldrun'], 'true'))
  dependsOn: A
  jobs:
  - job: B1
    steps:
    - script: echo hello from Stage B
Note
By default, each stage in a pipeline depends on the one just before it in the YAML file.
If you need to refer to a stage that isn't immediately prior to the current one, you can override this automatic default by adding adependsOnsection to the stage.
dependsOn
Job to job dependencies within one stage
At the job level within a single stage, thedependenciesdata doesn't contain stage-level information.
dependencies
"dependencies": {
  "<JOB_NAME>": {
    "result": "Succeeded|SucceededWithIssues|Skipped|Failed|Canceled",
    "outputs": {
      "stepName.variableName": "value1"
    }
  },
  "...": {
    // another job
  }
}
"dependencies": {
  "<JOB_NAME>": {
    "result": "Succeeded|SucceededWithIssues|Skipped|Failed|Canceled",
    "outputs": {
      "stepName.variableName": "value1"
    }
  },
  "...": {
    // another job
  }
}
In this example, there are three jobs (a, b, and c). Job a will always be skipped because ofcondition: false.
Job b runs because there are no associated conditions.
Job c runs because all of its dependencies either succeed (job b) or are skipped (job a).
condition: false
jobs:
- job: a
  condition: false
  steps:
  - script: echo Job a
- job: b
  steps:
  - script: echo Job b
- job: c
  dependsOn:
  - a
  - b
  condition: |
    and
    (
      in(dependencies.a.result, 'Succeeded', 'SucceededWithIssues', 'Skipped'),
      in(dependencies.b.result, 'Succeeded', 'SucceededWithIssues', 'Skipped')
    )
  steps:
  - script: echo Job c
jobs:
- job: a
  condition: false
  steps:
  - script: echo Job a
- job: b
  steps:
  - script: echo Job b
- job: c
  dependsOn:
  - a
  - b
  condition: |
    and
    (
      in(dependencies.a.result, 'Succeeded', 'SucceededWithIssues', 'Skipped'),
      in(dependencies.b.result, 'Succeeded', 'SucceededWithIssues', 'Skipped')
    )
  steps:
  - script: echo Job c
In this example, Job B depends on an output variable from Job A.
jobs:
- job: A
  steps:
  - bash: echo "##vso[task.setvariable variable=shouldrun;isOutput=true]true"
  # or on Windows:
  # - script: echo ##vso[task.setvariable variable=shouldrun;isOutput=true]true
    name: printvar

- job: B
  condition: and(succeeded(), eq(dependencies.A.outputs['printvar.shouldrun'], 'true'))
  dependsOn: A
  steps:
  - script: echo hello from B
jobs:
- job: A
  steps:
  - bash: echo "##vso[task.setvariable variable=shouldrun;isOutput=true]true"
  # or on Windows:
  # - script: echo ##vso[task.setvariable variable=shouldrun;isOutput=true]true
    name: printvar

- job: B
  condition: and(succeeded(), eq(dependencies.A.outputs['printvar.shouldrun'], 'true'))
  dependsOn: A
  steps:
  - script: echo hello from B
Job to job dependencies across stages
At the job level, you can also reference outputs from a job in a previous stage.
This requires using thestageDependenciescontext.
stageDependencies
"stageDependencies": {
  "<STAGE_NAME>" : {
    "<JOB_NAME>": {
      "result": "Succeeded|SucceededWithIssues|Skipped|Failed|Canceled",
      "outputs": {
          "stepName.variableName": "value"
      }
    },
    "...": {
      // another job
    }
  },
  "...": {
    // another stage
  }
}
"stageDependencies": {
  "<STAGE_NAME>" : {
    "<JOB_NAME>": {
      "result": "Succeeded|SucceededWithIssues|Skipped|Failed|Canceled",
      "outputs": {
          "stepName.variableName": "value"
      }
    },
    "...": {
      // another job
    }
  },
  "...": {
    // another stage
  }
}
In this example, job B1 runs if job A1 is skipped.
Job B2 checks the value of the output variable from job A1 to determine whether it should run.
stages:
- stage: A
  jobs:
  - job: A1
    steps:
     - bash: echo "##vso[task.setvariable variable=shouldrun;isOutput=true]true"
     # or on Windows:
     # - script: echo ##vso[task.setvariable variable=shouldrun;isOutput=true]true
       name: printvar

- stage: B
  dependsOn: A
  jobs:
  - job: B1
    condition: in(stageDependencies.A.A1.result, 'Skipped') # change condition to `Succeeded and stage will be skipped`
    steps:
    - script: echo hello from Job B1
  - job: B2
    condition: eq(stageDependencies.A.A1.outputs['printvar.shouldrun'], 'true')
    steps:
     - script: echo hello from Job B2
stages:
- stage: A
  jobs:
  - job: A1
    steps:
     - bash: echo "##vso[task.setvariable variable=shouldrun;isOutput=true]true"
     # or on Windows:
     # - script: echo ##vso[task.setvariable variable=shouldrun;isOutput=true]true
       name: printvar

- stage: B
  dependsOn: A
  jobs:
  - job: B1
    condition: in(stageDependencies.A.A1.result, 'Skipped') # change condition to `Succeeded and stage will be skipped`
    steps:
    - script: echo hello from Job B1
  - job: B2
    condition: eq(stageDependencies.A.A1.outputs['printvar.shouldrun'], 'true')
    steps:
     - script: echo hello from Job B2
If a job depends on a variable defined by a deployment job in a different stage, then the syntax is different. In the following example, the jobrun_testsruns if thebuild_jobdeployment job setrunTeststotrue. Notice that the key used for theoutputsdictionary isbuild_job.setRunTests.runTests.
run_tests
build_job
runTests
true
outputs
build_job.setRunTests.runTests
stages:
- stage: build
  jobs:
  - deployment: build_job
    environment:
      name: Production
    strategy:
      runOnce:
        deploy:
          steps:
          - task: PowerShell@2
            name: setRunTests
            inputs:
              targetType: inline
              pwsh: true
              script: |
                $runTests = "true"
                echo "setting runTests: $runTests"
                echo "##vso[task.setvariable variable=runTests;isOutput=true]$runTests"

- stage: test
  dependsOn:
  - 'build'
  jobs:
    - job: run_tests
      condition: eq(stageDependencies.build.build_job.outputs['build_job.setRunTests.runTests'], 'true')
      steps:
        ...
stages:
- stage: build
  jobs:
  - deployment: build_job
    environment:
      name: Production
    strategy:
      runOnce:
        deploy:
          steps:
          - task: PowerShell@2
            name: setRunTests
            inputs:
              targetType: inline
              pwsh: true
              script: |
                $runTests = "true"
                echo "setting runTests: $runTests"
                echo "##vso[task.setvariable variable=runTests;isOutput=true]$runTests"

- stage: test
  dependsOn:
  - 'build'
  jobs:
    - job: run_tests
      condition: eq(stageDependencies.build.build_job.outputs['build_job.setRunTests.runTests'], 'true')
      steps:
        ...
Deployment job output variables
If a stage depends on a variable defined by a deployment job in a different stage, then the syntax is different. In the following example, the stagetestdepends on the deploymentbuild_jobsettingshouldTesttotrue. Notice that in theconditionof theteststage,build_jobappears twice.
test
build_job
shouldTest
true
condition
test
build_job
stages:
- stage: build
  jobs:
  - deployment: build_job
    environment:
      name: Production
    strategy:
      runOnce:
        deploy:
          steps:
          - task: PowerShell@2
            name: setRunTests
            inputs:
              targetType: inline
              pwsh: true
              script: |
                $runTests = "true"
                echo "setting runTests: $runTests"
                echo "##vso[task.setvariable variable=runTests;isOutput=true]$runTests"

- stage: test
  dependsOn:
  - 'build'
  condition: eq(dependencies.build.outputs['build_job.build_job.setRunTests.runTests'], 'true')
  jobs:
    - job: A
      steps:
        - script: echo Hello from job A
stages:
- stage: build
  jobs:
  - deployment: build_job
    environment:
      name: Production
    strategy:
      runOnce:
        deploy:
          steps:
          - task: PowerShell@2
            name: setRunTests
            inputs:
              targetType: inline
              pwsh: true
              script: |
                $runTests = "true"
                echo "setting runTests: $runTests"
                echo "##vso[task.setvariable variable=runTests;isOutput=true]$runTests"

- stage: test
  dependsOn:
  - 'build'
  condition: eq(dependencies.build.outputs['build_job.build_job.setRunTests.runTests'], 'true')
  jobs:
    - job: A
      steps:
        - script: echo Hello from job A
In the example above, the condition references an environment and not an environment resource. To reference an environment resource, you'll need to add the environment resource name to the dependencies condition. In the following example, condition references an environment virtual machine resource namedvmtest.
vmtest
stages:
- stage: build
  jobs:
  - deployment: build_job
    environment:
      name: vmtest
      resourceName: winVM2
      resourceType: VirtualMachine
    strategy:
      runOnce:
        deploy:
          steps:
          - task: PowerShell@2
            name: setRunTests
            inputs:
              targetType: inline
              pwsh: true
              script: |
                $runTests = "true"
                echo "setting runTests: $runTests"
                echo "##vso[task.setvariable variable=runTests;isOutput=true]$runTests"

- stage: test
  dependsOn:
  - 'build'
  condition: eq(dependencies.build.outputs['build_job.Deploy_winVM2.setRunTests.runTests'], 'true')
  jobs:
  - job: A
    steps:
     - script: echo Hello from job A
stages:
- stage: build
  jobs:
  - deployment: build_job
    environment:
      name: vmtest
      resourceName: winVM2
      resourceType: VirtualMachine
    strategy:
      runOnce:
        deploy:
          steps:
          - task: PowerShell@2
            name: setRunTests
            inputs:
              targetType: inline
              pwsh: true
              script: |
                $runTests = "true"
                echo "setting runTests: $runTests"
                echo "##vso[task.setvariable variable=runTests;isOutput=true]$runTests"

- stage: test
  dependsOn:
  - 'build'
  condition: eq(dependencies.build.outputs['build_job.Deploy_winVM2.setRunTests.runTests'], 'true')
  jobs:
  - job: A
    steps:
     - script: echo Hello from job A
Filtered arrays
When operating on a collection of items, you can use the*syntax to apply a filtered array. A filtered array returns all objects/elements regardless their names.
*
As an example, consider an array of objects namedfoo. We want to get an array of the values of theidproperty in each object in our array.
foo
id
[
    { "id": 1, "a": "avalue1"},
    { "id": 2, "a": "avalue2"},
    { "id": 3, "a": "avalue3"}
]
[
    { "id": 1, "a": "avalue1"},
    { "id": 2, "a": "avalue2"},
    { "id": 3, "a": "avalue3"}
]
We could do the following:
foo.*.id
foo.*.id
This tells the system to operate onfooas a filtered array and then select theidproperty.
foo
id
This would return:
[ 1, 2, 3 ]
[ 1, 2, 3 ]
Type casting
Values in an expression may be converted from one type to another as the expression gets evaluated.
When an expression is evaluated, the parameters are coalesced to the relevant data type and then turned back into strings.
For example, in this YAML, the valuesTrueandFalseare converted  to1and0when the expression is evaluated.
The functionlt()returnsTruewhen the left parameter is less than the right parameter.
True
False
1
0
lt()
True
variables:
  firstEval: $[lt(False, True)] # 0 vs. 1, True
  secondEval: $[lt(True, False)] # 1 vs. 0, False

steps:
- script: echo $(firstEval)
- script: echo $(secondEval)
variables:
  firstEval: $[lt(False, True)] # 0 vs. 1, True
  secondEval: $[lt(True, False)] # 1 vs. 0, False

steps:
- script: echo $(firstEval)
- script: echo $(secondEval)
When you use theeq()expression for evaluating equivalence, values are implicitly converted to numbers (falseto0andtrueto1).
eq()
false
0
true
1
variables:
  trueAsNumber: $[eq('true', true)] # 1 vs. 1, True
  falseAsNumber: $[eq('false', true)] # 0 vs. 1, False

steps:
- script: echo $(trueAsNumber)
- script: echo $(falseAsNumber)
variables:
  trueAsNumber: $[eq('true', true)] # 1 vs. 1, True
  falseAsNumber: $[eq('false', true)] # 0 vs. 1, False

steps:
- script: echo $(trueAsNumber)
- script: echo $(falseAsNumber)
In this next example, the valuesvariables.emptyStringand the empty string both evaluate as empty strings.
The functioncoalesce()evaluates the parameters in order, and returns the first value that doesn't equal null or empty-string.
variables.emptyString
coalesce()
variables:
  coalesceLiteral: $[coalesce(variables.emptyString, '', 'literal value')]

steps:
- script: echo $(coalesceLiteral) # outputs literal value
variables:
  coalesceLiteral: $[coalesce(variables.emptyString, '', 'literal value')]

steps:
- script: echo $(coalesceLiteral) # outputs literal value
Detailed conversion rules are listed further below.
Boolean
To number:
Falseâ0
False
0
Trueâ1
True
1
To string:
Falseâ'False'
False
'False'
Trueâ'True'
True
'True'
Null
To Boolean:False
False
To number:0
0
To string:''(the empty string)
''
Number
To Boolean:0âFalse, any other number âTrue
0
False
True
To version: Must be greater than zero and must contain a nonzero decimal. Must be less thanInt32.MaxValue(decimal component also).
To string:
Converts the number to a string with no thousands separator and no decimal separator.
String
To Boolean:''(the empty string) âFalse, any other string âTrue
''
False
True
To null:''(the empty string) âNull, any other string not convertible
''
Null
To number:''(the empty string) â 0, otherwise, runs C#'sInt32.TryParseusingInvariantCultureand the following rules: AllowDecimalPoint | AllowLeadingSign | AllowLeadingWhite | AllowThousands | AllowTrailingWhite. IfTryParsefails, then it's not convertible.
''
Int32.TryParse
TryParse
To version:
runs C#'sVersion.TryParse. Must contain Major and Minor component at minimum. IfTryParsefails, then it's not convertible.
Version.TryParse
TryParse
Version
To Boolean:True
True
To string: Major.Minor or Major.Minor.Build or Major.Minor.Build.Revision.
FAQ
I want to do something that isn't supported by expressions. What options do I have for extending Pipelines functionality?
You can customize your Pipeline with a script that includes an expression. For example, this snippet takes theBUILD_BUILDNUMBERvariable and splits it with Bash. This script outputs two new variables,$MAJOR_RUNand$MINOR_RUN, for the major and minor run numbers.
The two variables are then used to create two pipeline variables,$majorand$minorwithtask.setvariable. These variables are available to downstream steps. To share variables across pipelines seeVariable groups.
BUILD_BUILDNUMBER
$MAJOR_RUN
$MINOR_RUN
$major
$minor
steps:
- bash: |
    MAJOR_RUN=$(echo $BUILD_BUILDNUMBER | cut -d '.' -f1)
    echo "This is the major run number: $MAJOR_RUN"
    echo "##vso[task.setvariable variable=major]$MAJOR_RUN"

    MINOR_RUN=$(echo $BUILD_BUILDNUMBER | cut -d '.' -f2)
    echo "This is the minor run number: $MINOR_RUN"
    echo "##vso[task.setvariable variable=minor]$MINOR_RUN"

- bash: echo "My pipeline variable for major run is $(major)"
- bash: echo "My pipeline variable for minor run is $(minor)"
steps:
- bash: |
    MAJOR_RUN=$(echo $BUILD_BUILDNUMBER | cut -d '.' -f1)
    echo "This is the major run number: $MAJOR_RUN"
    echo "##vso[task.setvariable variable=major]$MAJOR_RUN"

    MINOR_RUN=$(echo $BUILD_BUILDNUMBER | cut -d '.' -f2)
    echo "This is the minor run number: $MINOR_RUN"
    echo "##vso[task.setvariable variable=minor]$MINOR_RUN"

- bash: echo "My pipeline variable for major run is $(major)"
- bash: echo "My pipeline variable for minor run is $(minor)"
Feedback
Was this page helpful?
Additional resources