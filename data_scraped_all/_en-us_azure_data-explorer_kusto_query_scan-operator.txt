Note
Access to this page requires authorization. You can trysigning inorchanging directories.
Access to this page requires authorization. You can trychanging directories.
scan operator
Article
2025-01-22
7 contributors
In this article
Applies to: âMicrosoft FabricâAzure Data ExplorerâAzure MonitorâMicrosoft Sentinel
Scans data, matches, and builds sequences based on the predicates.
Matching records are determined according to predicates defined in the operatorâs steps. A predicate can depend on the state that is generated by previous steps.
The output for the matching record is determined by the input record and assignments defined in the operator's steps.
Syntax
T| scan[with_match_id=MatchIdColumnName] [declare(ColumnDeclarations)]with(StepDefinitions)
| scan
with_match_id
=
declare
(
)
with
(
)
ColumnDeclarationssyntax
ColumnName:ColumnType[=DefaultValue] [,... ]
:
=
,
StepDefinitionsyntax
stepStepName[output=all|last|none]:Condition[=>Column=Assignment[,... ] ];
step
output
all
last
none
:
=>
=
,
;
Learn more aboutsyntax conventions.
Parameters
string
string
long
string
null
string
string
true
false
true
string
output
string
all
last
none
all
Returns
A record for each match of a record from the input to a step. The schema of the output is the schema of the source extended with the column in thedeclareclause.
declare
Scan logic
scangoes over the serialized input data, record by record, comparing each record against each stepâs condition while taking into account the current state of each step.
scan
State
The underlying state of thescanoperator can be thought of as a table with a row for eachstep. Each step maintains its own state with the latest values of the columns and declared variables from all of the previous steps and the current step. If relevant, it also holds the match ID for the ongoing sequence.
scan
step
If a scan operator hasnsteps nameds_1,s_2, ...,s_nthen steps_kwould havekrecords in its state corresponding tos_1,s_2, ...,s_k. TheStepName.ColumnNameformat is used to reference a value in the state. For instance,s_2.col1would reference columncol1that belongs to steps_2in the state ofs_k. For a detailed example, see thescan logic walkthrough.
s_2.col1
col1
The state starts empty and updates whenever a scanned input record matches a step. When the state of the current step is nonempty, the step is referred to as having anactive sequence.
Matching logic
Each input record is evaluated against all of the steps in reverse order, from the last step to the first. When a recordris evaluated against some steps_k, the following logic is applied:
Check 1:If the state of the previous step (s_k-1) is nonempty, andrmeets theConditionofs_k, then a match occurs. The match leads to the following actions:The state ofs_kis cleared.The state ofs_k-1is promoted to become the state ofs_k.The assignments ofs_kare calculated and extendr.The extendedris added to the output and to the state ofs_k.NoteIfCheck 1results in a match,Check 2is disregarded, andrmoves on to be evaluated againsts_k-1.
Check 1:If the state of the previous step (s_k-1) is nonempty, andrmeets theConditionofs_k, then a match occurs. The match leads to the following actions:
The state ofs_kis cleared.
The state ofs_k-1is promoted to become the state ofs_k.
The assignments ofs_kare calculated and extendr.
The extendedris added to the output and to the state ofs_k.
Note
IfCheck 1results in a match,Check 2is disregarded, andrmoves on to be evaluated againsts_k-1.
Check 2:If the state ofs_khas an active sequence ors_kis the first step, andrmeets theConditionofs_k, then a match occurs. The match leads to the following actions:The assignments ofs_kare calculated and extendr.The values that represents_kin the state ofs_kare replaced with the values of the extendedr.Ifs_kis defined asoutput=all, the extendedris added to the output.Ifs_kis the first step, a new sequence begins and the match ID increases by1. This only affects the output whenwith_match_idis used.
Check 2:If the state ofs_khas an active sequence ors_kis the first step, andrmeets theConditionofs_k, then a match occurs. The match leads to the following actions:
The assignments ofs_kare calculated and extendr.
The values that represents_kin the state ofs_kare replaced with the values of the extendedr.
Ifs_kis defined asoutput=all, the extendedris added to the output.
output=all
Ifs_kis the first step, a new sequence begins and the match ID increases by1. This only affects the output whenwith_match_idis used.
1
with_match_id
Once the checks fors_kare complete,rmoves on to be evaluated againsts_k-1.
For a detailed example of this logic, see thescan logic walkthrough.
Examples
The example in this section shows how to use the syntax to help you get started.
The examples in this article use publicly available tables in thehelp cluster, such as theStormEventstable in theSamplesdatabase.
StormEvents
The examples in this article use publicly available tables, such as theStormEventstable in the Weather analyticssample data.
StormEvents
Cumulative sum
Calculate the cumulative sum for an input column. The result of this example is equivalent to usingrow_cumsum().
Run the query
range x from 1 to 5 step 1 
| scan declare (cumulative_x:long=0) with 
(
    step s1: true => cumulative_x = x + s1.cumulative_x;
)
range x from 1 to 5 step 1 
| scan declare (cumulative_x:long=0) with 
(
    step s1: true => cumulative_x = x + s1.cumulative_x;
)
Output
Cumulative sum on multiple columns with a reset condition
Calculate the cumulative sum for two input columns, reset the sum value to the current record value whenever the cumulative sum reached 10 or more.
Run the query
range x from 1 to 5 step 1
| extend y = 2 * x
| scan declare (cumulative_x:long=0, cumulative_y:long=0) with 
(
    step s1: true => cumulative_x = iff(s1.cumulative_x >= 10, x, x + s1.cumulative_x), 
                     cumulative_y = iff(s1.cumulative_y >= 10, y, y + s1.cumulative_y);
)
range x from 1 to 5 step 1
| extend y = 2 * x
| scan declare (cumulative_x:long=0, cumulative_y:long=0) with 
(
    step s1: true => cumulative_x = iff(s1.cumulative_x >= 10, x, x + s1.cumulative_x), 
                     cumulative_y = iff(s1.cumulative_y >= 10, y, y + s1.cumulative_y);
)
Output
Fill forward a column
Fill forward a string column. Each empty value is assigned the last seen nonempty value.
Run the query
let Events = datatable (Ts: timespan, Event: string) [
    0m, "A",
    1m, "",
    2m, "B",
    3m, "",
    4m, "",
    6m, "C",
    8m, "",
    11m, "D",
    12m, ""
]
;
Events
| sort by Ts asc
| scan declare (Event_filled: string="") with 
(
    step s1: true => Event_filled = iff(isempty(Event), s1.Event_filled, Event);
)
let Events = datatable (Ts: timespan, Event: string) [
    0m, "A",
    1m, "",
    2m, "B",
    3m, "",
    4m, "",
    6m, "C",
    8m, "",
    11m, "D",
    12m, ""
]
;
Events
| sort by Ts asc
| scan declare (Event_filled: string="") with 
(
    step s1: true => Event_filled = iff(isempty(Event), s1.Event_filled, Event);
)
Output
Sessions tagging
Divide the input into sessions: a session ends 30 minutes after the first event of the session, after which a new session starts. Note the use ofwith_match_idflag, which assigns a unique value for each distinct match (session) ofscan. Also note the special use of twostepsin this example,inSessionhastrueas condition so it captures and outputs all the records from the input whileendSessioncaptures records that happen more than 30m from thesessionStartvalue for the current match. TheendSessionstep hasoutput=nonemeaning it doesn't produce output records. TheendSessionstep is used to advance the state of the current match frominSessiontoendSession, allowing a new match (session) to begin, starting from the current record.
with_match_id
inSession
true
endSession
sessionStart
endSession
output=none
endSession
inSession
endSession
Run the query
let Events = datatable (Ts: timespan, Event: string) [
    0m, "A",
    1m, "A",
    2m, "B",
    3m, "D",
    32m, "B",
    36m, "C",
    38m, "D",
    41m, "E",
    75m, "A"
]
;
Events
| sort by Ts asc
| scan with_match_id=session_id declare (sessionStart: timespan) with 
(
    step inSession: true => sessionStart = iff(isnull(inSession.sessionStart), Ts, inSession.sessionStart);
    step endSession output=none: Ts - inSession.sessionStart > 30m;
)
let Events = datatable (Ts: timespan, Event: string) [
    0m, "A",
    1m, "A",
    2m, "B",
    3m, "D",
    32m, "B",
    36m, "C",
    38m, "D",
    41m, "E",
    75m, "A"
]
;
Events
| sort by Ts asc
| scan with_match_id=session_id declare (sessionStart: timespan) with 
(
    step inSession: true => sessionStart = iff(isnull(inSession.sessionStart), Ts, inSession.sessionStart);
    step endSession output=none: Ts - inSession.sessionStart > 30m;
)
Output
Events between Start and Stop
Find all sequences of events between the eventStartand the eventStopthat occur within 5 minutes. Assign a match ID for each sequence.
Start
Stop
Run the query
let Events = datatable (Ts: timespan, Event: string) [
    0m, "A",
    1m, "Start",
    2m, "B",
    3m, "D",
    4m, "Stop",
    6m, "C",
    8m, "Start",
    11m, "E",
    12m, "Stop"
]
;
Events
| sort by Ts asc
| scan with_match_id=m_id with 
(
    step s1: Event == "Start";
    step s2: Event != "Start" and Event != "Stop" and Ts - s1.Ts <= 5m;
    step s3: Event == "Stop" and Ts - s1.Ts <= 5m;
)
let Events = datatable (Ts: timespan, Event: string) [
    0m, "A",
    1m, "Start",
    2m, "B",
    3m, "D",
    4m, "Stop",
    6m, "C",
    8m, "Start",
    11m, "E",
    12m, "Stop"
]
;
Events
| sort by Ts asc
| scan with_match_id=m_id with 
(
    step s1: Event == "Start";
    step s2: Event != "Start" and Event != "Stop" and Ts - s1.Ts <= 5m;
    step s3: Event == "Stop" and Ts - s1.Ts <= 5m;
)
Output
Calculate a custom funnel of events
Calculate a funnel completion of the sequenceHail->Tornado->Thunderstorm WindbyStatewith custom thresholds on the times between the events (Tornadowithin1handThunderstorm Windwithin2h). This example is similar to thefunnel_sequence_completion plugin, but allows greater flexibility.
Hail
Tornado
Thunderstorm Wind
State
Tornado
1h
Thunderstorm Wind
2h
Run the query
StormEvents
| partition hint.strategy=native by State 
    (
    sort by StartTime asc
    | scan with 
    (
        step hail: EventType == "Hail";
        step tornado: EventType == "Tornado" and StartTime - hail.StartTime <= 1h;
        step thunderstormWind: EventType == "Thunderstorm Wind" and StartTime - tornado.StartTime <= 2h;
    )
    )
| summarize dcount(State) by EventType
StormEvents
| partition hint.strategy=native by State 
    (
    sort by StartTime asc
    | scan with 
    (
        step hail: EventType == "Hail";
        step tornado: EventType == "Tornado" and StartTime - hail.StartTime <= 1h;
        step thunderstormWind: EventType == "Thunderstorm Wind" and StartTime - tornado.StartTime <= 2h;
    )
    )
| summarize dcount(State) by EventType
Output
Scan logic walkthrough
This section demonstrates thescan logicusing a step-by-step walkthrough of theEvents between start and stopexample:
Run the query
let Events = datatable (Ts: timespan, Event: string) [
    0m, "A",
    1m, "Start",
    2m, "B",
    3m, "D",
    4m, "Stop",
    6m, "C",
    8m, "Start",
    11m, "E",
    12m, "Stop"
]
;
Events
| sort by Ts asc
| scan with_match_id=m_id with 
(
    step s1: Event == "Start";
    step s2: Event != "Start" and Event != "Stop" and Ts - s1.Ts <= 5m;
    step s3: Event == "Stop" and Ts - s1.Ts <= 5m;
)
let Events = datatable (Ts: timespan, Event: string) [
    0m, "A",
    1m, "Start",
    2m, "B",
    3m, "D",
    4m, "Stop",
    6m, "C",
    8m, "Start",
    11m, "E",
    12m, "Stop"
]
;
Events
| sort by Ts asc
| scan with_match_id=m_id with 
(
    step s1: Event == "Start";
    step s2: Event != "Start" and Event != "Stop" and Ts - s1.Ts <= 5m;
    step s3: Event == "Stop" and Ts - s1.Ts <= 5m;
)
Output
The state
Think of the state of thescanoperator as a table with a row for each step, in which each step has its own state. This state contains the latest values of the columns and declared variables from all of the previous steps and the current step. To learn more, seeState.
scan
For this example, the state can be represented with the following table:
The "X" indicates that a specific field is irrelevant for that step.
The matching logic
This section follows thematching logicthrough each record of theEventstable, explaining the transformation of the state and output at each step.
Events
Note
An input record is evaluated against the steps in reverse order, from the last step (s3) to the first step (s1).
s3
s1
Record evaluation at each step:
s3:Check 1isn't passed because the state ofs2is empty, andCheck 2isn't passed becauses3lacks an active sequence.
s3
s2
s3
s2:Check 1isn't passed because the state ofs1is empty, andCheck 2isn't passed becauses2lacks an active sequence.
s2
s1
s2
s1:Check 1is irrelevant because there's no previous step.Check 2isn't passed because the record doesn't meet the condition ofEvent == "Start".Record 1is discarded without affecting the state or output.
s1
Event == "Start"
State:
Record evaluation at each step:
s3:Check 1isn't passed because the state ofs2is empty, andCheck 2isn't passed becauses3lacks an active sequence.
s3
s2
s3
s2:Check 1isn't passed because the state ofs1is empty, andCheck 2isn't passed becauses2lacks an active sequence.
s2
s1
s2
s1:Check 1is irrelevant because there's no previous step.Check 2is passed because the record meets the condition ofEvent == "Start". This match initiates a new sequence, and them_idis assigned.Record 2and itsm_id(0) are added to the state and the output.
s1
Event == "Start"
m_id
m_id
0
State:
Record evaluation at each step:
s3:Check 1isn't passed because the state ofs2is empty, andCheck 2isn't passed becauses3lacks an active sequence.
s3
s2
s3
s2:Check 1is passed because the state ofs1is nonempty and the record meets the condition ofTs - s1.Ts < 5m. This match causes the state ofs1to be cleared and the sequence ins1to be promoted tos2.Record 3and itsm_id(0) are added to the state and the output.
s2
s1
Ts - s1.Ts < 5m
s1
s1
s2
m_id
0
s1:Check 1is irrelevant because there's no previous step, andCheck 2isn't passed because the record doesn't meet the condition ofEvent == "Start".
s1
Event == "Start"
State:
Record evaluation at each step:
s3:Check 1isn't passed because the record doesn't meet the condition ofEvent == "Stop", andCheck 2isn't passed becauses3lacks an active sequence.
s3
Event == "Stop"
s3
s2:Check 1isn't passed because the state ofs1is empty. it passesCheck 2because it meets the condition ofTs - s1.Ts < 5m.Record 4and itsm_id(0) are added to the state and the output. The values from this record overwrite the previous state values fors2.Tsands2.Event.
s2
s1
Ts - s1.Ts < 5m
m_id
0
s2.Ts
s2.Event
s1:Check 1is irrelevant because there's no previous step, andCheck 2isn't passed because the record doesn't meet the condition ofEvent == "Start".
s1
Event == "Start"
State:
Record evaluation at each step:
s3:Check 1is passed becauses2is nonempty and it meets thes3condition ofEvent == "Stop". This match causes the state ofs2to be cleared and the sequence ins2to be promoted tos3.Record 5and itsm_id(0) are added to the state and the output.
s3
s2
s3
Event == "Stop"
s2
s2
s3
m_id
0
s2:Check 1isn't passed because the state ofs1is empty, andCheck 2isn't passed becauses2lacks an active sequence.
s2
s1
s2
s1:Check 1is irrelevant because there's no previous step.Check 2isn't passed because the record doesn't meet the condition ofEvent == "Start".
s1
Event == "Start"
State:
Record evaluation at each step:
s3:Check 1isn't passed because the state ofs2is empty, andCheck 2isn't passed becauses3doesn't meet thes3condition ofEvent == "Stop".
s3
s2
s3
s3
Event == "Stop"
s2:Check 1isn't passed because the state ofs1is empty, andCheck 2isn't passed becauses2lacks an active sequence.
s2
s1
s2
s1:Check 1isn't passed because there's no previous step, andCheck 2isn't passed because it doesn't meet the condition ofEvent == "Start".Record 6is discarded without affecting the state or output.
s1
Event == "Start"
State:
Record evaluation at each step:
s3:Check 1isn't passed because the state ofs2is empty, andCheck 2isn't passed because it doesn't meet the condition ofEvent == "Stop".
s3
s2
Event == "Stop"
s2:Check 1isn't passed because the state ofs1is empty, andCheck 2isn't passed becauses2lacks an active sequence.
s2
s1
s2
s1:Check 1isn't passed because there's no previous step. it passesCheck 2because it meets the condition ofEvent == "Start". This match initiates a new sequence ins1with a newm_id.Record 7and itsm_id(1) are added to the state and the output.
s1
Event == "Start"
s1
m_id
m_id
1
State:
Note
There are now two active sequences in the state.
Record evaluation at each step:
s3:Check 1isn't passed because the state ofs2is empty, andCheck 2isn't passed because it doesn't meet thes3condition ofEvent == "Stop".
s3
s2
s3
Event == "Stop"
s2:Check 1is passed because the state ofs1is nonempty and the record meets the condition ofTs - s1.Ts < 5m. This match causes the state ofs1to be cleared and the sequence ins1to be promoted tos2.Record 8and itsm_id(1) are added to the state and the output.
s2
s1
Ts - s1.Ts < 5m
s1
s1
s2
m_id
1
s1:Check 1is irrelevant because there's no previous step, andCheck 2isn't passed because the record doesn't meet the condition ofEvent == "Start".
s1
Event == "Start"
State:
Record evaluation at each step:
s3:Check 1is passed becauses2is nonempty and it meets thes3condition ofEvent == "Stop". This match causes the state ofs2to be cleared and the sequence ins2to be promoted tos3.Record 9and itsm_id(1) are added to the state and the output.
s3
s2
s3
Event == "Stop"
s2
s2
s3
m_id
1
s2:Check 1isn't passed because the state ofs1is empty, andCheck 2isn't passed becauses2lacks an active sequence.
s2
s1
s2
s1:Check 1isn't passed because there's no previous step. it passesCheck 2because it meets the condition ofEvent == "Start". This match initiates a new sequence ins1with a newm_id.
s1
Event == "Start"
s1
m_id
State:
Feedback
Was this page helpful?
Additional resources